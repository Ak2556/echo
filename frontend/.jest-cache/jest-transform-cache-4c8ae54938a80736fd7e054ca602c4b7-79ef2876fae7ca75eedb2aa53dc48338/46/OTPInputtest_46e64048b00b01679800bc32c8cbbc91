51ab08e8e9f63a2103fb3c2d948a0dea
/**
 * OTPInput Component Tests
 * Comprehensive test suite for OTP input functionality
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _userevent = /*#__PURE__*/ _interop_require_default(require("@testing-library/user-event"));
const _OTPInput = /*#__PURE__*/ _interop_require_default(require("../OTPInput"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
describe('OTPInput', ()=>{
    const user = _userevent.default.setup();
    const mockOnComplete = jest.fn();
    const mockOnChange = jest.fn();
    // Helper to focus elements - userEvent.click handles act() internally
    const focusElement = async (element)=>{
        await user.click(element);
    };
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    describe('Component Rendering', ()=>{
        it('renders correct number of input fields', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            expect(inputs).toHaveLength(6);
        });
        it('renders with custom length', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 4,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            expect(inputs).toHaveLength(4);
        });
        it('renders with proper structure', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const container = _react1.screen.getAllByRole('textbox')[0].closest('.otp-input-container');
            expect(container).toBeInTheDocument();
        });
        it('shows loading state', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete,
                loading: true
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            inputs.forEach((input)=>{
                expect(input).toBeDisabled();
            });
        });
        it('shows error state', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete,
                error: "Invalid OTP"
            }));
            expect(_react1.screen.getByText('Invalid OTP')).toBeInTheDocument();
        });
    });
    describe('Input Behavior', ()=>{
        it('accepts only numeric input', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const firstInput = _react1.screen.getAllByRole('textbox')[0];
            await user.type(firstInput, 'a');
            expect(firstInput).toHaveValue('');
            await user.type(firstInput, '1');
            expect(firstInput).toHaveValue('1');
        });
        it('moves to next input after entering digit', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            await user.type(inputs[0], '1');
            expect(inputs[1]).toHaveFocus();
        });
        it('moves to previous input on backspace', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            // Type in first input and move to second
            await user.type(inputs[0], '1');
            expect(inputs[1]).toHaveFocus();
            // Backspace should move back to first input
            await user.keyboard('{Backspace}');
            expect(inputs[0]).toHaveFocus();
        });
        it('replaces existing digit when typing', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const firstInput = _react1.screen.getAllByRole('textbox')[0];
            await user.type(firstInput, '1');
            expect(firstInput).toHaveValue('1');
            // Clear and type new digit
            await user.clear(firstInput);
            await user.type(firstInput, '2');
            expect(firstInput).toHaveValue('2');
        });
        it('handles arrow key navigation', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            await focusElement(inputs[0]);
            await user.keyboard('{ArrowRight}');
            expect(inputs[1]).toHaveFocus();
            await user.keyboard('{ArrowLeft}');
            expect(inputs[0]).toHaveFocus();
        });
        it('handles Home key to jump to first input', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            await focusElement(inputs[3]);
            expect(inputs[3]).toHaveFocus();
            await user.keyboard('{Home}');
            expect(inputs[0]).toHaveFocus();
        });
        it('handles End key to jump to last input', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            await focusElement(inputs[2]);
            expect(inputs[2]).toHaveFocus();
            await user.keyboard('{End}');
            expect(inputs[5]).toHaveFocus();
        });
        it('handles backspace on filled input to clear it', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            // Fill first input
            await user.type(inputs[0], '1');
            expect(inputs[0]).toHaveValue('1');
            // Go back to first input
            await focusElement(inputs[0]);
            // Backspace should clear current input
            await user.keyboard('{Backspace}');
            expect(inputs[0]).toHaveValue('');
        });
        it('handles multi-character input from rapid typing', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            // Start from middle input
            await focusElement(inputs[2]);
            // Simulate rapid multi-character input
            _react1.fireEvent.change(inputs[2], {
                target: {
                    value: '345'
                }
            });
            await (0, _react1.waitFor)(()=>{
                expect(inputs[2]).toHaveValue('3');
                expect(inputs[3]).toHaveValue('4');
                expect(inputs[4]).toHaveValue('5');
            });
        });
    });
    describe('Paste Functionality', ()=>{
        it('handles paste of complete OTP', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const firstInput = _react1.screen.getAllByRole('textbox')[0];
            await focusElement(firstInput);
            // Simulate paste event
            const pasteEvent = new ClipboardEvent('paste', {
                clipboardData: new DataTransfer()
            });
            pasteEvent.clipboardData?.setData('text/plain', '123456');
            _react1.fireEvent.paste(firstInput, pasteEvent);
            await (0, _react1.waitFor)(()=>{
                expect(mockOnComplete).toHaveBeenCalledWith('123456');
            });
        });
        it('handles paste of partial OTP', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const firstInput = _react1.screen.getAllByRole('textbox')[0];
            await focusElement(firstInput);
            const pasteEvent = new ClipboardEvent('paste', {
                clipboardData: new DataTransfer()
            });
            pasteEvent.clipboardData?.setData('text/plain', '123');
            _react1.fireEvent.paste(firstInput, pasteEvent);
            await (0, _react1.waitFor)(()=>{
                const inputs = _react1.screen.getAllByRole('textbox');
                expect(inputs[0]).toHaveValue('1');
                expect(inputs[1]).toHaveValue('2');
                expect(inputs[2]).toHaveValue('3');
                expect(inputs[2]).toHaveFocus();
            });
        });
        it('ignores non-numeric paste content', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const firstInput = _react1.screen.getAllByRole('textbox')[0];
            await focusElement(firstInput);
            const pasteEvent = new ClipboardEvent('paste', {
                clipboardData: new DataTransfer()
            });
            pasteEvent.clipboardData?.setData('text/plain', 'abc123');
            _react1.fireEvent.paste(firstInput, pasteEvent);
            // Should not fill any inputs with invalid characters
            const inputs = _react1.screen.getAllByRole('textbox');
            inputs.forEach((input)=>{
                expect(input).toHaveValue('');
            });
        });
        it('handles paste longer than input length', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 4,
                onComplete: mockOnComplete
            }));
            const firstInput = _react1.screen.getAllByRole('textbox')[0];
            await focusElement(firstInput);
            const pasteEvent = new ClipboardEvent('paste', {
                clipboardData: new DataTransfer()
            });
            pasteEvent.clipboardData?.setData('text/plain', '123456789');
            _react1.fireEvent.paste(firstInput, pasteEvent);
            await (0, _react1.waitFor)(()=>{
                expect(mockOnComplete).toHaveBeenCalledWith('1234');
            });
        });
    });
    describe('Completion Handling', ()=>{
        it('calls onComplete when all fields are filled', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 4,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            await user.type(inputs[0], '1');
            await user.type(inputs[1], '2');
            await user.type(inputs[2], '3');
            await user.type(inputs[3], '4');
            expect(mockOnComplete).toHaveBeenCalledWith('1234');
        });
        it('updates internal state on input change', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 4,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            await user.type(inputs[0], '1');
            expect(inputs[0]).toHaveValue('1');
            await user.type(inputs[1], '2');
            expect(inputs[1]).toHaveValue('2');
        });
        it('does not call onComplete for incomplete OTP', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            await user.type(inputs[0], '1');
            await user.type(inputs[1], '2');
            await user.type(inputs[2], '3');
            expect(mockOnComplete).not.toHaveBeenCalled();
        });
    });
    describe('Component State Management', ()=>{
        it('maintains internal state correctly', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            await user.type(inputs[0], '1');
            await user.type(inputs[1], '2');
            await user.type(inputs[2], '3');
            expect(inputs[0]).toHaveValue('1');
            expect(inputs[1]).toHaveValue('2');
            expect(inputs[2]).toHaveValue('3');
        });
        it('resets state when component remounts', ()=>{
            const { unmount } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            unmount();
            // Render a new instance
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            inputs.forEach((input)=>{
                expect(input).toHaveValue('');
            });
        });
    });
    describe('Accessibility', ()=>{
        it('has proper ARIA attributes', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            inputs.forEach((input, index)=>{
                expect(input).toHaveAttribute('aria-label', `Digit ${index + 1} of 6`);
                expect(input).toHaveAttribute('inputMode', 'numeric');
            });
        });
        it('supports screen readers with live region', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const liveRegion = _react1.screen.getByRole('status');
            expect(liveRegion).toHaveAttribute('aria-live', 'polite');
            expect(liveRegion).toHaveAttribute('aria-atomic', 'true');
        });
        it('announces errors to screen readers', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete,
                error: "Invalid OTP"
            }));
            const errorElement = _react1.screen.getByText('Invalid OTP');
            expect(errorElement).toHaveAttribute('role', 'alert');
        });
    });
    describe('Security', ()=>{
        it('does not expose OTP in DOM attributes', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            inputs.forEach((input)=>{
                expect(input).not.toHaveAttribute('data-value');
                expect(input).not.toHaveAttribute('title');
            });
        });
        it('uses proper input mode for numeric input', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            inputs.forEach((input)=>{
                expect(input).toHaveAttribute('inputMode', 'numeric');
                expect(input).toHaveAttribute('maxLength', '1');
            });
        });
    });
    describe('Edge Cases', ()=>{
        it('handles rapid typing', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            // Type rapidly in sequence
            await user.type(inputs[0], '123456');
            await (0, _react1.waitFor)(()=>{
                expect(mockOnComplete).toHaveBeenCalledWith('123456');
            });
        });
        it('handles focus events correctly', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            // Focus on middle input
            await focusElement(inputs[2]);
            expect(inputs[2]).toHaveFocus();
            // Type should work from any focused input
            await user.type(inputs[2], '5');
            expect(inputs[2]).toHaveValue('5');
        });
        it('handles loading state correctly', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete,
                loading: true
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            inputs.forEach((input)=>{
                expect(input).toBeDisabled();
            });
            expect(_react1.screen.getByText('Verifying...')).toBeInTheDocument();
        });
        it('handles error state correctly', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete,
                error: "Invalid code"
            }));
            expect(_react1.screen.getByText('Invalid code')).toBeInTheDocument();
            expect(_react1.screen.getByRole('alert')).toBeInTheDocument();
        });
    });
    describe('Performance', ()=>{
        it('does not cause unnecessary re-renders', ()=>{
            const renderSpy = jest.fn();
            const TestComponent = ()=>{
                renderSpy();
                return /*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                });
            };
            const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            expect(renderSpy).toHaveBeenCalledTimes(1);
            // Re-render with same props
            rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            // Should not cause additional renders due to memoization
            expect(renderSpy).toHaveBeenCalledTimes(2);
        });
    });
    describe('Production Error Scenarios', ()=>{
        describe('Network and API Failures', ()=>{
            it('calls onComplete callback when code is complete', async ()=>{
                const successCallback = jest.fn();
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: successCallback
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                await user.type(inputs[0], '123456');
                await (0, _react1.waitFor)(()=>{
                    expect(successCallback).toHaveBeenCalledWith('123456');
                });
            });
            it('allows multiple callback invocations', async ()=>{
                const callback = jest.fn();
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 4,
                    onComplete: callback
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                // First code
                await user.type(inputs[0], '1234');
                await (0, _react1.waitFor)(()=>{
                    expect(callback).toHaveBeenCalledTimes(1);
                });
                // Clear and enter new code
                for(let i = 0; i < 4; i++){
                    await user.clear(inputs[i]);
                }
                await user.type(inputs[0], '5678');
                await (0, _react1.waitFor)(()=>{
                    expect(callback).toHaveBeenCalledTimes(2);
                });
            });
            it('passes correct code to callback', async ()=>{
                let receivedCode = '';
                const callback = jest.fn((code)=>{
                    receivedCode = code;
                });
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: callback
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                await user.type(inputs[0], '987654');
                await (0, _react1.waitFor)(()=>{
                    expect(receivedCode).toBe('987654');
                });
            });
        });
        describe('Memory and Resource Management', ()=>{
            it('cleans up event listeners on unmount', ()=>{
                const { unmount } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                // Component should unmount without errors
                expect(()=>unmount()).not.toThrow();
            });
            it('handles rapid component mount/unmount cycles', ()=>{
                for(let i = 0; i < 10; i++){
                    const { unmount } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                        length: 6,
                        onComplete: mockOnComplete
                    }));
                    unmount();
                }
                // Should not leak memory or throw errors
                expect(true).toBe(true);
            });
            it('handles extremely long OTP codes efficiently', ()=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 20,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                expect(inputs).toHaveLength(20);
                // Should render without performance issues
                expect(container).toBeInTheDocument();
            });
        });
        describe('Race Conditions and Timing Issues', ()=>{
            it('handles simultaneous input changes', async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                // Simulate rapid, simultaneous changes
                await user.type(inputs[0], '1');
                await user.type(inputs[1], '2');
                await user.type(inputs[2], '3');
                // Should handle gracefully - check that at least one input has a value
                const hasValues = inputs.some((input)=>input.getAttribute('value') !== '');
                expect(hasValues).toBe(true);
            });
            it('handles onChange during loading state', async ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    loading: false
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                await user.type(inputs[0], '1');
                // Switch to loading mid-input
                rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    loading: true
                }));
                // Inputs should be disabled
                const updatedInputs = _react1.screen.getAllByRole('textbox');
                updatedInputs.forEach((input)=>{
                    expect(input).toBeDisabled();
                });
            });
            it('handles onComplete being called multiple times for same code', async ()=>{
                const callback = jest.fn();
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 4,
                    onComplete: callback
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                await user.type(inputs[0], '1234');
                await (0, _react1.waitFor)(()=>{
                    expect(callback).toHaveBeenCalledTimes(1);
                });
                // Typing same code again
                await user.clear(inputs[0]);
                await user.type(inputs[0], '1234');
                // Should be called again
                expect(callback).toHaveBeenCalledTimes(2);
            });
            it('handles rapid error state changes', async ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    error: ""
                }));
                for(let i = 0; i < 10; i++){
                    rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                        length: 6,
                        onComplete: mockOnComplete,
                        error: `Error ${i}`
                    }));
                    await new Promise((resolve)=>setTimeout(resolve, 10));
                    rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                        length: 6,
                        onComplete: mockOnComplete,
                        error: ""
                    }));
                }
                // Should handle rapid changes without crashing
                expect(_react1.screen.getAllByRole('textbox')).toHaveLength(6);
            });
        });
        describe('Input Validation Edge Cases', ()=>{
            it('handles special Unicode digits', async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                // Try to input Unicode mathematical digits
                await user.type(inputs[0], 'ðŸðŸðŸ‘');
                // Should reject non-ASCII digits
                expect(inputs[0]).toHaveValue('');
            });
            it('handles mixed valid and invalid characters in paste', async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const firstInput = _react1.screen.getAllByRole('textbox')[0];
                await focusElement(firstInput);
                const pasteEvent = new ClipboardEvent('paste', {
                    clipboardData: new DataTransfer()
                });
                pasteEvent.clipboardData?.setData('text/plain', '12abc34');
                _react1.fireEvent.paste(firstInput, pasteEvent);
                // Should reject entire paste due to invalid characters
                const inputs = _react1.screen.getAllByRole('textbox');
                inputs.forEach((input)=>{
                    expect(input).toHaveValue('');
                });
            });
            it('handles whitespace in pasted content', async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const firstInput = _react1.screen.getAllByRole('textbox')[0];
                await focusElement(firstInput);
                const pasteEvent = new ClipboardEvent('paste', {
                    clipboardData: new DataTransfer()
                });
                pasteEvent.clipboardData?.setData('text/plain', '  123456  ');
                _react1.fireEvent.paste(firstInput, pasteEvent);
                await (0, _react1.waitFor)(()=>{
                    expect(mockOnComplete).toHaveBeenCalledWith('123456');
                });
            });
            it('handles newlines in pasted content', async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const firstInput = _react1.screen.getAllByRole('textbox')[0];
                await focusElement(firstInput);
                const pasteEvent = new ClipboardEvent('paste', {
                    clipboardData: new DataTransfer()
                });
                pasteEvent.clipboardData?.setData('text/plain', '123\n456');
                _react1.fireEvent.paste(firstInput, pasteEvent);
                // Should reject due to newline
                const inputs = _react1.screen.getAllByRole('textbox');
                inputs.forEach((input)=>{
                    expect(input).toHaveValue('');
                });
            });
            it('handles zero-width characters', async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                // Try to input zero-width space
                await user.type(inputs[0], '1\u200B2');
                // Should only accept the digits
                expect(inputs[0]).toHaveValue('1');
            });
        });
        describe('Browser Compatibility Edge Cases', ()=>{
            it('handles missing clipboardData gracefully', ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const firstInput = _react1.screen.getAllByRole('textbox')[0];
                // Simulate old browser without clipboardData
                const pasteEvent = new Event('paste');
                (0, _react1.fireEvent)(firstInput, pasteEvent);
                // Should not crash
                expect(firstInput).toBeInTheDocument();
            });
            it('handles inputs without select method', async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                // Component should handle missing select method gracefully
                // This tests defensive programming for older browsers
                expect(inputs[0]).toBeInTheDocument();
                expect(typeof inputs[0].select).toBe('function');
            });
            it('handles focus on null refs gracefully', ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                // Component should handle null refs internally
                expect(_react1.screen.getAllByRole('textbox')).toHaveLength(6);
            });
        });
        describe('High Load Scenarios', ()=>{
            it('handles 1000+ rapid keystrokes', async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                // Simulate user mashing keys rapidly
                for(let i = 0; i < 1000; i++){
                    const randomInput = inputs[Math.floor(Math.random() * inputs.length)];
                    const randomKey = Math.floor(Math.random() * 10).toString();
                    _react1.fireEvent.change(randomInput, {
                        target: {
                            value: randomKey
                        }
                    });
                }
                // Should still be functional
                expect(inputs[0]).toBeInTheDocument();
            });
            it('handles continuous paste operations', async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const firstInput = _react1.screen.getAllByRole('textbox')[0];
                for(let i = 0; i < 100; i++){
                    const pasteEvent = new ClipboardEvent('paste', {
                        clipboardData: new DataTransfer()
                    });
                    pasteEvent.clipboardData?.setData('text/plain', `${100000 + i}`.slice(0, 6));
                    _react1.fireEvent.paste(firstInput, pasteEvent);
                }
                // Should handle without memory leaks
                expect(firstInput).toBeInTheDocument();
            });
            it('handles alternating focus between all inputs', async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                // Rapidly switch focus
                await (0, _react1.act)(async ()=>{
                    for(let i = 0; i < 100; i++){
                        inputs[i % 6].focus();
                    }
                });
                // Should handle gracefully
                expect(inputs.some((input)=>input === document.activeElement)).toBe(true);
            });
        });
        describe('Accessibility Under Stress', ()=>{
            it('maintains ARIA attributes during rapid state changes', async ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                for(let i = 0; i < 10; i++){
                    rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                        length: 6,
                        onComplete: mockOnComplete,
                        error: `Error ${i}`
                    }));
                    const inputs = _react1.screen.getAllByRole('textbox');
                    inputs.forEach((input, idx)=>{
                        expect(input).toHaveAttribute('aria-label', `Digit ${idx + 1} of 6`);
                        expect(input).toHaveAttribute('aria-invalid', 'true');
                    });
                    rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                        length: 6,
                        onComplete: mockOnComplete,
                        error: ""
                    }));
                }
            });
            it('maintains live region updates during high activity', async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const liveRegion = _react1.screen.getByRole('status');
                const inputs = _react1.screen.getAllByRole('textbox');
                for(let i = 0; i < 6; i++){
                    await user.type(inputs[i], (i + 1).toString());
                    expect(liveRegion).toBeInTheDocument();
                }
            });
        });
        describe('Component Lifecycle Edge Cases', ()=>{
            it('handles length prop changing dynamically', ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 4,
                    onComplete: mockOnComplete
                }));
                expect(_react1.screen.getAllByRole('textbox')).toHaveLength(4);
                // Changing length prop creates a new component instance
                // The component doesn't dynamically resize, so this test documents the behavior
                rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 8,
                    onComplete: mockOnComplete
                }));
                // Component will still have 4 inputs as it doesn't re-initialize
                expect(_react1.screen.getAllByRole('textbox').length).toBeGreaterThan(0);
            });
            it('handles onComplete callback changing', async ()=>{
                const callback1 = jest.fn();
                const callback2 = jest.fn();
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 4,
                    onComplete: callback1
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                await user.type(inputs[0], '1234');
                await (0, _react1.waitFor)(()=>{
                    expect(callback1).toHaveBeenCalled();
                });
                // Change callback
                rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 4,
                    onComplete: callback2
                }));
                await user.clear(inputs[0]);
                await user.type(inputs[0], '5678');
                await (0, _react1.waitFor)(()=>{
                    expect(callback2).toHaveBeenCalled();
                });
            });
            it('handles parent component re-renders', ()=>{
                const ParentComponent = ({ count })=>/*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                        children: [
                            /*#__PURE__*/ (0, _jsxruntime.jsx)("span", {
                                children: count
                            }),
                            /*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                                length: 6,
                                onComplete: mockOnComplete
                            })
                        ]
                    });
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(ParentComponent, {
                    count: 0
                }));
                for(let i = 0; i < 100; i++){
                    rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(ParentComponent, {
                        count: i
                    }));
                }
                expect(_react1.screen.getAllByRole('textbox')).toHaveLength(6);
            });
        });
        describe('Error Recovery', ()=>{
            it('recovers from error state when user corrects input', async ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    error: "Invalid code"
                }));
                expect(_react1.screen.getByText('Invalid code')).toBeInTheDocument();
                rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    error: ""
                }));
                expect(_react1.screen.queryByText('Invalid code')).not.toBeInTheDocument();
            });
            it('allows re-entry after error', async ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    error: "Try again"
                }));
                rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    error: ""
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                await user.type(inputs[0], '123456');
                await (0, _react1.waitFor)(()=>{
                    expect(mockOnComplete).toHaveBeenCalledWith('123456');
                });
            });
            it('clears input when error is shown', async ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                await user.type(inputs[0], '123');
                // Show error - simulating failed verification
                rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    error: "Invalid"
                }));
                // User should be able to clear and retry
                await user.clear(inputs[0]);
                await user.type(inputs[0], '456');
                expect(inputs[0]).toHaveValue('4');
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2VjaG8vZWNoby9mcm9udGVuZC9zcmMvY29tcG9uZW50cy9hdXRoL19fdGVzdHNfXy9PVFBJbnB1dC50ZXN0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE9UUElucHV0IENvbXBvbmVudCBUZXN0c1xuICogQ29tcHJlaGVuc2l2ZSB0ZXN0IHN1aXRlIGZvciBPVFAgaW5wdXQgZnVuY3Rpb25hbGl0eVxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQge1xuICByZW5kZXIsXG4gIHNjcmVlbixcbiAgZmlyZUV2ZW50LFxuICB3YWl0Rm9yLFxuICBhY3QsXG59IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnO1xuaW1wb3J0IHVzZXJFdmVudCBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQnO1xuaW1wb3J0IE9UUElucHV0IGZyb20gJ0AvY29tcG9uZW50cy9hdXRoL09UUElucHV0JztcblxuZGVzY3JpYmUoJ09UUElucHV0JywgKCkgPT4ge1xuICBjb25zdCB1c2VyID0gdXNlckV2ZW50LnNldHVwKCk7XG4gIGNvbnN0IG1vY2tPbkNvbXBsZXRlID0gamVzdC5mbigpO1xuICBjb25zdCBtb2NrT25DaGFuZ2UgPSBqZXN0LmZuKCk7XG5cbiAgLy8gSGVscGVyIHRvIGZvY3VzIGVsZW1lbnRzIC0gdXNlckV2ZW50LmNsaWNrIGhhbmRsZXMgYWN0KCkgaW50ZXJuYWxseVxuICBjb25zdCBmb2N1c0VsZW1lbnQgPSBhc3luYyAoZWxlbWVudDogSFRNTEVsZW1lbnQpID0+IHtcbiAgICBhd2FpdCB1c2VyLmNsaWNrKGVsZW1lbnQpO1xuICB9O1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ29tcG9uZW50IFJlbmRlcmluZycsICgpID0+IHtcbiAgICBpdCgncmVuZGVycyBjb3JyZWN0IG51bWJlciBvZiBpbnB1dCBmaWVsZHMnLCAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuICAgICAgZXhwZWN0KGlucHV0cykudG9IYXZlTGVuZ3RoKDYpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3JlbmRlcnMgd2l0aCBjdXN0b20gbGVuZ3RoJywgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezR9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcbiAgICAgIGV4cGVjdChpbnB1dHMpLnRvSGF2ZUxlbmd0aCg0KTtcbiAgICB9KTtcblxuICAgIGl0KCdyZW5kZXJzIHdpdGggcHJvcGVyIHN0cnVjdHVyZScsICgpID0+IHtcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuXG4gICAgICBjb25zdCBjb250YWluZXIgPSBzY3JlZW5cbiAgICAgICAgLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpWzBdXG4gICAgICAgIC5jbG9zZXN0KCcub3RwLWlucHV0LWNvbnRhaW5lcicpO1xuICAgICAgZXhwZWN0KGNvbnRhaW5lcikudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG93cyBsb2FkaW5nIHN0YXRlJywgKCkgPT4ge1xuICAgICAgcmVuZGVyKFxuICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gbG9hZGluZz17dHJ1ZX0gLz5cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcbiAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgICBleHBlY3QoaW5wdXQpLnRvQmVEaXNhYmxlZCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvd3MgZXJyb3Igc3RhdGUnLCAoKSA9PiB7XG4gICAgICByZW5kZXIoXG4gICAgICAgIDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSBlcnJvcj1cIkludmFsaWQgT1RQXCIgLz5cbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdJbnZhbGlkIE9UUCcpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnSW5wdXQgQmVoYXZpb3InLCAoKSA9PiB7XG4gICAgaXQoJ2FjY2VwdHMgb25seSBudW1lcmljIGlucHV0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGZpcnN0SW5wdXQgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94JylbMF07XG5cbiAgICAgIGF3YWl0IHVzZXIudHlwZShmaXJzdElucHV0LCAnYScpO1xuICAgICAgZXhwZWN0KGZpcnN0SW5wdXQpLnRvSGF2ZVZhbHVlKCcnKTtcblxuICAgICAgYXdhaXQgdXNlci50eXBlKGZpcnN0SW5wdXQsICcxJyk7XG4gICAgICBleHBlY3QoZmlyc3RJbnB1dCkudG9IYXZlVmFsdWUoJzEnKTtcbiAgICB9KTtcblxuICAgIGl0KCdtb3ZlcyB0byBuZXh0IGlucHV0IGFmdGVyIGVudGVyaW5nIGRpZ2l0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcblxuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzEnKTtcbiAgICAgIGV4cGVjdChpbnB1dHNbMV0pLnRvSGF2ZUZvY3VzKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnbW92ZXMgdG8gcHJldmlvdXMgaW5wdXQgb24gYmFja3NwYWNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcblxuICAgICAgLy8gVHlwZSBpbiBmaXJzdCBpbnB1dCBhbmQgbW92ZSB0byBzZWNvbmRcbiAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMF0sICcxJyk7XG4gICAgICBleHBlY3QoaW5wdXRzWzFdKS50b0hhdmVGb2N1cygpO1xuXG4gICAgICAvLyBCYWNrc3BhY2Ugc2hvdWxkIG1vdmUgYmFjayB0byBmaXJzdCBpbnB1dFxuICAgICAgYXdhaXQgdXNlci5rZXlib2FyZCgne0JhY2tzcGFjZX0nKTtcbiAgICAgIGV4cGVjdChpbnB1dHNbMF0pLnRvSGF2ZUZvY3VzKCk7XG4gICAgfSk7XG5cbiAgICBpdCgncmVwbGFjZXMgZXhpc3RpbmcgZGlnaXQgd2hlbiB0eXBpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgZmlyc3RJbnB1dCA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKVswXTtcblxuICAgICAgYXdhaXQgdXNlci50eXBlKGZpcnN0SW5wdXQsICcxJyk7XG4gICAgICBleHBlY3QoZmlyc3RJbnB1dCkudG9IYXZlVmFsdWUoJzEnKTtcblxuICAgICAgLy8gQ2xlYXIgYW5kIHR5cGUgbmV3IGRpZ2l0XG4gICAgICBhd2FpdCB1c2VyLmNsZWFyKGZpcnN0SW5wdXQpO1xuICAgICAgYXdhaXQgdXNlci50eXBlKGZpcnN0SW5wdXQsICcyJyk7XG4gICAgICBleHBlY3QoZmlyc3RJbnB1dCkudG9IYXZlVmFsdWUoJzInKTtcbiAgICB9KTtcblxuICAgIGl0KCdoYW5kbGVzIGFycm93IGtleSBuYXZpZ2F0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcblxuICAgICAgYXdhaXQgZm9jdXNFbGVtZW50KGlucHV0c1swXSk7XG5cbiAgICAgIGF3YWl0IHVzZXIua2V5Ym9hcmQoJ3tBcnJvd1JpZ2h0fScpO1xuICAgICAgZXhwZWN0KGlucHV0c1sxXSkudG9IYXZlRm9jdXMoKTtcblxuICAgICAgYXdhaXQgdXNlci5rZXlib2FyZCgne0Fycm93TGVmdH0nKTtcbiAgICAgIGV4cGVjdChpbnB1dHNbMF0pLnRvSGF2ZUZvY3VzKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyBIb21lIGtleSB0byBqdW1wIHRvIGZpcnN0IGlucHV0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcblxuICAgICAgYXdhaXQgZm9jdXNFbGVtZW50KGlucHV0c1szXSk7XG4gICAgICBleHBlY3QoaW5wdXRzWzNdKS50b0hhdmVGb2N1cygpO1xuXG4gICAgICBhd2FpdCB1c2VyLmtleWJvYXJkKCd7SG9tZX0nKTtcbiAgICAgIGV4cGVjdChpbnB1dHNbMF0pLnRvSGF2ZUZvY3VzKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyBFbmQga2V5IHRvIGp1bXAgdG8gbGFzdCBpbnB1dCcsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuXG4gICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgIGF3YWl0IGZvY3VzRWxlbWVudChpbnB1dHNbMl0pO1xuICAgICAgZXhwZWN0KGlucHV0c1syXSkudG9IYXZlRm9jdXMoKTtcblxuICAgICAgYXdhaXQgdXNlci5rZXlib2FyZCgne0VuZH0nKTtcbiAgICAgIGV4cGVjdChpbnB1dHNbNV0pLnRvSGF2ZUZvY3VzKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyBiYWNrc3BhY2Ugb24gZmlsbGVkIGlucHV0IHRvIGNsZWFyIGl0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcblxuICAgICAgLy8gRmlsbCBmaXJzdCBpbnB1dFxuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzEnKTtcbiAgICAgIGV4cGVjdChpbnB1dHNbMF0pLnRvSGF2ZVZhbHVlKCcxJyk7XG5cbiAgICAgIC8vIEdvIGJhY2sgdG8gZmlyc3QgaW5wdXRcbiAgICAgIGF3YWl0IGZvY3VzRWxlbWVudChpbnB1dHNbMF0pO1xuXG4gICAgICAvLyBCYWNrc3BhY2Ugc2hvdWxkIGNsZWFyIGN1cnJlbnQgaW5wdXRcbiAgICAgIGF3YWl0IHVzZXIua2V5Ym9hcmQoJ3tCYWNrc3BhY2V9Jyk7XG4gICAgICBleHBlY3QoaW5wdXRzWzBdKS50b0hhdmVWYWx1ZSgnJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyBtdWx0aS1jaGFyYWN0ZXIgaW5wdXQgZnJvbSByYXBpZCB0eXBpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICAvLyBTdGFydCBmcm9tIG1pZGRsZSBpbnB1dFxuICAgICAgYXdhaXQgZm9jdXNFbGVtZW50KGlucHV0c1syXSk7XG5cbiAgICAgIC8vIFNpbXVsYXRlIHJhcGlkIG11bHRpLWNoYXJhY3RlciBpbnB1dFxuICAgICAgZmlyZUV2ZW50LmNoYW5nZShpbnB1dHNbMl0sIHsgdGFyZ2V0OiB7IHZhbHVlOiAnMzQ1JyB9IH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KGlucHV0c1syXSkudG9IYXZlVmFsdWUoJzMnKTtcbiAgICAgICAgZXhwZWN0KGlucHV0c1szXSkudG9IYXZlVmFsdWUoJzQnKTtcbiAgICAgICAgZXhwZWN0KGlucHV0c1s0XSkudG9IYXZlVmFsdWUoJzUnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUGFzdGUgRnVuY3Rpb25hbGl0eScsICgpID0+IHtcbiAgICBpdCgnaGFuZGxlcyBwYXN0ZSBvZiBjb21wbGV0ZSBPVFAnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgZmlyc3RJbnB1dCA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKVswXTtcbiAgICAgIGF3YWl0IGZvY3VzRWxlbWVudChmaXJzdElucHV0KTtcblxuICAgICAgLy8gU2ltdWxhdGUgcGFzdGUgZXZlbnRcbiAgICAgIGNvbnN0IHBhc3RlRXZlbnQgPSBuZXcgQ2xpcGJvYXJkRXZlbnQoJ3Bhc3RlJywge1xuICAgICAgICBjbGlwYm9hcmREYXRhOiBuZXcgRGF0YVRyYW5zZmVyKCksXG4gICAgICB9KTtcbiAgICAgIHBhc3RlRXZlbnQuY2xpcGJvYXJkRGF0YT8uc2V0RGF0YSgndGV4dC9wbGFpbicsICcxMjM0NTYnKTtcblxuICAgICAgZmlyZUV2ZW50LnBhc3RlKGZpcnN0SW5wdXQsIHBhc3RlRXZlbnQpO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KG1vY2tPbkNvbXBsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnMTIzNDU2Jyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdoYW5kbGVzIHBhc3RlIG9mIHBhcnRpYWwgT1RQJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGZpcnN0SW5wdXQgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94JylbMF07XG4gICAgICBhd2FpdCBmb2N1c0VsZW1lbnQoZmlyc3RJbnB1dCk7XG5cbiAgICAgIGNvbnN0IHBhc3RlRXZlbnQgPSBuZXcgQ2xpcGJvYXJkRXZlbnQoJ3Bhc3RlJywge1xuICAgICAgICBjbGlwYm9hcmREYXRhOiBuZXcgRGF0YVRyYW5zZmVyKCksXG4gICAgICB9KTtcbiAgICAgIHBhc3RlRXZlbnQuY2xpcGJvYXJkRGF0YT8uc2V0RGF0YSgndGV4dC9wbGFpbicsICcxMjMnKTtcblxuICAgICAgZmlyZUV2ZW50LnBhc3RlKGZpcnN0SW5wdXQsIHBhc3RlRXZlbnQpO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuICAgICAgICBleHBlY3QoaW5wdXRzWzBdKS50b0hhdmVWYWx1ZSgnMScpO1xuICAgICAgICBleHBlY3QoaW5wdXRzWzFdKS50b0hhdmVWYWx1ZSgnMicpO1xuICAgICAgICBleHBlY3QoaW5wdXRzWzJdKS50b0hhdmVWYWx1ZSgnMycpO1xuICAgICAgICBleHBlY3QoaW5wdXRzWzJdKS50b0hhdmVGb2N1cygpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnaWdub3JlcyBub24tbnVtZXJpYyBwYXN0ZSBjb250ZW50JywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGZpcnN0SW5wdXQgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94JylbMF07XG4gICAgICBhd2FpdCBmb2N1c0VsZW1lbnQoZmlyc3RJbnB1dCk7XG5cbiAgICAgIGNvbnN0IHBhc3RlRXZlbnQgPSBuZXcgQ2xpcGJvYXJkRXZlbnQoJ3Bhc3RlJywge1xuICAgICAgICBjbGlwYm9hcmREYXRhOiBuZXcgRGF0YVRyYW5zZmVyKCksXG4gICAgICB9KTtcbiAgICAgIHBhc3RlRXZlbnQuY2xpcGJvYXJkRGF0YT8uc2V0RGF0YSgndGV4dC9wbGFpbicsICdhYmMxMjMnKTtcblxuICAgICAgZmlyZUV2ZW50LnBhc3RlKGZpcnN0SW5wdXQsIHBhc3RlRXZlbnQpO1xuXG4gICAgICAvLyBTaG91bGQgbm90IGZpbGwgYW55IGlucHV0cyB3aXRoIGludmFsaWQgY2hhcmFjdGVyc1xuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuICAgICAgaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICAgIGV4cGVjdChpbnB1dCkudG9IYXZlVmFsdWUoJycpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyBwYXN0ZSBsb25nZXIgdGhhbiBpbnB1dCBsZW5ndGgnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17NH0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgZmlyc3RJbnB1dCA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKVswXTtcbiAgICAgIGF3YWl0IGZvY3VzRWxlbWVudChmaXJzdElucHV0KTtcblxuICAgICAgY29uc3QgcGFzdGVFdmVudCA9IG5ldyBDbGlwYm9hcmRFdmVudCgncGFzdGUnLCB7XG4gICAgICAgIGNsaXBib2FyZERhdGE6IG5ldyBEYXRhVHJhbnNmZXIoKSxcbiAgICAgIH0pO1xuICAgICAgcGFzdGVFdmVudC5jbGlwYm9hcmREYXRhPy5zZXREYXRhKCd0ZXh0L3BsYWluJywgJzEyMzQ1Njc4OScpO1xuXG4gICAgICBmaXJlRXZlbnQucGFzdGUoZmlyc3RJbnB1dCwgcGFzdGVFdmVudCk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QobW9ja09uQ29tcGxldGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcxMjM0Jyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvbXBsZXRpb24gSGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ2NhbGxzIG9uQ29tcGxldGUgd2hlbiBhbGwgZmllbGRzIGFyZSBmaWxsZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17NH0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnMScpO1xuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1sxXSwgJzInKTtcbiAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMl0sICczJyk7XG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzNdLCAnNCcpO1xuXG4gICAgICBleHBlY3QobW9ja09uQ29tcGxldGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcxMjM0Jyk7XG4gICAgfSk7XG5cbiAgICBpdCgndXBkYXRlcyBpbnRlcm5hbCBzdGF0ZSBvbiBpbnB1dCBjaGFuZ2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17NH0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnMScpO1xuICAgICAgZXhwZWN0KGlucHV0c1swXSkudG9IYXZlVmFsdWUoJzEnKTtcblxuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1sxXSwgJzInKTtcbiAgICAgIGV4cGVjdChpbnB1dHNbMV0pLnRvSGF2ZVZhbHVlKCcyJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnZG9lcyBub3QgY2FsbCBvbkNvbXBsZXRlIGZvciBpbmNvbXBsZXRlIE9UUCcsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuXG4gICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMF0sICcxJyk7XG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzFdLCAnMicpO1xuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1syXSwgJzMnKTtcblxuICAgICAgZXhwZWN0KG1vY2tPbkNvbXBsZXRlKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ29tcG9uZW50IFN0YXRlIE1hbmFnZW1lbnQnLCAoKSA9PiB7XG4gICAgaXQoJ21haW50YWlucyBpbnRlcm5hbCBzdGF0ZSBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnMScpO1xuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1sxXSwgJzInKTtcbiAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMl0sICczJyk7XG5cbiAgICAgIGV4cGVjdChpbnB1dHNbMF0pLnRvSGF2ZVZhbHVlKCcxJyk7XG4gICAgICBleHBlY3QoaW5wdXRzWzFdKS50b0hhdmVWYWx1ZSgnMicpO1xuICAgICAgZXhwZWN0KGlucHV0c1syXSkudG9IYXZlVmFsdWUoJzMnKTtcbiAgICB9KTtcblxuICAgIGl0KCdyZXNldHMgc3RhdGUgd2hlbiBjb21wb25lbnQgcmVtb3VudHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHVubW91bnQgfSA9IHJlbmRlcihcbiAgICAgICAgPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+XG4gICAgICApO1xuXG4gICAgICB1bm1vdW50KCk7XG5cbiAgICAgIC8vIFJlbmRlciBhIG5ldyBpbnN0YW5jZVxuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcbiAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgICBleHBlY3QoaW5wdXQpLnRvSGF2ZVZhbHVlKCcnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQWNjZXNzaWJpbGl0eScsICgpID0+IHtcbiAgICBpdCgnaGFzIHByb3BlciBBUklBIGF0dHJpYnV0ZXMnLCAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuICAgICAgaW5wdXRzLmZvckVhY2goKGlucHV0LCBpbmRleCkgPT4ge1xuICAgICAgICBleHBlY3QoaW5wdXQpLnRvSGF2ZUF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGBEaWdpdCAke2luZGV4ICsgMX0gb2YgNmApO1xuICAgICAgICBleHBlY3QoaW5wdXQpLnRvSGF2ZUF0dHJpYnV0ZSgnaW5wdXRNb2RlJywgJ251bWVyaWMnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3N1cHBvcnRzIHNjcmVlbiByZWFkZXJzIHdpdGggbGl2ZSByZWdpb24nLCAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgbGl2ZVJlZ2lvbiA9IHNjcmVlbi5nZXRCeVJvbGUoJ3N0YXR1cycpO1xuICAgICAgZXhwZWN0KGxpdmVSZWdpb24pLnRvSGF2ZUF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ3BvbGl0ZScpO1xuICAgICAgZXhwZWN0KGxpdmVSZWdpb24pLnRvSGF2ZUF0dHJpYnV0ZSgnYXJpYS1hdG9taWMnLCAndHJ1ZScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2Fubm91bmNlcyBlcnJvcnMgdG8gc2NyZWVuIHJlYWRlcnMnLCAoKSA9PiB7XG4gICAgICByZW5kZXIoXG4gICAgICAgIDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSBlcnJvcj1cIkludmFsaWQgT1RQXCIgLz5cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGVycm9yRWxlbWVudCA9IHNjcmVlbi5nZXRCeVRleHQoJ0ludmFsaWQgT1RQJyk7XG4gICAgICBleHBlY3QoZXJyb3JFbGVtZW50KS50b0hhdmVBdHRyaWJ1dGUoJ3JvbGUnLCAnYWxlcnQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1NlY3VyaXR5JywgKCkgPT4ge1xuICAgIGl0KCdkb2VzIG5vdCBleHBvc2UgT1RQIGluIERPTSBhdHRyaWJ1dGVzJywgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcbiAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgICBleHBlY3QoaW5wdXQpLm5vdC50b0hhdmVBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnKTtcbiAgICAgICAgZXhwZWN0KGlucHV0KS5ub3QudG9IYXZlQXR0cmlidXRlKCd0aXRsZScpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgndXNlcyBwcm9wZXIgaW5wdXQgbW9kZSBmb3IgbnVtZXJpYyBpbnB1dCcsICgpID0+IHtcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuXG4gICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG4gICAgICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgICAgZXhwZWN0KGlucHV0KS50b0hhdmVBdHRyaWJ1dGUoJ2lucHV0TW9kZScsICdudW1lcmljJyk7XG4gICAgICAgIGV4cGVjdChpbnB1dCkudG9IYXZlQXR0cmlidXRlKCdtYXhMZW5ndGgnLCAnMScpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFZGdlIENhc2VzJywgKCkgPT4ge1xuICAgIGl0KCdoYW5kbGVzIHJhcGlkIHR5cGluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuXG4gICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgIC8vIFR5cGUgcmFwaWRseSBpbiBzZXF1ZW5jZVxuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzEyMzQ1NicpO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KG1vY2tPbkNvbXBsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnMTIzNDU2Jyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdoYW5kbGVzIGZvY3VzIGV2ZW50cyBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICAvLyBGb2N1cyBvbiBtaWRkbGUgaW5wdXRcbiAgICAgIGF3YWl0IGZvY3VzRWxlbWVudChpbnB1dHNbMl0pO1xuICAgICAgZXhwZWN0KGlucHV0c1syXSkudG9IYXZlRm9jdXMoKTtcblxuICAgICAgLy8gVHlwZSBzaG91bGQgd29yayBmcm9tIGFueSBmb2N1c2VkIGlucHV0XG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzJdLCAnNScpO1xuICAgICAgZXhwZWN0KGlucHV0c1syXSkudG9IYXZlVmFsdWUoJzUnKTtcbiAgICB9KTtcblxuICAgIGl0KCdoYW5kbGVzIGxvYWRpbmcgc3RhdGUgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgcmVuZGVyKFxuICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gbG9hZGluZz17dHJ1ZX0gLz5cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcbiAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgICBleHBlY3QoaW5wdXQpLnRvQmVEaXNhYmxlZCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdWZXJpZnlpbmcuLi4nKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdoYW5kbGVzIGVycm9yIHN0YXRlIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIHJlbmRlcihcbiAgICAgICAgPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IGVycm9yPVwiSW52YWxpZCBjb2RlXCIgLz5cbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdJbnZhbGlkIGNvZGUnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlSb2xlKCdhbGVydCcpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgaXQoJ2RvZXMgbm90IGNhdXNlIHVubmVjZXNzYXJ5IHJlLXJlbmRlcnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCByZW5kZXJTcHkgPSBqZXN0LmZuKCk7XG5cbiAgICAgIGNvbnN0IFRlc3RDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICAgIHJlbmRlclNweSgpO1xuICAgICAgICByZXR1cm4gPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+O1xuICAgICAgfTtcblxuICAgICAgY29uc3QgeyByZXJlbmRlciB9ID0gcmVuZGVyKDxUZXN0Q29tcG9uZW50IC8+KTtcblxuICAgICAgZXhwZWN0KHJlbmRlclNweSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuXG4gICAgICAvLyBSZS1yZW5kZXIgd2l0aCBzYW1lIHByb3BzXG4gICAgICByZXJlbmRlcig8VGVzdENvbXBvbmVudCAvPik7XG5cbiAgICAgIC8vIFNob3VsZCBub3QgY2F1c2UgYWRkaXRpb25hbCByZW5kZXJzIGR1ZSB0byBtZW1vaXphdGlvblxuICAgICAgZXhwZWN0KHJlbmRlclNweSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUHJvZHVjdGlvbiBFcnJvciBTY2VuYXJpb3MnLCAoKSA9PiB7XG4gICAgZGVzY3JpYmUoJ05ldHdvcmsgYW5kIEFQSSBGYWlsdXJlcycsICgpID0+IHtcbiAgICAgIGl0KCdjYWxscyBvbkNvbXBsZXRlIGNhbGxiYWNrIHdoZW4gY29kZSBpcyBjb21wbGV0ZScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3Qgc3VjY2Vzc0NhbGxiYWNrID0gamVzdC5mbigpO1xuXG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXtzdWNjZXNzQ2FsbGJhY2t9IC8+KTtcbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMF0sICcxMjM0NTYnKTtcblxuICAgICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgICBleHBlY3Qoc3VjY2Vzc0NhbGxiYWNrKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnMTIzNDU2Jyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdhbGxvd3MgbXVsdGlwbGUgY2FsbGJhY2sgaW52b2NhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gamVzdC5mbigpO1xuXG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs0fSBvbkNvbXBsZXRlPXtjYWxsYmFja30gLz4pO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgICAgLy8gRmlyc3QgY29kZVxuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnMTIzNCcpO1xuXG4gICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChjYWxsYmFjaykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDbGVhciBhbmQgZW50ZXIgbmV3IGNvZGVcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICBhd2FpdCB1c2VyLmNsZWFyKGlucHV0c1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnNTY3OCcpO1xuXG4gICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChjYWxsYmFjaykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgncGFzc2VzIGNvcnJlY3QgY29kZSB0byBjYWxsYmFjaycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbGV0IHJlY2VpdmVkQ29kZSA9ICcnO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IGplc3QuZm4oKGNvZGU6IHN0cmluZykgPT4ge1xuICAgICAgICAgIHJlY2VpdmVkQ29kZSA9IGNvZGU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXtjYWxsYmFja30gLz4pO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzk4NzY1NCcpO1xuXG4gICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChyZWNlaXZlZENvZGUpLnRvQmUoJzk4NzY1NCcpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ01lbW9yeSBhbmQgUmVzb3VyY2UgTWFuYWdlbWVudCcsICgpID0+IHtcbiAgICAgIGl0KCdjbGVhbnMgdXAgZXZlbnQgbGlzdGVuZXJzIG9uIHVubW91bnQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdW5tb3VudCB9ID0gcmVuZGVyKFxuICAgICAgICAgIDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPlxuICAgICAgICApO1xuXG4gICAgICAgIC8vIENvbXBvbmVudCBzaG91bGQgdW5tb3VudCB3aXRob3V0IGVycm9yc1xuICAgICAgICBleHBlY3QoKCkgPT4gdW5tb3VudCgpKS5ub3QudG9UaHJvdygpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdoYW5kbGVzIHJhcGlkIGNvbXBvbmVudCBtb3VudC91bm1vdW50IGN5Y2xlcycsICgpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgeyB1bm1vdW50IH0gPSByZW5kZXIoXG4gICAgICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz5cbiAgICAgICAgICApO1xuICAgICAgICAgIHVubW91bnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNob3VsZCBub3QgbGVhayBtZW1vcnkgb3IgdGhyb3cgZXJyb3JzXG4gICAgICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdoYW5kbGVzIGV4dHJlbWVseSBsb25nIE9UUCBjb2RlcyBlZmZpY2llbnRseScsICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcbiAgICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXsyMH0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+XG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuICAgICAgICBleHBlY3QoaW5wdXRzKS50b0hhdmVMZW5ndGgoMjApO1xuXG4gICAgICAgIC8vIFNob3VsZCByZW5kZXIgd2l0aG91dCBwZXJmb3JtYW5jZSBpc3N1ZXNcbiAgICAgICAgZXhwZWN0KGNvbnRhaW5lcikudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ1JhY2UgQ29uZGl0aW9ucyBhbmQgVGltaW5nIElzc3VlcycsICgpID0+IHtcbiAgICAgIGl0KCdoYW5kbGVzIHNpbXVsdGFuZW91cyBpbnB1dCBjaGFuZ2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICAgIC8vIFNpbXVsYXRlIHJhcGlkLCBzaW11bHRhbmVvdXMgY2hhbmdlc1xuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnMScpO1xuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzFdLCAnMicpO1xuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzJdLCAnMycpO1xuXG4gICAgICAgIC8vIFNob3VsZCBoYW5kbGUgZ3JhY2VmdWxseSAtIGNoZWNrIHRoYXQgYXQgbGVhc3Qgb25lIGlucHV0IGhhcyBhIHZhbHVlXG4gICAgICAgIGNvbnN0IGhhc1ZhbHVlcyA9IGlucHV0cy5zb21lKFxuICAgICAgICAgIChpbnB1dCkgPT4gaW5wdXQuZ2V0QXR0cmlidXRlKCd2YWx1ZScpICE9PSAnJ1xuICAgICAgICApO1xuICAgICAgICBleHBlY3QoaGFzVmFsdWVzKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdoYW5kbGVzIG9uQ2hhbmdlIGR1cmluZyBsb2FkaW5nIHN0YXRlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlcmVuZGVyIH0gPSByZW5kZXIoXG4gICAgICAgICAgPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IGxvYWRpbmc9e2ZhbHNlfSAvPlxuICAgICAgICApO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzEnKTtcblxuICAgICAgICAvLyBTd2l0Y2ggdG8gbG9hZGluZyBtaWQtaW5wdXRcbiAgICAgICAgcmVyZW5kZXIoXG4gICAgICAgICAgPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IGxvYWRpbmc9e3RydWV9IC8+XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gSW5wdXRzIHNob3VsZCBiZSBkaXNhYmxlZFxuICAgICAgICBjb25zdCB1cGRhdGVkSW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuICAgICAgICB1cGRhdGVkSW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICAgICAgZXhwZWN0KGlucHV0KS50b0JlRGlzYWJsZWQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ2hhbmRsZXMgb25Db21wbGV0ZSBiZWluZyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgZm9yIHNhbWUgY29kZScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBqZXN0LmZuKCk7XG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs0fSBvbkNvbXBsZXRlPXtjYWxsYmFja30gLz4pO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzEyMzQnKTtcblxuICAgICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgICBleHBlY3QoY2FsbGJhY2spLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVHlwaW5nIHNhbWUgY29kZSBhZ2FpblxuICAgICAgICBhd2FpdCB1c2VyLmNsZWFyKGlucHV0c1swXSk7XG4gICAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMF0sICcxMjM0Jyk7XG5cbiAgICAgICAgLy8gU2hvdWxkIGJlIGNhbGxlZCBhZ2FpblxuICAgICAgICBleHBlY3QoY2FsbGJhY2spLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygyKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnaGFuZGxlcyByYXBpZCBlcnJvciBzdGF0ZSBjaGFuZ2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlcmVuZGVyIH0gPSByZW5kZXIoXG4gICAgICAgICAgPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IGVycm9yPVwiXCIgLz5cbiAgICAgICAgKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgICByZXJlbmRlcihcbiAgICAgICAgICAgIDxPVFBJbnB1dFxuICAgICAgICAgICAgICBsZW5ndGg9ezZ9XG4gICAgICAgICAgICAgIG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfVxuICAgICAgICAgICAgICBlcnJvcj17YEVycm9yICR7aX1gfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApO1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwKSk7XG4gICAgICAgICAgcmVyZW5kZXIoXG4gICAgICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gZXJyb3I9XCJcIiAvPlxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaG91bGQgaGFuZGxlIHJhcGlkIGNoYW5nZXMgd2l0aG91dCBjcmFzaGluZ1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpKS50b0hhdmVMZW5ndGgoNik7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdJbnB1dCBWYWxpZGF0aW9uIEVkZ2UgQ2FzZXMnLCAoKSA9PiB7XG4gICAgICBpdCgnaGFuZGxlcyBzcGVjaWFsIFVuaWNvZGUgZGlnaXRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICAgIC8vIFRyeSB0byBpbnB1dCBVbmljb2RlIG1hdGhlbWF0aWNhbCBkaWdpdHNcbiAgICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJ/Cdn4/wnZ+Q8J2fkScpO1xuXG4gICAgICAgIC8vIFNob3VsZCByZWplY3Qgbm9uLUFTQ0lJIGRpZ2l0c1xuICAgICAgICBleHBlY3QoaW5wdXRzWzBdKS50b0hhdmVWYWx1ZSgnJyk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ2hhbmRsZXMgbWl4ZWQgdmFsaWQgYW5kIGludmFsaWQgY2hhcmFjdGVycyBpbiBwYXN0ZScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG4gICAgICAgIGNvbnN0IGZpcnN0SW5wdXQgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94JylbMF07XG4gICAgICAgIGF3YWl0IGZvY3VzRWxlbWVudChmaXJzdElucHV0KTtcblxuICAgICAgICBjb25zdCBwYXN0ZUV2ZW50ID0gbmV3IENsaXBib2FyZEV2ZW50KCdwYXN0ZScsIHtcbiAgICAgICAgICBjbGlwYm9hcmREYXRhOiBuZXcgRGF0YVRyYW5zZmVyKCksXG4gICAgICAgIH0pO1xuICAgICAgICBwYXN0ZUV2ZW50LmNsaXBib2FyZERhdGE/LnNldERhdGEoJ3RleHQvcGxhaW4nLCAnMTJhYmMzNCcpO1xuXG4gICAgICAgIGZpcmVFdmVudC5wYXN0ZShmaXJzdElucHV0LCBwYXN0ZUV2ZW50KTtcblxuICAgICAgICAvLyBTaG91bGQgcmVqZWN0IGVudGlyZSBwYXN0ZSBkdWUgdG8gaW52YWxpZCBjaGFyYWN0ZXJzXG4gICAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcbiAgICAgICAgaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICAgICAgZXhwZWN0KGlucHV0KS50b0hhdmVWYWx1ZSgnJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdoYW5kbGVzIHdoaXRlc3BhY2UgaW4gcGFzdGVkIGNvbnRlbnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuICAgICAgICBjb25zdCBmaXJzdElucHV0ID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpWzBdO1xuICAgICAgICBhd2FpdCBmb2N1c0VsZW1lbnQoZmlyc3RJbnB1dCk7XG5cbiAgICAgICAgY29uc3QgcGFzdGVFdmVudCA9IG5ldyBDbGlwYm9hcmRFdmVudCgncGFzdGUnLCB7XG4gICAgICAgICAgY2xpcGJvYXJkRGF0YTogbmV3IERhdGFUcmFuc2ZlcigpLFxuICAgICAgICB9KTtcbiAgICAgICAgcGFzdGVFdmVudC5jbGlwYm9hcmREYXRhPy5zZXREYXRhKCd0ZXh0L3BsYWluJywgJyAgMTIzNDU2ICAnKTtcblxuICAgICAgICBmaXJlRXZlbnQucGFzdGUoZmlyc3RJbnB1dCwgcGFzdGVFdmVudCk7XG5cbiAgICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgICAgZXhwZWN0KG1vY2tPbkNvbXBsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnMTIzNDU2Jyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdoYW5kbGVzIG5ld2xpbmVzIGluIHBhc3RlZCBjb250ZW50JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcbiAgICAgICAgY29uc3QgZmlyc3RJbnB1dCA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKVswXTtcbiAgICAgICAgYXdhaXQgZm9jdXNFbGVtZW50KGZpcnN0SW5wdXQpO1xuXG4gICAgICAgIGNvbnN0IHBhc3RlRXZlbnQgPSBuZXcgQ2xpcGJvYXJkRXZlbnQoJ3Bhc3RlJywge1xuICAgICAgICAgIGNsaXBib2FyZERhdGE6IG5ldyBEYXRhVHJhbnNmZXIoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHBhc3RlRXZlbnQuY2xpcGJvYXJkRGF0YT8uc2V0RGF0YSgndGV4dC9wbGFpbicsICcxMjNcXG40NTYnKTtcblxuICAgICAgICBmaXJlRXZlbnQucGFzdGUoZmlyc3RJbnB1dCwgcGFzdGVFdmVudCk7XG5cbiAgICAgICAgLy8gU2hvdWxkIHJlamVjdCBkdWUgdG8gbmV3bGluZVxuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG4gICAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChpbnB1dCkudG9IYXZlVmFsdWUoJycpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnaGFuZGxlcyB6ZXJvLXdpZHRoIGNoYXJhY3RlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgICAgLy8gVHJ5IHRvIGlucHV0IHplcm8td2lkdGggc3BhY2VcbiAgICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzFcXHUyMDBCMicpO1xuXG4gICAgICAgIC8vIFNob3VsZCBvbmx5IGFjY2VwdCB0aGUgZGlnaXRzXG4gICAgICAgIGV4cGVjdChpbnB1dHNbMF0pLnRvSGF2ZVZhbHVlKCcxJyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdCcm93c2VyIENvbXBhdGliaWxpdHkgRWRnZSBDYXNlcycsICgpID0+IHtcbiAgICAgIGl0KCdoYW5kbGVzIG1pc3NpbmcgY2xpcGJvYXJkRGF0YSBncmFjZWZ1bGx5JywgKCkgPT4ge1xuICAgICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcbiAgICAgICAgY29uc3QgZmlyc3RJbnB1dCA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKVswXTtcblxuICAgICAgICAvLyBTaW11bGF0ZSBvbGQgYnJvd3NlciB3aXRob3V0IGNsaXBib2FyZERhdGFcbiAgICAgICAgY29uc3QgcGFzdGVFdmVudCA9IG5ldyBFdmVudCgncGFzdGUnKSBhcyBhbnk7XG4gICAgICAgIGZpcmVFdmVudChmaXJzdElucHV0LCBwYXN0ZUV2ZW50KTtcblxuICAgICAgICAvLyBTaG91bGQgbm90IGNyYXNoXG4gICAgICAgIGV4cGVjdChmaXJzdElucHV0KS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdoYW5kbGVzIGlucHV0cyB3aXRob3V0IHNlbGVjdCBtZXRob2QnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgICAgLy8gQ29tcG9uZW50IHNob3VsZCBoYW5kbGUgbWlzc2luZyBzZWxlY3QgbWV0aG9kIGdyYWNlZnVsbHlcbiAgICAgICAgLy8gVGhpcyB0ZXN0cyBkZWZlbnNpdmUgcHJvZ3JhbW1pbmcgZm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGV4cGVjdChpbnB1dHNbMF0pLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICAgIGV4cGVjdCh0eXBlb2YgKGlucHV0c1swXSBhcyBIVE1MSW5wdXRFbGVtZW50KS5zZWxlY3QpLnRvQmUoJ2Z1bmN0aW9uJyk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ2hhbmRsZXMgZm9jdXMgb24gbnVsbCByZWZzIGdyYWNlZnVsbHknLCAoKSA9PiB7XG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuXG4gICAgICAgIC8vIENvbXBvbmVudCBzaG91bGQgaGFuZGxlIG51bGwgcmVmcyBpbnRlcm5hbGx5XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94JykpLnRvSGF2ZUxlbmd0aCg2KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ0hpZ2ggTG9hZCBTY2VuYXJpb3MnLCAoKSA9PiB7XG4gICAgICBpdCgnaGFuZGxlcyAxMDAwKyByYXBpZCBrZXlzdHJva2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICAgIC8vIFNpbXVsYXRlIHVzZXIgbWFzaGluZyBrZXlzIHJhcGlkbHlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDAwOyBpKyspIHtcbiAgICAgICAgICBjb25zdCByYW5kb21JbnB1dCA9IGlucHV0c1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBpbnB1dHMubGVuZ3RoKV07XG4gICAgICAgICAgY29uc3QgcmFuZG9tS2V5ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTApLnRvU3RyaW5nKCk7XG4gICAgICAgICAgZmlyZUV2ZW50LmNoYW5nZShyYW5kb21JbnB1dCwgeyB0YXJnZXQ6IHsgdmFsdWU6IHJhbmRvbUtleSB9IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hvdWxkIHN0aWxsIGJlIGZ1bmN0aW9uYWxcbiAgICAgICAgZXhwZWN0KGlucHV0c1swXSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnaGFuZGxlcyBjb250aW51b3VzIHBhc3RlIG9wZXJhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuICAgICAgICBjb25zdCBmaXJzdElucHV0ID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpWzBdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBwYXN0ZUV2ZW50ID0gbmV3IENsaXBib2FyZEV2ZW50KCdwYXN0ZScsIHtcbiAgICAgICAgICAgIGNsaXBib2FyZERhdGE6IG5ldyBEYXRhVHJhbnNmZXIoKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwYXN0ZUV2ZW50LmNsaXBib2FyZERhdGE/LnNldERhdGEoXG4gICAgICAgICAgICAndGV4dC9wbGFpbicsXG4gICAgICAgICAgICBgJHsxMDAwMDAgKyBpfWAuc2xpY2UoMCwgNilcbiAgICAgICAgICApO1xuICAgICAgICAgIGZpcmVFdmVudC5wYXN0ZShmaXJzdElucHV0LCBwYXN0ZUV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNob3VsZCBoYW5kbGUgd2l0aG91dCBtZW1vcnkgbGVha3NcbiAgICAgICAgZXhwZWN0KGZpcnN0SW5wdXQpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ2hhbmRsZXMgYWx0ZXJuYXRpbmcgZm9jdXMgYmV0d2VlbiBhbGwgaW5wdXRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICAgIC8vIFJhcGlkbHkgc3dpdGNoIGZvY3VzXG4gICAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xuICAgICAgICAgICAgaW5wdXRzW2kgJSA2XS5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU2hvdWxkIGhhbmRsZSBncmFjZWZ1bGx5XG4gICAgICAgIGV4cGVjdChpbnB1dHMuc29tZSgoaW5wdXQpID0+IGlucHV0ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkudG9CZShcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdBY2Nlc3NpYmlsaXR5IFVuZGVyIFN0cmVzcycsICgpID0+IHtcbiAgICAgIGl0KCdtYWludGFpbnMgQVJJQSBhdHRyaWJ1dGVzIGR1cmluZyByYXBpZCBzdGF0ZSBjaGFuZ2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlcmVuZGVyIH0gPSByZW5kZXIoXG4gICAgICAgICAgPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+XG4gICAgICAgICk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgICAgcmVyZW5kZXIoXG4gICAgICAgICAgICA8T1RQSW5wdXRcbiAgICAgICAgICAgICAgbGVuZ3RoPXs2fVxuICAgICAgICAgICAgICBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX1cbiAgICAgICAgICAgICAgZXJyb3I9e2BFcnJvciAke2l9YH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcbiAgICAgICAgICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQsIGlkeCkgPT4ge1xuICAgICAgICAgICAgZXhwZWN0KGlucHV0KS50b0hhdmVBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICdhcmlhLWxhYmVsJyxcbiAgICAgICAgICAgICAgYERpZ2l0ICR7aWR4ICsgMX0gb2YgNmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBleHBlY3QoaW5wdXQpLnRvSGF2ZUF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJywgJ3RydWUnKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJlcmVuZGVyKFxuICAgICAgICAgICAgPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IGVycm9yPVwiXCIgLz5cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaXQoJ21haW50YWlucyBsaXZlIHJlZ2lvbiB1cGRhdGVzIGR1cmluZyBoaWdoIGFjdGl2aXR5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcbiAgICAgICAgY29uc3QgbGl2ZVJlZ2lvbiA9IHNjcmVlbi5nZXRCeVJvbGUoJ3N0YXR1cycpO1xuXG4gICAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbaV0sIChpICsgMSkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgZXhwZWN0KGxpdmVSZWdpb24pLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ0NvbXBvbmVudCBMaWZlY3ljbGUgRWRnZSBDYXNlcycsICgpID0+IHtcbiAgICAgIGl0KCdoYW5kbGVzIGxlbmd0aCBwcm9wIGNoYW5naW5nIGR5bmFtaWNhbGx5JywgKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlcmVuZGVyIH0gPSByZW5kZXIoXG4gICAgICAgICAgPE9UUElucHV0IGxlbmd0aD17NH0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+XG4gICAgICAgICk7XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94JykpLnRvSGF2ZUxlbmd0aCg0KTtcblxuICAgICAgICAvLyBDaGFuZ2luZyBsZW5ndGggcHJvcCBjcmVhdGVzIGEgbmV3IGNvbXBvbmVudCBpbnN0YW5jZVxuICAgICAgICAvLyBUaGUgY29tcG9uZW50IGRvZXNuJ3QgZHluYW1pY2FsbHkgcmVzaXplLCBzbyB0aGlzIHRlc3QgZG9jdW1lbnRzIHRoZSBiZWhhdmlvclxuICAgICAgICByZXJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs4fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuICAgICAgICAvLyBDb21wb25lbnQgd2lsbCBzdGlsbCBoYXZlIDQgaW5wdXRzIGFzIGl0IGRvZXNuJ3QgcmUtaW5pdGlhbGl6ZVxuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdoYW5kbGVzIG9uQ29tcGxldGUgY2FsbGJhY2sgY2hhbmdpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrMSA9IGplc3QuZm4oKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2syID0gamVzdC5mbigpO1xuXG4gICAgICAgIGNvbnN0IHsgcmVyZW5kZXIgfSA9IHJlbmRlcihcbiAgICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs0fSBvbkNvbXBsZXRlPXtjYWxsYmFjazF9IC8+XG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcblxuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnMTIzNCcpO1xuXG4gICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChjYWxsYmFjazEpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2hhbmdlIGNhbGxiYWNrXG4gICAgICAgIHJlcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezR9IG9uQ29tcGxldGU9e2NhbGxiYWNrMn0gLz4pO1xuXG4gICAgICAgIGF3YWl0IHVzZXIuY2xlYXIoaW5wdXRzWzBdKTtcbiAgICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzU2NzgnKTtcblxuICAgICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgICBleHBlY3QoY2FsbGJhY2syKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdoYW5kbGVzIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycycsICgpID0+IHtcbiAgICAgICAgY29uc3QgUGFyZW50Q29tcG9uZW50ID0gKHsgY291bnQgfTogeyBjb3VudDogbnVtYmVyIH0pID0+IChcbiAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgPHNwYW4+e2NvdW50fTwvc3Bhbj5cbiAgICAgICAgICAgIDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHsgcmVyZW5kZXIgfSA9IHJlbmRlcig8UGFyZW50Q29tcG9uZW50IGNvdW50PXswfSAvPik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xuICAgICAgICAgIHJlcmVuZGVyKDxQYXJlbnRDb21wb25lbnQgY291bnQ9e2l9IC8+KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94JykpLnRvSGF2ZUxlbmd0aCg2KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ0Vycm9yIFJlY292ZXJ5JywgKCkgPT4ge1xuICAgICAgaXQoJ3JlY292ZXJzIGZyb20gZXJyb3Igc3RhdGUgd2hlbiB1c2VyIGNvcnJlY3RzIGlucHV0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlcmVuZGVyIH0gPSByZW5kZXIoXG4gICAgICAgICAgPE9UUElucHV0XG4gICAgICAgICAgICBsZW5ndGg9ezZ9XG4gICAgICAgICAgICBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX1cbiAgICAgICAgICAgIGVycm9yPVwiSW52YWxpZCBjb2RlXCJcbiAgICAgICAgICAvPlxuICAgICAgICApO1xuXG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdJbnZhbGlkIGNvZGUnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcblxuICAgICAgICByZXJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gZXJyb3I9XCJcIiAvPik7XG5cbiAgICAgICAgZXhwZWN0KHNjcmVlbi5xdWVyeUJ5VGV4dCgnSW52YWxpZCBjb2RlJykpLm5vdC50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdhbGxvd3MgcmUtZW50cnkgYWZ0ZXIgZXJyb3InLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVyZW5kZXIgfSA9IHJlbmRlcihcbiAgICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gZXJyb3I9XCJUcnkgYWdhaW5cIiAvPlxuICAgICAgICApO1xuXG4gICAgICAgIHJlcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSBlcnJvcj1cIlwiIC8+KTtcblxuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG4gICAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMF0sICcxMjM0NTYnKTtcblxuICAgICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgICBleHBlY3QobW9ja09uQ29tcGxldGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcxMjM0NTYnKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ2NsZWFycyBpbnB1dCB3aGVuIGVycm9yIGlzIHNob3duJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlcmVuZGVyIH0gPSByZW5kZXIoXG4gICAgICAgICAgPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+XG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcblxuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnMTIzJyk7XG5cbiAgICAgICAgLy8gU2hvdyBlcnJvciAtIHNpbXVsYXRpbmcgZmFpbGVkIHZlcmlmaWNhdGlvblxuICAgICAgICByZXJlbmRlcihcbiAgICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gZXJyb3I9XCJJbnZhbGlkXCIgLz5cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBVc2VyIHNob3VsZCBiZSBhYmxlIHRvIGNsZWFyIGFuZCByZXRyeVxuICAgICAgICBhd2FpdCB1c2VyLmNsZWFyKGlucHV0c1swXSk7XG4gICAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMF0sICc0NTYnKTtcblxuICAgICAgICBleHBlY3QoaW5wdXRzWzBdKS50b0hhdmVWYWx1ZSgnNCcpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJ1c2VyIiwidXNlckV2ZW50Iiwic2V0dXAiLCJtb2NrT25Db21wbGV0ZSIsImplc3QiLCJmbiIsIm1vY2tPbkNoYW5nZSIsImZvY3VzRWxlbWVudCIsImVsZW1lbnQiLCJjbGljayIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwiaXQiLCJyZW5kZXIiLCJPVFBJbnB1dCIsImxlbmd0aCIsIm9uQ29tcGxldGUiLCJpbnB1dHMiLCJzY3JlZW4iLCJnZXRBbGxCeVJvbGUiLCJleHBlY3QiLCJ0b0hhdmVMZW5ndGgiLCJjb250YWluZXIiLCJjbG9zZXN0IiwidG9CZUluVGhlRG9jdW1lbnQiLCJsb2FkaW5nIiwiZm9yRWFjaCIsImlucHV0IiwidG9CZURpc2FibGVkIiwiZXJyb3IiLCJnZXRCeVRleHQiLCJmaXJzdElucHV0IiwidHlwZSIsInRvSGF2ZVZhbHVlIiwidG9IYXZlRm9jdXMiLCJrZXlib2FyZCIsImNsZWFyIiwiZmlyZUV2ZW50IiwiY2hhbmdlIiwidGFyZ2V0IiwidmFsdWUiLCJ3YWl0Rm9yIiwicGFzdGVFdmVudCIsIkNsaXBib2FyZEV2ZW50IiwiY2xpcGJvYXJkRGF0YSIsIkRhdGFUcmFuc2ZlciIsInNldERhdGEiLCJwYXN0ZSIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwibm90IiwidG9IYXZlQmVlbkNhbGxlZCIsInVubW91bnQiLCJpbmRleCIsInRvSGF2ZUF0dHJpYnV0ZSIsImxpdmVSZWdpb24iLCJnZXRCeVJvbGUiLCJlcnJvckVsZW1lbnQiLCJyZW5kZXJTcHkiLCJUZXN0Q29tcG9uZW50IiwicmVyZW5kZXIiLCJ0b0hhdmVCZWVuQ2FsbGVkVGltZXMiLCJzdWNjZXNzQ2FsbGJhY2siLCJjYWxsYmFjayIsImkiLCJyZWNlaXZlZENvZGUiLCJjb2RlIiwidG9CZSIsInRvVGhyb3ciLCJoYXNWYWx1ZXMiLCJzb21lIiwiZ2V0QXR0cmlidXRlIiwidXBkYXRlZElucHV0cyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsIkV2ZW50Iiwic2VsZWN0IiwicmFuZG9tSW5wdXQiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJyYW5kb21LZXkiLCJ0b1N0cmluZyIsInNsaWNlIiwiYWN0IiwiZm9jdXMiLCJkb2N1bWVudCIsImFjdGl2ZUVsZW1lbnQiLCJpZHgiLCJ0b0JlR3JlYXRlclRoYW4iLCJjYWxsYmFjazEiLCJjYWxsYmFjazIiLCJQYXJlbnRDb21wb25lbnQiLCJjb3VudCIsImRpdiIsInNwYW4iLCJxdWVyeUJ5VGV4dCJdLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdDOzs7Ozs4REFFaUI7d0JBT1g7a0VBQ2U7aUVBQ0Q7Ozs7OztBQUVyQkEsU0FBUyxZQUFZO0lBQ25CLE1BQU1DLE9BQU9DLGtCQUFTLENBQUNDLEtBQUs7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