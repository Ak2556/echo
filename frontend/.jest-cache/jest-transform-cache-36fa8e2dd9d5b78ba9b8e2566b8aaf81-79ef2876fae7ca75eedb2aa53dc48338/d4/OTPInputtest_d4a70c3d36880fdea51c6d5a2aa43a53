37535ae9478f024e91a286cfc5a6af42
/**
 * OTPInput Component Tests
 * Comprehensive test suite for OTP input functionality
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _userevent = /*#__PURE__*/ _interop_require_default(require("@testing-library/user-event"));
const _OTPInput = /*#__PURE__*/ _interop_require_default(require("../OTPInput"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
describe("OTPInput", ()=>{
    const user = _userevent.default.setup();
    const mockOnComplete = jest.fn();
    const mockOnChange = jest.fn();
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    describe("Component Rendering", ()=>{
        it("renders correct number of input fields", ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            expect(inputs).toHaveLength(6);
        });
        it("renders with custom length", ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 4,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            expect(inputs).toHaveLength(4);
        });
        it("renders with proper structure", ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const container = _react1.screen.getAllByRole("textbox")[0].closest(".otp-input-container");
            expect(container).toBeInTheDocument();
        });
        it("shows loading state", ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete,
                loading: true
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            inputs.forEach((input)=>{
                expect(input).toBeDisabled();
            });
        });
        it("shows error state", ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete,
                error: "Invalid OTP"
            }));
            expect(_react1.screen.getByText("Invalid OTP")).toBeInTheDocument();
        });
    });
    describe("Input Behavior", ()=>{
        it("accepts only numeric input", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const firstInput = _react1.screen.getAllByRole("textbox")[0];
            await user.type(firstInput, "a");
            expect(firstInput).toHaveValue("");
            await user.type(firstInput, "1");
            expect(firstInput).toHaveValue("1");
        });
        it("moves to next input after entering digit", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            await user.type(inputs[0], "1");
            expect(inputs[1]).toHaveFocus();
        });
        it("moves to previous input on backspace", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            // Type in first input and move to second
            await user.type(inputs[0], "1");
            expect(inputs[1]).toHaveFocus();
            // Backspace should move back to first input
            await user.keyboard("{Backspace}");
            expect(inputs[0]).toHaveFocus();
        });
        it("replaces existing digit when typing", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const firstInput = _react1.screen.getAllByRole("textbox")[0];
            await user.type(firstInput, "1");
            expect(firstInput).toHaveValue("1");
            // Clear and type new digit
            await user.clear(firstInput);
            await user.type(firstInput, "2");
            expect(firstInput).toHaveValue("2");
        });
        it("handles arrow key navigation", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            inputs[0].focus();
            await user.keyboard("{ArrowRight}");
            expect(inputs[1]).toHaveFocus();
            await user.keyboard("{ArrowLeft}");
            expect(inputs[0]).toHaveFocus();
        });
        it("handles Home key to jump to first input", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            inputs[3].focus();
            expect(inputs[3]).toHaveFocus();
            await user.keyboard("{Home}");
            expect(inputs[0]).toHaveFocus();
        });
        it("handles End key to jump to last input", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            inputs[2].focus();
            expect(inputs[2]).toHaveFocus();
            await user.keyboard("{End}");
            expect(inputs[5]).toHaveFocus();
        });
        it("handles backspace on filled input to clear it", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            // Fill first input
            await user.type(inputs[0], "1");
            expect(inputs[0]).toHaveValue("1");
            // Go back to first input
            inputs[0].focus();
            // Backspace should clear current input
            await user.keyboard("{Backspace}");
            expect(inputs[0]).toHaveValue("");
        });
        it("handles multi-character input from rapid typing", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            // Start from middle input
            inputs[2].focus();
            // Simulate rapid multi-character input
            _react1.fireEvent.change(inputs[2], {
                target: {
                    value: "345"
                }
            });
            await (0, _react1.waitFor)(()=>{
                expect(inputs[2]).toHaveValue("3");
                expect(inputs[3]).toHaveValue("4");
                expect(inputs[4]).toHaveValue("5");
            });
        });
    });
    describe("Paste Functionality", ()=>{
        it("handles paste of complete OTP", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const firstInput = _react1.screen.getAllByRole("textbox")[0];
            firstInput.focus();
            // Simulate paste event
            const pasteEvent = new ClipboardEvent("paste", {
                clipboardData: new DataTransfer()
            });
            pasteEvent.clipboardData?.setData("text/plain", "123456");
            _react1.fireEvent.paste(firstInput, pasteEvent);
            await (0, _react1.waitFor)(()=>{
                expect(mockOnComplete).toHaveBeenCalledWith("123456");
            });
        });
        it("handles paste of partial OTP", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const firstInput = _react1.screen.getAllByRole("textbox")[0];
            firstInput.focus();
            const pasteEvent = new ClipboardEvent("paste", {
                clipboardData: new DataTransfer()
            });
            pasteEvent.clipboardData?.setData("text/plain", "123");
            _react1.fireEvent.paste(firstInput, pasteEvent);
            await (0, _react1.waitFor)(()=>{
                const inputs = _react1.screen.getAllByRole("textbox");
                expect(inputs[0]).toHaveValue("1");
                expect(inputs[1]).toHaveValue("2");
                expect(inputs[2]).toHaveValue("3");
                expect(inputs[2]).toHaveFocus();
            });
        });
        it("ignores non-numeric paste content", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const firstInput = _react1.screen.getAllByRole("textbox")[0];
            firstInput.focus();
            const pasteEvent = new ClipboardEvent("paste", {
                clipboardData: new DataTransfer()
            });
            pasteEvent.clipboardData?.setData("text/plain", "abc123");
            _react1.fireEvent.paste(firstInput, pasteEvent);
            // Should not fill any inputs with invalid characters
            const inputs = _react1.screen.getAllByRole("textbox");
            inputs.forEach((input)=>{
                expect(input).toHaveValue("");
            });
        });
        it("handles paste longer than input length", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 4,
                onComplete: mockOnComplete
            }));
            const firstInput = _react1.screen.getAllByRole("textbox")[0];
            firstInput.focus();
            const pasteEvent = new ClipboardEvent("paste", {
                clipboardData: new DataTransfer()
            });
            pasteEvent.clipboardData?.setData("text/plain", "123456789");
            _react1.fireEvent.paste(firstInput, pasteEvent);
            await (0, _react1.waitFor)(()=>{
                expect(mockOnComplete).toHaveBeenCalledWith("1234");
            });
        });
    });
    describe("Completion Handling", ()=>{
        it("calls onComplete when all fields are filled", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 4,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            await user.type(inputs[0], "1");
            await user.type(inputs[1], "2");
            await user.type(inputs[2], "3");
            await user.type(inputs[3], "4");
            expect(mockOnComplete).toHaveBeenCalledWith("1234");
        });
        it("updates internal state on input change", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 4,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            await user.type(inputs[0], "1");
            expect(inputs[0]).toHaveValue("1");
            await user.type(inputs[1], "2");
            expect(inputs[1]).toHaveValue("2");
        });
        it("does not call onComplete for incomplete OTP", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            await user.type(inputs[0], "1");
            await user.type(inputs[1], "2");
            await user.type(inputs[2], "3");
            expect(mockOnComplete).not.toHaveBeenCalled();
        });
    });
    describe("Component State Management", ()=>{
        it("maintains internal state correctly", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            await user.type(inputs[0], "1");
            await user.type(inputs[1], "2");
            await user.type(inputs[2], "3");
            expect(inputs[0]).toHaveValue("1");
            expect(inputs[1]).toHaveValue("2");
            expect(inputs[2]).toHaveValue("3");
        });
        it("resets state when component remounts", ()=>{
            const { unmount } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            unmount();
            // Render a new instance
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            inputs.forEach((input)=>{
                expect(input).toHaveValue("");
            });
        });
    });
    describe("Accessibility", ()=>{
        it("has proper ARIA attributes", ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            inputs.forEach((input, index)=>{
                expect(input).toHaveAttribute("aria-label", `Digit ${index + 1} of 6`);
                expect(input).toHaveAttribute("inputMode", "numeric");
            });
        });
        it("supports screen readers with live region", ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const liveRegion = _react1.screen.getByRole("status");
            expect(liveRegion).toHaveAttribute("aria-live", "polite");
            expect(liveRegion).toHaveAttribute("aria-atomic", "true");
        });
        it("announces errors to screen readers", ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete,
                error: "Invalid OTP"
            }));
            const errorElement = _react1.screen.getByText("Invalid OTP");
            expect(errorElement).toHaveAttribute("role", "alert");
        });
    });
    describe("Security", ()=>{
        it("does not expose OTP in DOM attributes", ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            inputs.forEach((input)=>{
                expect(input).not.toHaveAttribute("data-value");
                expect(input).not.toHaveAttribute("title");
            });
        });
        it("uses proper input mode for numeric input", ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            inputs.forEach((input)=>{
                expect(input).toHaveAttribute("inputMode", "numeric");
                expect(input).toHaveAttribute("maxLength", "1");
            });
        });
    });
    describe("Edge Cases", ()=>{
        it("handles rapid typing", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            // Type rapidly in sequence
            await user.type(inputs[0], "123456");
            await (0, _react1.waitFor)(()=>{
                expect(mockOnComplete).toHaveBeenCalledWith("123456");
            });
        });
        it("handles focus events correctly", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            // Focus on middle input
            inputs[2].focus();
            expect(inputs[2]).toHaveFocus();
            // Type should work from any focused input
            await user.type(inputs[2], "5");
            expect(inputs[2]).toHaveValue("5");
        });
        it("handles loading state correctly", ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete,
                loading: true
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            inputs.forEach((input)=>{
                expect(input).toBeDisabled();
            });
            expect(_react1.screen.getByText("Verifying...")).toBeInTheDocument();
        });
        it("handles error state correctly", ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete,
                error: "Invalid code"
            }));
            expect(_react1.screen.getByText("Invalid code")).toBeInTheDocument();
            expect(_react1.screen.getByRole("alert")).toBeInTheDocument();
        });
    });
    describe("Performance", ()=>{
        it("does not cause unnecessary re-renders", ()=>{
            const renderSpy = jest.fn();
            const TestComponent = ()=>{
                renderSpy();
                return /*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                });
            };
            const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            expect(renderSpy).toHaveBeenCalledTimes(1);
            // Re-render with same props
            rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            // Should not cause additional renders due to memoization
            expect(renderSpy).toHaveBeenCalledTimes(2);
        });
    });
    describe("Production Error Scenarios", ()=>{
        describe("Network and API Failures", ()=>{
            it("calls onComplete callback when code is complete", async ()=>{
                const successCallback = jest.fn();
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: successCallback
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                await user.type(inputs[0], "123456");
                await (0, _react1.waitFor)(()=>{
                    expect(successCallback).toHaveBeenCalledWith("123456");
                });
            });
            it("allows multiple callback invocations", async ()=>{
                const callback = jest.fn();
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 4,
                    onComplete: callback
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                // First code
                await user.type(inputs[0], "1234");
                await (0, _react1.waitFor)(()=>{
                    expect(callback).toHaveBeenCalledTimes(1);
                });
                // Clear and enter new code
                for(let i = 0; i < 4; i++){
                    await user.clear(inputs[i]);
                }
                await user.type(inputs[0], "5678");
                await (0, _react1.waitFor)(()=>{
                    expect(callback).toHaveBeenCalledTimes(2);
                });
            });
            it("passes correct code to callback", async ()=>{
                let receivedCode = "";
                const callback = jest.fn((code)=>{
                    receivedCode = code;
                });
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: callback
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                await user.type(inputs[0], "987654");
                await (0, _react1.waitFor)(()=>{
                    expect(receivedCode).toBe("987654");
                });
            });
        });
        describe("Memory and Resource Management", ()=>{
            it("cleans up event listeners on unmount", ()=>{
                const { unmount } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                // Component should unmount without errors
                expect(()=>unmount()).not.toThrow();
            });
            it("handles rapid component mount/unmount cycles", ()=>{
                for(let i = 0; i < 10; i++){
                    const { unmount } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                        length: 6,
                        onComplete: mockOnComplete
                    }));
                    unmount();
                }
                // Should not leak memory or throw errors
                expect(true).toBe(true);
            });
            it("handles extremely long OTP codes efficiently", ()=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 20,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                expect(inputs).toHaveLength(20);
                // Should render without performance issues
                expect(container).toBeInTheDocument();
            });
        });
        describe("Race Conditions and Timing Issues", ()=>{
            it("handles simultaneous input changes", async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                // Simulate rapid, simultaneous changes
                await user.type(inputs[0], "1");
                await user.type(inputs[1], "2");
                await user.type(inputs[2], "3");
                // Should handle gracefully - check that at least one input has a value
                const hasValues = inputs.some((input)=>input.getAttribute("value") !== "");
                expect(hasValues).toBe(true);
            });
            it("handles onChange during loading state", async ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    loading: false
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                await user.type(inputs[0], "1");
                // Switch to loading mid-input
                rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    loading: true
                }));
                // Inputs should be disabled
                const updatedInputs = _react1.screen.getAllByRole("textbox");
                updatedInputs.forEach((input)=>{
                    expect(input).toBeDisabled();
                });
            });
            it("handles onComplete being called multiple times for same code", async ()=>{
                const callback = jest.fn();
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 4,
                    onComplete: callback
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                await user.type(inputs[0], "1234");
                await (0, _react1.waitFor)(()=>{
                    expect(callback).toHaveBeenCalledTimes(1);
                });
                // Typing same code again
                await user.clear(inputs[0]);
                await user.type(inputs[0], "1234");
                // Should be called again
                expect(callback).toHaveBeenCalledTimes(2);
            });
            it("handles rapid error state changes", async ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    error: ""
                }));
                for(let i = 0; i < 10; i++){
                    rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                        length: 6,
                        onComplete: mockOnComplete,
                        error: `Error ${i}`
                    }));
                    await new Promise((resolve)=>setTimeout(resolve, 10));
                    rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                        length: 6,
                        onComplete: mockOnComplete,
                        error: ""
                    }));
                }
                // Should handle rapid changes without crashing
                expect(_react1.screen.getAllByRole("textbox")).toHaveLength(6);
            });
        });
        describe("Input Validation Edge Cases", ()=>{
            it("handles special Unicode digits", async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                // Try to input Unicode mathematical digits
                await user.type(inputs[0], "\uD835\uDFCF\uD835\uDFD0\uD835\uDFD1");
                // Should reject non-ASCII digits
                expect(inputs[0]).toHaveValue("");
            });
            it("handles mixed valid and invalid characters in paste", async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const firstInput = _react1.screen.getAllByRole("textbox")[0];
                firstInput.focus();
                const pasteEvent = new ClipboardEvent("paste", {
                    clipboardData: new DataTransfer()
                });
                pasteEvent.clipboardData?.setData("text/plain", "12abc34");
                _react1.fireEvent.paste(firstInput, pasteEvent);
                // Should reject entire paste due to invalid characters
                const inputs = _react1.screen.getAllByRole("textbox");
                inputs.forEach((input)=>{
                    expect(input).toHaveValue("");
                });
            });
            it("handles whitespace in pasted content", async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const firstInput = _react1.screen.getAllByRole("textbox")[0];
                firstInput.focus();
                const pasteEvent = new ClipboardEvent("paste", {
                    clipboardData: new DataTransfer()
                });
                pasteEvent.clipboardData?.setData("text/plain", "  123456  ");
                _react1.fireEvent.paste(firstInput, pasteEvent);
                await (0, _react1.waitFor)(()=>{
                    expect(mockOnComplete).toHaveBeenCalledWith("123456");
                });
            });
            it("handles newlines in pasted content", async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const firstInput = _react1.screen.getAllByRole("textbox")[0];
                firstInput.focus();
                const pasteEvent = new ClipboardEvent("paste", {
                    clipboardData: new DataTransfer()
                });
                pasteEvent.clipboardData?.setData("text/plain", "123\n456");
                _react1.fireEvent.paste(firstInput, pasteEvent);
                // Should reject due to newline
                const inputs = _react1.screen.getAllByRole("textbox");
                inputs.forEach((input)=>{
                    expect(input).toHaveValue("");
                });
            });
            it("handles zero-width characters", async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                // Try to input zero-width space
                await user.type(inputs[0], "1â€‹2");
                // Should only accept the digits
                expect(inputs[0]).toHaveValue("1");
            });
        });
        describe("Browser Compatibility Edge Cases", ()=>{
            it("handles missing clipboardData gracefully", ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const firstInput = _react1.screen.getAllByRole("textbox")[0];
                // Simulate old browser without clipboardData
                const pasteEvent = new Event("paste");
                (0, _react1.fireEvent)(firstInput, pasteEvent);
                // Should not crash
                expect(firstInput).toBeInTheDocument();
            });
            it("handles inputs without select method", async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                // Component should handle missing select method gracefully
                // This tests defensive programming for older browsers
                expect(inputs[0]).toBeInTheDocument();
                expect(typeof inputs[0].select).toBe("function");
            });
            it("handles focus on null refs gracefully", ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                // Component should handle null refs internally
                expect(_react1.screen.getAllByRole("textbox")).toHaveLength(6);
            });
        });
        describe("High Load Scenarios", ()=>{
            it("handles 1000+ rapid keystrokes", async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                // Simulate user mashing keys rapidly
                for(let i = 0; i < 1000; i++){
                    const randomInput = inputs[Math.floor(Math.random() * inputs.length)];
                    const randomKey = Math.floor(Math.random() * 10).toString();
                    _react1.fireEvent.change(randomInput, {
                        target: {
                            value: randomKey
                        }
                    });
                }
                // Should still be functional
                expect(inputs[0]).toBeInTheDocument();
            });
            it("handles continuous paste operations", async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const firstInput = _react1.screen.getAllByRole("textbox")[0];
                for(let i = 0; i < 100; i++){
                    const pasteEvent = new ClipboardEvent("paste", {
                        clipboardData: new DataTransfer()
                    });
                    pasteEvent.clipboardData?.setData("text/plain", `${100000 + i}`.slice(0, 6));
                    _react1.fireEvent.paste(firstInput, pasteEvent);
                }
                // Should handle without memory leaks
                expect(firstInput).toBeInTheDocument();
            });
            it("handles alternating focus between all inputs", async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                // Rapidly switch focus
                for(let i = 0; i < 100; i++){
                    inputs[i % 6].focus();
                }
                // Should handle gracefully
                expect(inputs.some((input)=>input === document.activeElement)).toBe(true);
            });
        });
        describe("Accessibility Under Stress", ()=>{
            it("maintains ARIA attributes during rapid state changes", async ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                for(let i = 0; i < 10; i++){
                    rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                        length: 6,
                        onComplete: mockOnComplete,
                        error: `Error ${i}`
                    }));
                    const inputs = _react1.screen.getAllByRole("textbox");
                    inputs.forEach((input, idx)=>{
                        expect(input).toHaveAttribute("aria-label", `Digit ${idx + 1} of 6`);
                        expect(input).toHaveAttribute("aria-invalid", "true");
                    });
                    rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                        length: 6,
                        onComplete: mockOnComplete,
                        error: ""
                    }));
                }
            });
            it("maintains live region updates during high activity", async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const liveRegion = _react1.screen.getByRole("status");
                const inputs = _react1.screen.getAllByRole("textbox");
                for(let i = 0; i < 6; i++){
                    await user.type(inputs[i], (i + 1).toString());
                    expect(liveRegion).toBeInTheDocument();
                }
            });
        });
        describe("Component Lifecycle Edge Cases", ()=>{
            it("handles length prop changing dynamically", ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 4,
                    onComplete: mockOnComplete
                }));
                expect(_react1.screen.getAllByRole("textbox")).toHaveLength(4);
                // Changing length prop creates a new component instance
                // The component doesn't dynamically resize, so this test documents the behavior
                rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 8,
                    onComplete: mockOnComplete
                }));
                // Component will still have 4 inputs as it doesn't re-initialize
                expect(_react1.screen.getAllByRole("textbox").length).toBeGreaterThan(0);
            });
            it("handles onComplete callback changing", async ()=>{
                const callback1 = jest.fn();
                const callback2 = jest.fn();
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 4,
                    onComplete: callback1
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                await user.type(inputs[0], "1234");
                await (0, _react1.waitFor)(()=>{
                    expect(callback1).toHaveBeenCalled();
                });
                // Change callback
                rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 4,
                    onComplete: callback2
                }));
                await user.clear(inputs[0]);
                await user.type(inputs[0], "5678");
                await (0, _react1.waitFor)(()=>{
                    expect(callback2).toHaveBeenCalled();
                });
            });
            it("handles parent component re-renders", ()=>{
                const ParentComponent = ({ count })=>/*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                        children: [
                            /*#__PURE__*/ (0, _jsxruntime.jsx)("span", {
                                children: count
                            }),
                            /*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                                length: 6,
                                onComplete: mockOnComplete
                            })
                        ]
                    });
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(ParentComponent, {
                    count: 0
                }));
                for(let i = 0; i < 100; i++){
                    rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(ParentComponent, {
                        count: i
                    }));
                }
                expect(_react1.screen.getAllByRole("textbox")).toHaveLength(6);
            });
        });
        describe("Error Recovery", ()=>{
            it("recovers from error state when user corrects input", async ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    error: "Invalid code"
                }));
                expect(_react1.screen.getByText("Invalid code")).toBeInTheDocument();
                rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    error: ""
                }));
                expect(_react1.screen.queryByText("Invalid code")).not.toBeInTheDocument();
            });
            it("allows re-entry after error", async ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    error: "Try again"
                }));
                rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    error: ""
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                await user.type(inputs[0], "123456");
                await (0, _react1.waitFor)(()=>{
                    expect(mockOnComplete).toHaveBeenCalledWith("123456");
                });
            });
            it("clears input when error is shown", async ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                await user.type(inputs[0], "123");
                // Show error - simulating failed verification
                rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    error: "Invalid"
                }));
                // User should be able to clear and retry
                await user.clear(inputs[0]);
                await user.type(inputs[0], "456");
                expect(inputs[0]).toHaveValue("4");
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hZW5hL0RldmVsb3Blci9lY2hvL2Zyb250ZW5kL3NyYy9jb21wb25lbnRzL2F1dGgvX190ZXN0c19fL09UUElucHV0LnRlc3QudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogT1RQSW5wdXQgQ29tcG9uZW50IFRlc3RzXG4gKiBDb21wcmVoZW5zaXZlIHRlc3Qgc3VpdGUgZm9yIE9UUCBpbnB1dCBmdW5jdGlvbmFsaXR5XG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHJlbmRlciwgc2NyZWVuLCBmaXJlRXZlbnQsIHdhaXRGb3IgfSBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3JlYWN0JztcbmltcG9ydCB1c2VyRXZlbnQgZnJvbSAnQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50JztcbmltcG9ydCBPVFBJbnB1dCBmcm9tICdAL2NvbXBvbmVudHMvYXV0aC9PVFBJbnB1dCc7XG5cbmRlc2NyaWJlKCdPVFBJbnB1dCcsICgpID0+IHtcbiAgY29uc3QgdXNlciA9IHVzZXJFdmVudC5zZXR1cCgpO1xuICBjb25zdCBtb2NrT25Db21wbGV0ZSA9IGplc3QuZm4oKTtcbiAgY29uc3QgbW9ja09uQ2hhbmdlID0gamVzdC5mbigpO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ29tcG9uZW50IFJlbmRlcmluZycsICgpID0+IHtcbiAgICBpdCgncmVuZGVycyBjb3JyZWN0IG51bWJlciBvZiBpbnB1dCBmaWVsZHMnLCAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuICAgICAgZXhwZWN0KGlucHV0cykudG9IYXZlTGVuZ3RoKDYpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3JlbmRlcnMgd2l0aCBjdXN0b20gbGVuZ3RoJywgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezR9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcbiAgICAgIGV4cGVjdChpbnB1dHMpLnRvSGF2ZUxlbmd0aCg0KTtcbiAgICB9KTtcblxuICAgIGl0KCdyZW5kZXJzIHdpdGggcHJvcGVyIHN0cnVjdHVyZScsICgpID0+IHtcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuXG4gICAgICBjb25zdCBjb250YWluZXIgPSBzY3JlZW5cbiAgICAgICAgLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpWzBdXG4gICAgICAgIC5jbG9zZXN0KCcub3RwLWlucHV0LWNvbnRhaW5lcicpO1xuICAgICAgZXhwZWN0KGNvbnRhaW5lcikudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG93cyBsb2FkaW5nIHN0YXRlJywgKCkgPT4ge1xuICAgICAgcmVuZGVyKFxuICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gbG9hZGluZz17dHJ1ZX0gLz5cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcbiAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgICBleHBlY3QoaW5wdXQpLnRvQmVEaXNhYmxlZCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvd3MgZXJyb3Igc3RhdGUnLCAoKSA9PiB7XG4gICAgICByZW5kZXIoXG4gICAgICAgIDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSBlcnJvcj1cIkludmFsaWQgT1RQXCIgLz5cbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdJbnZhbGlkIE9UUCcpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnSW5wdXQgQmVoYXZpb3InLCAoKSA9PiB7XG4gICAgaXQoJ2FjY2VwdHMgb25seSBudW1lcmljIGlucHV0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGZpcnN0SW5wdXQgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94JylbMF07XG5cbiAgICAgIGF3YWl0IHVzZXIudHlwZShmaXJzdElucHV0LCAnYScpO1xuICAgICAgZXhwZWN0KGZpcnN0SW5wdXQpLnRvSGF2ZVZhbHVlKCcnKTtcblxuICAgICAgYXdhaXQgdXNlci50eXBlKGZpcnN0SW5wdXQsICcxJyk7XG4gICAgICBleHBlY3QoZmlyc3RJbnB1dCkudG9IYXZlVmFsdWUoJzEnKTtcbiAgICB9KTtcblxuICAgIGl0KCdtb3ZlcyB0byBuZXh0IGlucHV0IGFmdGVyIGVudGVyaW5nIGRpZ2l0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcblxuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzEnKTtcbiAgICAgIGV4cGVjdChpbnB1dHNbMV0pLnRvSGF2ZUZvY3VzKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnbW92ZXMgdG8gcHJldmlvdXMgaW5wdXQgb24gYmFja3NwYWNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcblxuICAgICAgLy8gVHlwZSBpbiBmaXJzdCBpbnB1dCBhbmQgbW92ZSB0byBzZWNvbmRcbiAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMF0sICcxJyk7XG4gICAgICBleHBlY3QoaW5wdXRzWzFdKS50b0hhdmVGb2N1cygpO1xuXG4gICAgICAvLyBCYWNrc3BhY2Ugc2hvdWxkIG1vdmUgYmFjayB0byBmaXJzdCBpbnB1dFxuICAgICAgYXdhaXQgdXNlci5rZXlib2FyZCgne0JhY2tzcGFjZX0nKTtcbiAgICAgIGV4cGVjdChpbnB1dHNbMF0pLnRvSGF2ZUZvY3VzKCk7XG4gICAgfSk7XG5cbiAgICBpdCgncmVwbGFjZXMgZXhpc3RpbmcgZGlnaXQgd2hlbiB0eXBpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgZmlyc3RJbnB1dCA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKVswXTtcblxuICAgICAgYXdhaXQgdXNlci50eXBlKGZpcnN0SW5wdXQsICcxJyk7XG4gICAgICBleHBlY3QoZmlyc3RJbnB1dCkudG9IYXZlVmFsdWUoJzEnKTtcblxuICAgICAgLy8gQ2xlYXIgYW5kIHR5cGUgbmV3IGRpZ2l0XG4gICAgICBhd2FpdCB1c2VyLmNsZWFyKGZpcnN0SW5wdXQpO1xuICAgICAgYXdhaXQgdXNlci50eXBlKGZpcnN0SW5wdXQsICcyJyk7XG4gICAgICBleHBlY3QoZmlyc3RJbnB1dCkudG9IYXZlVmFsdWUoJzInKTtcbiAgICB9KTtcblxuICAgIGl0KCdoYW5kbGVzIGFycm93IGtleSBuYXZpZ2F0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcblxuICAgICAgaW5wdXRzWzBdLmZvY3VzKCk7XG5cbiAgICAgIGF3YWl0IHVzZXIua2V5Ym9hcmQoJ3tBcnJvd1JpZ2h0fScpO1xuICAgICAgZXhwZWN0KGlucHV0c1sxXSkudG9IYXZlRm9jdXMoKTtcblxuICAgICAgYXdhaXQgdXNlci5rZXlib2FyZCgne0Fycm93TGVmdH0nKTtcbiAgICAgIGV4cGVjdChpbnB1dHNbMF0pLnRvSGF2ZUZvY3VzKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyBIb21lIGtleSB0byBqdW1wIHRvIGZpcnN0IGlucHV0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcblxuICAgICAgaW5wdXRzWzNdLmZvY3VzKCk7XG4gICAgICBleHBlY3QoaW5wdXRzWzNdKS50b0hhdmVGb2N1cygpO1xuXG4gICAgICBhd2FpdCB1c2VyLmtleWJvYXJkKCd7SG9tZX0nKTtcbiAgICAgIGV4cGVjdChpbnB1dHNbMF0pLnRvSGF2ZUZvY3VzKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyBFbmQga2V5IHRvIGp1bXAgdG8gbGFzdCBpbnB1dCcsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuXG4gICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgIGlucHV0c1syXS5mb2N1cygpO1xuICAgICAgZXhwZWN0KGlucHV0c1syXSkudG9IYXZlRm9jdXMoKTtcblxuICAgICAgYXdhaXQgdXNlci5rZXlib2FyZCgne0VuZH0nKTtcbiAgICAgIGV4cGVjdChpbnB1dHNbNV0pLnRvSGF2ZUZvY3VzKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyBiYWNrc3BhY2Ugb24gZmlsbGVkIGlucHV0IHRvIGNsZWFyIGl0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcblxuICAgICAgLy8gRmlsbCBmaXJzdCBpbnB1dFxuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzEnKTtcbiAgICAgIGV4cGVjdChpbnB1dHNbMF0pLnRvSGF2ZVZhbHVlKCcxJyk7XG5cbiAgICAgIC8vIEdvIGJhY2sgdG8gZmlyc3QgaW5wdXRcbiAgICAgIGlucHV0c1swXS5mb2N1cygpO1xuXG4gICAgICAvLyBCYWNrc3BhY2Ugc2hvdWxkIGNsZWFyIGN1cnJlbnQgaW5wdXRcbiAgICAgIGF3YWl0IHVzZXIua2V5Ym9hcmQoJ3tCYWNrc3BhY2V9Jyk7XG4gICAgICBleHBlY3QoaW5wdXRzWzBdKS50b0hhdmVWYWx1ZSgnJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyBtdWx0aS1jaGFyYWN0ZXIgaW5wdXQgZnJvbSByYXBpZCB0eXBpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICAvLyBTdGFydCBmcm9tIG1pZGRsZSBpbnB1dFxuICAgICAgaW5wdXRzWzJdLmZvY3VzKCk7XG5cbiAgICAgIC8vIFNpbXVsYXRlIHJhcGlkIG11bHRpLWNoYXJhY3RlciBpbnB1dFxuICAgICAgZmlyZUV2ZW50LmNoYW5nZShpbnB1dHNbMl0sIHsgdGFyZ2V0OiB7IHZhbHVlOiAnMzQ1JyB9IH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KGlucHV0c1syXSkudG9IYXZlVmFsdWUoJzMnKTtcbiAgICAgICAgZXhwZWN0KGlucHV0c1szXSkudG9IYXZlVmFsdWUoJzQnKTtcbiAgICAgICAgZXhwZWN0KGlucHV0c1s0XSkudG9IYXZlVmFsdWUoJzUnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUGFzdGUgRnVuY3Rpb25hbGl0eScsICgpID0+IHtcbiAgICBpdCgnaGFuZGxlcyBwYXN0ZSBvZiBjb21wbGV0ZSBPVFAnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgZmlyc3RJbnB1dCA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKVswXTtcbiAgICAgIGZpcnN0SW5wdXQuZm9jdXMoKTtcblxuICAgICAgLy8gU2ltdWxhdGUgcGFzdGUgZXZlbnRcbiAgICAgIGNvbnN0IHBhc3RlRXZlbnQgPSBuZXcgQ2xpcGJvYXJkRXZlbnQoJ3Bhc3RlJywge1xuICAgICAgICBjbGlwYm9hcmREYXRhOiBuZXcgRGF0YVRyYW5zZmVyKCksXG4gICAgICB9KTtcbiAgICAgIHBhc3RlRXZlbnQuY2xpcGJvYXJkRGF0YT8uc2V0RGF0YSgndGV4dC9wbGFpbicsICcxMjM0NTYnKTtcblxuICAgICAgZmlyZUV2ZW50LnBhc3RlKGZpcnN0SW5wdXQsIHBhc3RlRXZlbnQpO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KG1vY2tPbkNvbXBsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnMTIzNDU2Jyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdoYW5kbGVzIHBhc3RlIG9mIHBhcnRpYWwgT1RQJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGZpcnN0SW5wdXQgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94JylbMF07XG4gICAgICBmaXJzdElucHV0LmZvY3VzKCk7XG5cbiAgICAgIGNvbnN0IHBhc3RlRXZlbnQgPSBuZXcgQ2xpcGJvYXJkRXZlbnQoJ3Bhc3RlJywge1xuICAgICAgICBjbGlwYm9hcmREYXRhOiBuZXcgRGF0YVRyYW5zZmVyKCksXG4gICAgICB9KTtcbiAgICAgIHBhc3RlRXZlbnQuY2xpcGJvYXJkRGF0YT8uc2V0RGF0YSgndGV4dC9wbGFpbicsICcxMjMnKTtcblxuICAgICAgZmlyZUV2ZW50LnBhc3RlKGZpcnN0SW5wdXQsIHBhc3RlRXZlbnQpO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuICAgICAgICBleHBlY3QoaW5wdXRzWzBdKS50b0hhdmVWYWx1ZSgnMScpO1xuICAgICAgICBleHBlY3QoaW5wdXRzWzFdKS50b0hhdmVWYWx1ZSgnMicpO1xuICAgICAgICBleHBlY3QoaW5wdXRzWzJdKS50b0hhdmVWYWx1ZSgnMycpO1xuICAgICAgICBleHBlY3QoaW5wdXRzWzJdKS50b0hhdmVGb2N1cygpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnaWdub3JlcyBub24tbnVtZXJpYyBwYXN0ZSBjb250ZW50JywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGZpcnN0SW5wdXQgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94JylbMF07XG4gICAgICBmaXJzdElucHV0LmZvY3VzKCk7XG5cbiAgICAgIGNvbnN0IHBhc3RlRXZlbnQgPSBuZXcgQ2xpcGJvYXJkRXZlbnQoJ3Bhc3RlJywge1xuICAgICAgICBjbGlwYm9hcmREYXRhOiBuZXcgRGF0YVRyYW5zZmVyKCksXG4gICAgICB9KTtcbiAgICAgIHBhc3RlRXZlbnQuY2xpcGJvYXJkRGF0YT8uc2V0RGF0YSgndGV4dC9wbGFpbicsICdhYmMxMjMnKTtcblxuICAgICAgZmlyZUV2ZW50LnBhc3RlKGZpcnN0SW5wdXQsIHBhc3RlRXZlbnQpO1xuXG4gICAgICAvLyBTaG91bGQgbm90IGZpbGwgYW55IGlucHV0cyB3aXRoIGludmFsaWQgY2hhcmFjdGVyc1xuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuICAgICAgaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICAgIGV4cGVjdChpbnB1dCkudG9IYXZlVmFsdWUoJycpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyBwYXN0ZSBsb25nZXIgdGhhbiBpbnB1dCBsZW5ndGgnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17NH0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgZmlyc3RJbnB1dCA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKVswXTtcbiAgICAgIGZpcnN0SW5wdXQuZm9jdXMoKTtcblxuICAgICAgY29uc3QgcGFzdGVFdmVudCA9IG5ldyBDbGlwYm9hcmRFdmVudCgncGFzdGUnLCB7XG4gICAgICAgIGNsaXBib2FyZERhdGE6IG5ldyBEYXRhVHJhbnNmZXIoKSxcbiAgICAgIH0pO1xuICAgICAgcGFzdGVFdmVudC5jbGlwYm9hcmREYXRhPy5zZXREYXRhKCd0ZXh0L3BsYWluJywgJzEyMzQ1Njc4OScpO1xuXG4gICAgICBmaXJlRXZlbnQucGFzdGUoZmlyc3RJbnB1dCwgcGFzdGVFdmVudCk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QobW9ja09uQ29tcGxldGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcxMjM0Jyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvbXBsZXRpb24gSGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ2NhbGxzIG9uQ29tcGxldGUgd2hlbiBhbGwgZmllbGRzIGFyZSBmaWxsZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17NH0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnMScpO1xuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1sxXSwgJzInKTtcbiAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMl0sICczJyk7XG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzNdLCAnNCcpO1xuXG4gICAgICBleHBlY3QobW9ja09uQ29tcGxldGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcxMjM0Jyk7XG4gICAgfSk7XG5cbiAgICBpdCgndXBkYXRlcyBpbnRlcm5hbCBzdGF0ZSBvbiBpbnB1dCBjaGFuZ2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17NH0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnMScpO1xuICAgICAgZXhwZWN0KGlucHV0c1swXSkudG9IYXZlVmFsdWUoJzEnKTtcblxuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1sxXSwgJzInKTtcbiAgICAgIGV4cGVjdChpbnB1dHNbMV0pLnRvSGF2ZVZhbHVlKCcyJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnZG9lcyBub3QgY2FsbCBvbkNvbXBsZXRlIGZvciBpbmNvbXBsZXRlIE9UUCcsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuXG4gICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMF0sICcxJyk7XG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzFdLCAnMicpO1xuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1syXSwgJzMnKTtcblxuICAgICAgZXhwZWN0KG1vY2tPbkNvbXBsZXRlKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ29tcG9uZW50IFN0YXRlIE1hbmFnZW1lbnQnLCAoKSA9PiB7XG4gICAgaXQoJ21haW50YWlucyBpbnRlcm5hbCBzdGF0ZSBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnMScpO1xuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1sxXSwgJzInKTtcbiAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMl0sICczJyk7XG5cbiAgICAgIGV4cGVjdChpbnB1dHNbMF0pLnRvSGF2ZVZhbHVlKCcxJyk7XG4gICAgICBleHBlY3QoaW5wdXRzWzFdKS50b0hhdmVWYWx1ZSgnMicpO1xuICAgICAgZXhwZWN0KGlucHV0c1syXSkudG9IYXZlVmFsdWUoJzMnKTtcbiAgICB9KTtcblxuICAgIGl0KCdyZXNldHMgc3RhdGUgd2hlbiBjb21wb25lbnQgcmVtb3VudHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHVubW91bnQgfSA9IHJlbmRlcihcbiAgICAgICAgPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+XG4gICAgICApO1xuXG4gICAgICB1bm1vdW50KCk7XG5cbiAgICAgIC8vIFJlbmRlciBhIG5ldyBpbnN0YW5jZVxuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcbiAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgICBleHBlY3QoaW5wdXQpLnRvSGF2ZVZhbHVlKCcnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQWNjZXNzaWJpbGl0eScsICgpID0+IHtcbiAgICBpdCgnaGFzIHByb3BlciBBUklBIGF0dHJpYnV0ZXMnLCAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuICAgICAgaW5wdXRzLmZvckVhY2goKGlucHV0LCBpbmRleCkgPT4ge1xuICAgICAgICBleHBlY3QoaW5wdXQpLnRvSGF2ZUF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGBEaWdpdCAke2luZGV4ICsgMX0gb2YgNmApO1xuICAgICAgICBleHBlY3QoaW5wdXQpLnRvSGF2ZUF0dHJpYnV0ZSgnaW5wdXRNb2RlJywgJ251bWVyaWMnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3N1cHBvcnRzIHNjcmVlbiByZWFkZXJzIHdpdGggbGl2ZSByZWdpb24nLCAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgbGl2ZVJlZ2lvbiA9IHNjcmVlbi5nZXRCeVJvbGUoJ3N0YXR1cycpO1xuICAgICAgZXhwZWN0KGxpdmVSZWdpb24pLnRvSGF2ZUF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ3BvbGl0ZScpO1xuICAgICAgZXhwZWN0KGxpdmVSZWdpb24pLnRvSGF2ZUF0dHJpYnV0ZSgnYXJpYS1hdG9taWMnLCAndHJ1ZScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2Fubm91bmNlcyBlcnJvcnMgdG8gc2NyZWVuIHJlYWRlcnMnLCAoKSA9PiB7XG4gICAgICByZW5kZXIoXG4gICAgICAgIDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSBlcnJvcj1cIkludmFsaWQgT1RQXCIgLz5cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGVycm9yRWxlbWVudCA9IHNjcmVlbi5nZXRCeVRleHQoJ0ludmFsaWQgT1RQJyk7XG4gICAgICBleHBlY3QoZXJyb3JFbGVtZW50KS50b0hhdmVBdHRyaWJ1dGUoJ3JvbGUnLCAnYWxlcnQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1NlY3VyaXR5JywgKCkgPT4ge1xuICAgIGl0KCdkb2VzIG5vdCBleHBvc2UgT1RQIGluIERPTSBhdHRyaWJ1dGVzJywgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcbiAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgICBleHBlY3QoaW5wdXQpLm5vdC50b0hhdmVBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnKTtcbiAgICAgICAgZXhwZWN0KGlucHV0KS5ub3QudG9IYXZlQXR0cmlidXRlKCd0aXRsZScpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgndXNlcyBwcm9wZXIgaW5wdXQgbW9kZSBmb3IgbnVtZXJpYyBpbnB1dCcsICgpID0+IHtcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuXG4gICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG4gICAgICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgICAgZXhwZWN0KGlucHV0KS50b0hhdmVBdHRyaWJ1dGUoJ2lucHV0TW9kZScsICdudW1lcmljJyk7XG4gICAgICAgIGV4cGVjdChpbnB1dCkudG9IYXZlQXR0cmlidXRlKCdtYXhMZW5ndGgnLCAnMScpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFZGdlIENhc2VzJywgKCkgPT4ge1xuICAgIGl0KCdoYW5kbGVzIHJhcGlkIHR5cGluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuXG4gICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgIC8vIFR5cGUgcmFwaWRseSBpbiBzZXF1ZW5jZVxuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzEyMzQ1NicpO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KG1vY2tPbkNvbXBsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnMTIzNDU2Jyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdoYW5kbGVzIGZvY3VzIGV2ZW50cyBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICAvLyBGb2N1cyBvbiBtaWRkbGUgaW5wdXRcbiAgICAgIGlucHV0c1syXS5mb2N1cygpO1xuICAgICAgZXhwZWN0KGlucHV0c1syXSkudG9IYXZlRm9jdXMoKTtcblxuICAgICAgLy8gVHlwZSBzaG91bGQgd29yayBmcm9tIGFueSBmb2N1c2VkIGlucHV0XG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzJdLCAnNScpO1xuICAgICAgZXhwZWN0KGlucHV0c1syXSkudG9IYXZlVmFsdWUoJzUnKTtcbiAgICB9KTtcblxuICAgIGl0KCdoYW5kbGVzIGxvYWRpbmcgc3RhdGUgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgcmVuZGVyKFxuICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gbG9hZGluZz17dHJ1ZX0gLz5cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcbiAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgICBleHBlY3QoaW5wdXQpLnRvQmVEaXNhYmxlZCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdWZXJpZnlpbmcuLi4nKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdoYW5kbGVzIGVycm9yIHN0YXRlIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIHJlbmRlcihcbiAgICAgICAgPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IGVycm9yPVwiSW52YWxpZCBjb2RlXCIgLz5cbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdJbnZhbGlkIGNvZGUnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlSb2xlKCdhbGVydCcpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgaXQoJ2RvZXMgbm90IGNhdXNlIHVubmVjZXNzYXJ5IHJlLXJlbmRlcnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCByZW5kZXJTcHkgPSBqZXN0LmZuKCk7XG5cbiAgICAgIGNvbnN0IFRlc3RDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICAgIHJlbmRlclNweSgpO1xuICAgICAgICByZXR1cm4gPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+O1xuICAgICAgfTtcblxuICAgICAgY29uc3QgeyByZXJlbmRlciB9ID0gcmVuZGVyKDxUZXN0Q29tcG9uZW50IC8+KTtcblxuICAgICAgZXhwZWN0KHJlbmRlclNweSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuXG4gICAgICAvLyBSZS1yZW5kZXIgd2l0aCBzYW1lIHByb3BzXG4gICAgICByZXJlbmRlcig8VGVzdENvbXBvbmVudCAvPik7XG5cbiAgICAgIC8vIFNob3VsZCBub3QgY2F1c2UgYWRkaXRpb25hbCByZW5kZXJzIGR1ZSB0byBtZW1vaXphdGlvblxuICAgICAgZXhwZWN0KHJlbmRlclNweSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUHJvZHVjdGlvbiBFcnJvciBTY2VuYXJpb3MnLCAoKSA9PiB7XG4gICAgZGVzY3JpYmUoJ05ldHdvcmsgYW5kIEFQSSBGYWlsdXJlcycsICgpID0+IHtcbiAgICAgIGl0KCdjYWxscyBvbkNvbXBsZXRlIGNhbGxiYWNrIHdoZW4gY29kZSBpcyBjb21wbGV0ZScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3Qgc3VjY2Vzc0NhbGxiYWNrID0gamVzdC5mbigpO1xuXG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXtzdWNjZXNzQ2FsbGJhY2t9IC8+KTtcbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMF0sICcxMjM0NTYnKTtcblxuICAgICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgICBleHBlY3Qoc3VjY2Vzc0NhbGxiYWNrKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnMTIzNDU2Jyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdhbGxvd3MgbXVsdGlwbGUgY2FsbGJhY2sgaW52b2NhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gamVzdC5mbigpO1xuXG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs0fSBvbkNvbXBsZXRlPXtjYWxsYmFja30gLz4pO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgICAgLy8gRmlyc3QgY29kZVxuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnMTIzNCcpO1xuXG4gICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChjYWxsYmFjaykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDbGVhciBhbmQgZW50ZXIgbmV3IGNvZGVcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICBhd2FpdCB1c2VyLmNsZWFyKGlucHV0c1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnNTY3OCcpO1xuXG4gICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChjYWxsYmFjaykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgncGFzc2VzIGNvcnJlY3QgY29kZSB0byBjYWxsYmFjaycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbGV0IHJlY2VpdmVkQ29kZSA9ICcnO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IGplc3QuZm4oKGNvZGU6IHN0cmluZykgPT4ge1xuICAgICAgICAgIHJlY2VpdmVkQ29kZSA9IGNvZGU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXtjYWxsYmFja30gLz4pO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzk4NzY1NCcpO1xuXG4gICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChyZWNlaXZlZENvZGUpLnRvQmUoJzk4NzY1NCcpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ01lbW9yeSBhbmQgUmVzb3VyY2UgTWFuYWdlbWVudCcsICgpID0+IHtcbiAgICAgIGl0KCdjbGVhbnMgdXAgZXZlbnQgbGlzdGVuZXJzIG9uIHVubW91bnQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdW5tb3VudCB9ID0gcmVuZGVyKFxuICAgICAgICAgIDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPlxuICAgICAgICApO1xuXG4gICAgICAgIC8vIENvbXBvbmVudCBzaG91bGQgdW5tb3VudCB3aXRob3V0IGVycm9yc1xuICAgICAgICBleHBlY3QoKCkgPT4gdW5tb3VudCgpKS5ub3QudG9UaHJvdygpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdoYW5kbGVzIHJhcGlkIGNvbXBvbmVudCBtb3VudC91bm1vdW50IGN5Y2xlcycsICgpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgeyB1bm1vdW50IH0gPSByZW5kZXIoXG4gICAgICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz5cbiAgICAgICAgICApO1xuICAgICAgICAgIHVubW91bnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNob3VsZCBub3QgbGVhayBtZW1vcnkgb3IgdGhyb3cgZXJyb3JzXG4gICAgICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdoYW5kbGVzIGV4dHJlbWVseSBsb25nIE9UUCBjb2RlcyBlZmZpY2llbnRseScsICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcbiAgICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXsyMH0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+XG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuICAgICAgICBleHBlY3QoaW5wdXRzKS50b0hhdmVMZW5ndGgoMjApO1xuXG4gICAgICAgIC8vIFNob3VsZCByZW5kZXIgd2l0aG91dCBwZXJmb3JtYW5jZSBpc3N1ZXNcbiAgICAgICAgZXhwZWN0KGNvbnRhaW5lcikudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ1JhY2UgQ29uZGl0aW9ucyBhbmQgVGltaW5nIElzc3VlcycsICgpID0+IHtcbiAgICAgIGl0KCdoYW5kbGVzIHNpbXVsdGFuZW91cyBpbnB1dCBjaGFuZ2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICAgIC8vIFNpbXVsYXRlIHJhcGlkLCBzaW11bHRhbmVvdXMgY2hhbmdlc1xuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnMScpO1xuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzFdLCAnMicpO1xuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzJdLCAnMycpO1xuXG4gICAgICAgIC8vIFNob3VsZCBoYW5kbGUgZ3JhY2VmdWxseSAtIGNoZWNrIHRoYXQgYXQgbGVhc3Qgb25lIGlucHV0IGhhcyBhIHZhbHVlXG4gICAgICAgIGNvbnN0IGhhc1ZhbHVlcyA9IGlucHV0cy5zb21lKFxuICAgICAgICAgIChpbnB1dCkgPT4gaW5wdXQuZ2V0QXR0cmlidXRlKCd2YWx1ZScpICE9PSAnJ1xuICAgICAgICApO1xuICAgICAgICBleHBlY3QoaGFzVmFsdWVzKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdoYW5kbGVzIG9uQ2hhbmdlIGR1cmluZyBsb2FkaW5nIHN0YXRlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlcmVuZGVyIH0gPSByZW5kZXIoXG4gICAgICAgICAgPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IGxvYWRpbmc9e2ZhbHNlfSAvPlxuICAgICAgICApO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzEnKTtcblxuICAgICAgICAvLyBTd2l0Y2ggdG8gbG9hZGluZyBtaWQtaW5wdXRcbiAgICAgICAgcmVyZW5kZXIoXG4gICAgICAgICAgPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IGxvYWRpbmc9e3RydWV9IC8+XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gSW5wdXRzIHNob3VsZCBiZSBkaXNhYmxlZFxuICAgICAgICBjb25zdCB1cGRhdGVkSW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuICAgICAgICB1cGRhdGVkSW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICAgICAgZXhwZWN0KGlucHV0KS50b0JlRGlzYWJsZWQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ2hhbmRsZXMgb25Db21wbGV0ZSBiZWluZyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgZm9yIHNhbWUgY29kZScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBqZXN0LmZuKCk7XG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs0fSBvbkNvbXBsZXRlPXtjYWxsYmFja30gLz4pO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzEyMzQnKTtcblxuICAgICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgICBleHBlY3QoY2FsbGJhY2spLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVHlwaW5nIHNhbWUgY29kZSBhZ2FpblxuICAgICAgICBhd2FpdCB1c2VyLmNsZWFyKGlucHV0c1swXSk7XG4gICAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMF0sICcxMjM0Jyk7XG5cbiAgICAgICAgLy8gU2hvdWxkIGJlIGNhbGxlZCBhZ2FpblxuICAgICAgICBleHBlY3QoY2FsbGJhY2spLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygyKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnaGFuZGxlcyByYXBpZCBlcnJvciBzdGF0ZSBjaGFuZ2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlcmVuZGVyIH0gPSByZW5kZXIoXG4gICAgICAgICAgPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IGVycm9yPVwiXCIgLz5cbiAgICAgICAgKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgICByZXJlbmRlcihcbiAgICAgICAgICAgIDxPVFBJbnB1dFxuICAgICAgICAgICAgICBsZW5ndGg9ezZ9XG4gICAgICAgICAgICAgIG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfVxuICAgICAgICAgICAgICBlcnJvcj17YEVycm9yICR7aX1gfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApO1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwKSk7XG4gICAgICAgICAgcmVyZW5kZXIoXG4gICAgICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gZXJyb3I9XCJcIiAvPlxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaG91bGQgaGFuZGxlIHJhcGlkIGNoYW5nZXMgd2l0aG91dCBjcmFzaGluZ1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpKS50b0hhdmVMZW5ndGgoNik7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdJbnB1dCBWYWxpZGF0aW9uIEVkZ2UgQ2FzZXMnLCAoKSA9PiB7XG4gICAgICBpdCgnaGFuZGxlcyBzcGVjaWFsIFVuaWNvZGUgZGlnaXRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICAgIC8vIFRyeSB0byBpbnB1dCBVbmljb2RlIG1hdGhlbWF0aWNhbCBkaWdpdHNcbiAgICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJ/Cdn4/wnZ+Q8J2fkScpO1xuXG4gICAgICAgIC8vIFNob3VsZCByZWplY3Qgbm9uLUFTQ0lJIGRpZ2l0c1xuICAgICAgICBleHBlY3QoaW5wdXRzWzBdKS50b0hhdmVWYWx1ZSgnJyk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ2hhbmRsZXMgbWl4ZWQgdmFsaWQgYW5kIGludmFsaWQgY2hhcmFjdGVycyBpbiBwYXN0ZScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG4gICAgICAgIGNvbnN0IGZpcnN0SW5wdXQgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94JylbMF07XG4gICAgICAgIGZpcnN0SW5wdXQuZm9jdXMoKTtcblxuICAgICAgICBjb25zdCBwYXN0ZUV2ZW50ID0gbmV3IENsaXBib2FyZEV2ZW50KCdwYXN0ZScsIHtcbiAgICAgICAgICBjbGlwYm9hcmREYXRhOiBuZXcgRGF0YVRyYW5zZmVyKCksXG4gICAgICAgIH0pO1xuICAgICAgICBwYXN0ZUV2ZW50LmNsaXBib2FyZERhdGE/LnNldERhdGEoJ3RleHQvcGxhaW4nLCAnMTJhYmMzNCcpO1xuXG4gICAgICAgIGZpcmVFdmVudC5wYXN0ZShmaXJzdElucHV0LCBwYXN0ZUV2ZW50KTtcblxuICAgICAgICAvLyBTaG91bGQgcmVqZWN0IGVudGlyZSBwYXN0ZSBkdWUgdG8gaW52YWxpZCBjaGFyYWN0ZXJzXG4gICAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcbiAgICAgICAgaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICAgICAgZXhwZWN0KGlucHV0KS50b0hhdmVWYWx1ZSgnJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdoYW5kbGVzIHdoaXRlc3BhY2UgaW4gcGFzdGVkIGNvbnRlbnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuICAgICAgICBjb25zdCBmaXJzdElucHV0ID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpWzBdO1xuICAgICAgICBmaXJzdElucHV0LmZvY3VzKCk7XG5cbiAgICAgICAgY29uc3QgcGFzdGVFdmVudCA9IG5ldyBDbGlwYm9hcmRFdmVudCgncGFzdGUnLCB7XG4gICAgICAgICAgY2xpcGJvYXJkRGF0YTogbmV3IERhdGFUcmFuc2ZlcigpLFxuICAgICAgICB9KTtcbiAgICAgICAgcGFzdGVFdmVudC5jbGlwYm9hcmREYXRhPy5zZXREYXRhKCd0ZXh0L3BsYWluJywgJyAgMTIzNDU2ICAnKTtcblxuICAgICAgICBmaXJlRXZlbnQucGFzdGUoZmlyc3RJbnB1dCwgcGFzdGVFdmVudCk7XG5cbiAgICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgICAgZXhwZWN0KG1vY2tPbkNvbXBsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnMTIzNDU2Jyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdoYW5kbGVzIG5ld2xpbmVzIGluIHBhc3RlZCBjb250ZW50JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcbiAgICAgICAgY29uc3QgZmlyc3RJbnB1dCA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKVswXTtcbiAgICAgICAgZmlyc3RJbnB1dC5mb2N1cygpO1xuXG4gICAgICAgIGNvbnN0IHBhc3RlRXZlbnQgPSBuZXcgQ2xpcGJvYXJkRXZlbnQoJ3Bhc3RlJywge1xuICAgICAgICAgIGNsaXBib2FyZERhdGE6IG5ldyBEYXRhVHJhbnNmZXIoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHBhc3RlRXZlbnQuY2xpcGJvYXJkRGF0YT8uc2V0RGF0YSgndGV4dC9wbGFpbicsICcxMjNcXG40NTYnKTtcblxuICAgICAgICBmaXJlRXZlbnQucGFzdGUoZmlyc3RJbnB1dCwgcGFzdGVFdmVudCk7XG5cbiAgICAgICAgLy8gU2hvdWxkIHJlamVjdCBkdWUgdG8gbmV3bGluZVxuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG4gICAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChpbnB1dCkudG9IYXZlVmFsdWUoJycpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnaGFuZGxlcyB6ZXJvLXdpZHRoIGNoYXJhY3RlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgICAgLy8gVHJ5IHRvIGlucHV0IHplcm8td2lkdGggc3BhY2VcbiAgICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzFcXHUyMDBCMicpO1xuXG4gICAgICAgIC8vIFNob3VsZCBvbmx5IGFjY2VwdCB0aGUgZGlnaXRzXG4gICAgICAgIGV4cGVjdChpbnB1dHNbMF0pLnRvSGF2ZVZhbHVlKCcxJyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdCcm93c2VyIENvbXBhdGliaWxpdHkgRWRnZSBDYXNlcycsICgpID0+IHtcbiAgICAgIGl0KCdoYW5kbGVzIG1pc3NpbmcgY2xpcGJvYXJkRGF0YSBncmFjZWZ1bGx5JywgKCkgPT4ge1xuICAgICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcbiAgICAgICAgY29uc3QgZmlyc3RJbnB1dCA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKVswXTtcblxuICAgICAgICAvLyBTaW11bGF0ZSBvbGQgYnJvd3NlciB3aXRob3V0IGNsaXBib2FyZERhdGFcbiAgICAgICAgY29uc3QgcGFzdGVFdmVudCA9IG5ldyBFdmVudCgncGFzdGUnKSBhcyBhbnk7XG4gICAgICAgIGZpcmVFdmVudChmaXJzdElucHV0LCBwYXN0ZUV2ZW50KTtcblxuICAgICAgICAvLyBTaG91bGQgbm90IGNyYXNoXG4gICAgICAgIGV4cGVjdChmaXJzdElucHV0KS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdoYW5kbGVzIGlucHV0cyB3aXRob3V0IHNlbGVjdCBtZXRob2QnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgICAgLy8gQ29tcG9uZW50IHNob3VsZCBoYW5kbGUgbWlzc2luZyBzZWxlY3QgbWV0aG9kIGdyYWNlZnVsbHlcbiAgICAgICAgLy8gVGhpcyB0ZXN0cyBkZWZlbnNpdmUgcHJvZ3JhbW1pbmcgZm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGV4cGVjdChpbnB1dHNbMF0pLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICAgIGV4cGVjdCh0eXBlb2YgaW5wdXRzWzBdLnNlbGVjdCkudG9CZSgnZnVuY3Rpb24nKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnaGFuZGxlcyBmb2N1cyBvbiBudWxsIHJlZnMgZ3JhY2VmdWxseScsICgpID0+IHtcbiAgICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgICAgLy8gQ29tcG9uZW50IHNob3VsZCBoYW5kbGUgbnVsbCByZWZzIGludGVybmFsbHlcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKSkudG9IYXZlTGVuZ3RoKDYpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnSGlnaCBMb2FkIFNjZW5hcmlvcycsICgpID0+IHtcbiAgICAgIGl0KCdoYW5kbGVzIDEwMDArIHJhcGlkIGtleXN0cm9rZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgICAgLy8gU2ltdWxhdGUgdXNlciBtYXNoaW5nIGtleXMgcmFwaWRseVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDA7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHJhbmRvbUlucHV0ID0gaW5wdXRzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGlucHV0cy5sZW5ndGgpXTtcbiAgICAgICAgICBjb25zdCByYW5kb21LZXkgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMCkudG9TdHJpbmcoKTtcbiAgICAgICAgICBmaXJlRXZlbnQuY2hhbmdlKHJhbmRvbUlucHV0LCB7IHRhcmdldDogeyB2YWx1ZTogcmFuZG9tS2V5IH0gfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaG91bGQgc3RpbGwgYmUgZnVuY3Rpb25hbFxuICAgICAgICBleHBlY3QoaW5wdXRzWzBdKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdoYW5kbGVzIGNvbnRpbnVvdXMgcGFzdGUgb3BlcmF0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG4gICAgICAgIGNvbnN0IGZpcnN0SW5wdXQgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94JylbMF07XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHBhc3RlRXZlbnQgPSBuZXcgQ2xpcGJvYXJkRXZlbnQoJ3Bhc3RlJywge1xuICAgICAgICAgICAgY2xpcGJvYXJkRGF0YTogbmV3IERhdGFUcmFuc2ZlcigpLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBhc3RlRXZlbnQuY2xpcGJvYXJkRGF0YT8uc2V0RGF0YShcbiAgICAgICAgICAgICd0ZXh0L3BsYWluJyxcbiAgICAgICAgICAgIGAkezEwMDAwMCArIGl9YC5zbGljZSgwLCA2KVxuICAgICAgICAgICk7XG4gICAgICAgICAgZmlyZUV2ZW50LnBhc3RlKGZpcnN0SW5wdXQsIHBhc3RlRXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hvdWxkIGhhbmRsZSB3aXRob3V0IG1lbW9yeSBsZWFrc1xuICAgICAgICBleHBlY3QoZmlyc3RJbnB1dCkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnaGFuZGxlcyBhbHRlcm5hdGluZyBmb2N1cyBiZXR3ZWVuIGFsbCBpbnB1dHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgICAgLy8gUmFwaWRseSBzd2l0Y2ggZm9jdXNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xuICAgICAgICAgIGlucHV0c1tpICUgNl0uZm9jdXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNob3VsZCBoYW5kbGUgZ3JhY2VmdWxseVxuICAgICAgICBleHBlY3QoaW5wdXRzLnNvbWUoKGlucHV0KSA9PiBpbnB1dCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpLnRvQmUoXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnQWNjZXNzaWJpbGl0eSBVbmRlciBTdHJlc3MnLCAoKSA9PiB7XG4gICAgICBpdCgnbWFpbnRhaW5zIEFSSUEgYXR0cmlidXRlcyBkdXJpbmcgcmFwaWQgc3RhdGUgY2hhbmdlcycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgeyByZXJlbmRlciB9ID0gcmVuZGVyKFxuICAgICAgICAgIDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPlxuICAgICAgICApO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICAgIHJlcmVuZGVyKFxuICAgICAgICAgICAgPE9UUElucHV0XG4gICAgICAgICAgICAgIGxlbmd0aD17Nn1cbiAgICAgICAgICAgICAgb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9XG4gICAgICAgICAgICAgIGVycm9yPXtgRXJyb3IgJHtpfWB9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG4gICAgICAgICAgaW5wdXRzLmZvckVhY2goKGlucHV0LCBpZHgpID0+IHtcbiAgICAgICAgICAgIGV4cGVjdChpbnB1dCkudG9IYXZlQXR0cmlidXRlKFxuICAgICAgICAgICAgICAnYXJpYS1sYWJlbCcsXG4gICAgICAgICAgICAgIGBEaWdpdCAke2lkeCArIDF9IG9mIDZgXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXhwZWN0KGlucHV0KS50b0hhdmVBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcsICd0cnVlJyk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXJlbmRlcihcbiAgICAgICAgICAgIDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSBlcnJvcj1cIlwiIC8+XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGl0KCdtYWludGFpbnMgbGl2ZSByZWdpb24gdXBkYXRlcyBkdXJpbmcgaGlnaCBhY3Rpdml0eScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG4gICAgICAgIGNvbnN0IGxpdmVSZWdpb24gPSBzY3JlZW4uZ2V0QnlSb2xlKCdzdGF0dXMnKTtcblxuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzW2ldLCAoaSArIDEpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgIGV4cGVjdChsaXZlUmVnaW9uKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdDb21wb25lbnQgTGlmZWN5Y2xlIEVkZ2UgQ2FzZXMnLCAoKSA9PiB7XG4gICAgICBpdCgnaGFuZGxlcyBsZW5ndGggcHJvcCBjaGFuZ2luZyBkeW5hbWljYWxseScsICgpID0+IHtcbiAgICAgICAgY29uc3QgeyByZXJlbmRlciB9ID0gcmVuZGVyKFxuICAgICAgICAgIDxPVFBJbnB1dCBsZW5ndGg9ezR9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPlxuICAgICAgICApO1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpKS50b0hhdmVMZW5ndGgoNCk7XG5cbiAgICAgICAgLy8gQ2hhbmdpbmcgbGVuZ3RoIHByb3AgY3JlYXRlcyBhIG5ldyBjb21wb25lbnQgaW5zdGFuY2VcbiAgICAgICAgLy8gVGhlIGNvbXBvbmVudCBkb2Vzbid0IGR5bmFtaWNhbGx5IHJlc2l6ZSwgc28gdGhpcyB0ZXN0IGRvY3VtZW50cyB0aGUgYmVoYXZpb3JcbiAgICAgICAgcmVyZW5kZXIoPE9UUElucHV0IGxlbmd0aD17OH0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcbiAgICAgICAgLy8gQ29tcG9uZW50IHdpbGwgc3RpbGwgaGF2ZSA0IGlucHV0cyBhcyBpdCBkb2Vzbid0IHJlLWluaXRpYWxpemVcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKS5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnaGFuZGxlcyBvbkNvbXBsZXRlIGNhbGxiYWNrIGNoYW5naW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBjYWxsYmFjazEgPSBqZXN0LmZuKCk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrMiA9IGplc3QuZm4oKTtcblxuICAgICAgICBjb25zdCB7IHJlcmVuZGVyIH0gPSByZW5kZXIoXG4gICAgICAgICAgPE9UUElucHV0IGxlbmd0aD17NH0gb25Db21wbGV0ZT17Y2FsbGJhY2sxfSAvPlxuICAgICAgICApO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzEyMzQnKTtcblxuICAgICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgICBleHBlY3QoY2FsbGJhY2sxKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENoYW5nZSBjYWxsYmFja1xuICAgICAgICByZXJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs0fSBvbkNvbXBsZXRlPXtjYWxsYmFjazJ9IC8+KTtcblxuICAgICAgICBhd2FpdCB1c2VyLmNsZWFyKGlucHV0c1swXSk7XG4gICAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMF0sICc1Njc4Jyk7XG5cbiAgICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgICAgZXhwZWN0KGNhbGxiYWNrMikudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnaGFuZGxlcyBwYXJlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IFBhcmVudENvbXBvbmVudCA9ICh7IGNvdW50IH06IHsgY291bnQ6IG51bWJlciB9KSA9PiAoXG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxzcGFuPntjb3VudH08L3NwYW4+XG4gICAgICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCB7IHJlcmVuZGVyIH0gPSByZW5kZXIoPFBhcmVudENvbXBvbmVudCBjb3VudD17MH0gLz4pO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwOyBpKyspIHtcbiAgICAgICAgICByZXJlbmRlcig8UGFyZW50Q29tcG9uZW50IGNvdW50PXtpfSAvPik7XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpKS50b0hhdmVMZW5ndGgoNik7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdFcnJvciBSZWNvdmVyeScsICgpID0+IHtcbiAgICAgIGl0KCdyZWNvdmVycyBmcm9tIGVycm9yIHN0YXRlIHdoZW4gdXNlciBjb3JyZWN0cyBpbnB1dCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgeyByZXJlbmRlciB9ID0gcmVuZGVyKFxuICAgICAgICAgIDxPVFBJbnB1dFxuICAgICAgICAgICAgbGVuZ3RoPXs2fVxuICAgICAgICAgICAgb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9XG4gICAgICAgICAgICBlcnJvcj1cIkludmFsaWQgY29kZVwiXG4gICAgICAgICAgLz5cbiAgICAgICAgKTtcblxuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnSW52YWxpZCBjb2RlJykpLnRvQmVJblRoZURvY3VtZW50KCk7XG5cbiAgICAgICAgcmVyZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IGVycm9yPVwiXCIgLz4pO1xuXG4gICAgICAgIGV4cGVjdChzY3JlZW4ucXVlcnlCeVRleHQoJ0ludmFsaWQgY29kZScpKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnYWxsb3dzIHJlLWVudHJ5IGFmdGVyIGVycm9yJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlcmVuZGVyIH0gPSByZW5kZXIoXG4gICAgICAgICAgPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IGVycm9yPVwiVHJ5IGFnYWluXCIgLz5cbiAgICAgICAgKTtcblxuICAgICAgICByZXJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gZXJyb3I9XCJcIiAvPik7XG5cbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnMTIzNDU2Jyk7XG5cbiAgICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgICAgZXhwZWN0KG1vY2tPbkNvbXBsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnMTIzNDU2Jyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdjbGVhcnMgaW5wdXQgd2hlbiBlcnJvciBpcyBzaG93bicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgeyByZXJlbmRlciB9ID0gcmVuZGVyKFxuICAgICAgICAgIDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPlxuICAgICAgICApO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzEyMycpO1xuXG4gICAgICAgIC8vIFNob3cgZXJyb3IgLSBzaW11bGF0aW5nIGZhaWxlZCB2ZXJpZmljYXRpb25cbiAgICAgICAgcmVyZW5kZXIoXG4gICAgICAgICAgPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IGVycm9yPVwiSW52YWxpZFwiIC8+XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gVXNlciBzaG91bGQgYmUgYWJsZSB0byBjbGVhciBhbmQgcmV0cnlcbiAgICAgICAgYXdhaXQgdXNlci5jbGVhcihpbnB1dHNbMF0pO1xuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnNDU2Jyk7XG5cbiAgICAgICAgZXhwZWN0KGlucHV0c1swXSkudG9IYXZlVmFsdWUoJzQnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImRlc2NyaWJlIiwidXNlciIsInVzZXJFdmVudCIsInNldHVwIiwibW9ja09uQ29tcGxldGUiLCJqZXN0IiwiZm4iLCJtb2NrT25DaGFuZ2UiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIml0IiwicmVuZGVyIiwiT1RQSW5wdXQiLCJsZW5ndGgiLCJvbkNvbXBsZXRlIiwiaW5wdXRzIiwic2NyZWVuIiwiZ2V0QWxsQnlSb2xlIiwiZXhwZWN0IiwidG9IYXZlTGVuZ3RoIiwiY29udGFpbmVyIiwiY2xvc2VzdCIsInRvQmVJblRoZURvY3VtZW50IiwibG9hZGluZyIsImZvckVhY2giLCJpbnB1dCIsInRvQmVEaXNhYmxlZCIsImVycm9yIiwiZ2V0QnlUZXh0IiwiZmlyc3RJbnB1dCIsInR5cGUiLCJ0b0hhdmVWYWx1ZSIsInRvSGF2ZUZvY3VzIiwia2V5Ym9hcmQiLCJjbGVhciIsImZvY3VzIiwiZmlyZUV2ZW50IiwiY2hhbmdlIiwidGFyZ2V0IiwidmFsdWUiLCJ3YWl0Rm9yIiwicGFzdGVFdmVudCIsIkNsaXBib2FyZEV2ZW50IiwiY2xpcGJvYXJkRGF0YSIsIkRhdGFUcmFuc2ZlciIsInNldERhdGEiLCJwYXN0ZSIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwibm90IiwidG9IYXZlQmVlbkNhbGxlZCIsInVubW91bnQiLCJpbmRleCIsInRvSGF2ZUF0dHJpYnV0ZSIsImxpdmVSZWdpb24iLCJnZXRCeVJvbGUiLCJlcnJvckVsZW1lbnQiLCJyZW5kZXJTcHkiLCJUZXN0Q29tcG9uZW50IiwicmVyZW5kZXIiLCJ0b0hhdmVCZWVuQ2FsbGVkVGltZXMiLCJzdWNjZXNzQ2FsbGJhY2siLCJjYWxsYmFjayIsImkiLCJyZWNlaXZlZENvZGUiLCJjb2RlIiwidG9CZSIsInRvVGhyb3ciLCJoYXNWYWx1ZXMiLCJzb21lIiwiZ2V0QXR0cmlidXRlIiwidXBkYXRlZElucHV0cyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsIkV2ZW50Iiwic2VsZWN0IiwicmFuZG9tSW5wdXQiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJyYW5kb21LZXkiLCJ0b1N0cmluZyIsInNsaWNlIiwiZG9jdW1lbnQiLCJhY3RpdmVFbGVtZW50IiwiaWR4IiwidG9CZUdyZWF0ZXJUaGFuIiwiY2FsbGJhY2sxIiwiY2FsbGJhY2syIiwiUGFyZW50Q29tcG9uZW50IiwiY291bnQiLCJkaXYiLCJzcGFuIiwicXVlcnlCeVRleHQiXSwibWFwcGluZ3MiOiJBQUFBOzs7Q0FHQzs7Ozs7OERBRWlCO3dCQUNpQztrRUFDN0I7aUVBQ0Q7Ozs7OztBQUVyQkEsU0FBUyxZQUFZO0lBQ25CLE1BQU1DLE9BQU9DLGtCQUFTLENBQUNDLEtBQUs7SUFDNUIsTUFBTUMsaUJBQWlCQyxLQUFLQyxFQUFFO0lBQzlCLE1BQU1DLGVBQWVGLEtBQUtDLEVBQUU7SUFFNUJFLFdBQVc7UUFDVEgsS0FBS0ksYUFBYTtJQUNwQjtJQUVBVCxTQUFTLHVCQUF1QjtRQUM5QlUsR0FBRywwQ0FBMEM7WUFDM0NDLElBQUFBLGNBQU0sZ0JBQUMscUJBQUNDLGlCQUFRO2dCQUFDQyxRQUFRO2dCQUFHQyxZQUFZVjs7WUFFeEMsTUFBTVcsU0FBU0MsY0FBTSxDQUFDQyxZQUFZLENBQUM7WUFDbkNDLE9BQU9ILFFBQVFJLFlBQVksQ0FBQztRQUM5QjtRQUVBVCxHQUFHLDhCQUE4QjtZQUMvQkMsSUFBQUEsY0FBTSxnQkFBQyxxQkFBQ0MsaUJBQVE7Z0JBQUNDLFFBQVE7Z0JBQUdDLFlBQVlWOztZQUV4QyxNQUFNVyxTQUFTQyxjQUFNLENBQUNDLFlBQVksQ0FBQztZQUNuQ0MsT0FBT0gsUUFBUUksWUFBWSxDQUFDO1FBQzlCO1FBRUFULEdBQUcsaUNBQWlDO1lBQ2xDQyxJQUFBQSxjQUFNLGdC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