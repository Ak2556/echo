34aa5c33a5bb42f944e09610273cb7e6
/**
 * @fileoverview Responsive Design Hook
 * @description Custom hook for detecting viewport size and responsive breakpoints
 * @version 1.0.0
 */ "use client";
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    useResponsive: function() {
        return useResponsive;
    },
    useBreakpoint: function() {
        return useBreakpoint;
    },
    useWindowSize: function() {
        return useWindowSize;
    },
    useOrientation: function() {
        return useOrientation;
    },
    default: function() {
        return _default;
    }
});
const _react = require("react");
function useResponsive(customBreakpoints) {
    const [state, setState] = (0, _react.useState)(()=>{
        // SSR-safe initial state
        if (typeof window === "undefined") {
            return {
                isMobile: false,
                isTablet: false,
                isDesktop: true,
                isLargeDesktop: false,
                width: 1024,
                height: 768,
                breakpoint: "lg",
                isPortrait: false,
                isLandscape: true,
                isTouchDevice: false,
                prefersReducedMotion: false,
                prefersHighContrast: false,
                prefersDarkMode: false
            };
        }
        // Calculate initial state based on current window dimensions
        const width = window.innerWidth;
        const height = window.innerHeight;
        const isMobile = width < 768;
        const isTablet = width >= 768 && width < 1024;
        const isDesktop = width >= 1024 && width < 1280;
        const isLargeDesktop = width >= 1280;
        const breakpoint = isMobile ? "sm" : isTablet ? "md" : isLargeDesktop ? "xl" : "lg";
        return {
            isMobile,
            isTablet,
            isDesktop,
            isLargeDesktop,
            width,
            height,
            breakpoint,
            isPortrait: height > width,
            isLandscape: width >= height,
            isTouchDevice: typeof navigator !== "undefined" ? navigator.maxTouchPoints > 0 : false,
            prefersReducedMotion: false,
            prefersHighContrast: false,
            prefersDarkMode: false
        };
    });
    const mediaQueries = (0, _react.useMemo)(()=>{
        if (typeof window === "undefined" || !window.matchMedia) {
            return null;
        }
        // Use custom breakpoints if provided, otherwise use defaults
        const breakpoints = customBreakpoints || {
            mobile: "(max-width: 767px)",
            tablet: "(min-width: 768px) and (max-width: 1023px)",
            desktop: "(min-width: 1024px)",
            xl: "(min-width: 1280px)"
        };
        try {
            return {
                mobile: window.matchMedia(breakpoints.mobile || "(max-width: 767px)"),
                tablet: window.matchMedia(breakpoints.tablet || "(min-width: 768px) and (max-width: 1023px)"),
                desktop: window.matchMedia(breakpoints.desktop || "(min-width: 1024px)"),
                xl: window.matchMedia(breakpoints.xl || "(min-width: 1280px)"),
                portrait: window.matchMedia("(orientation: portrait)"),
                landscape: window.matchMedia("(orientation: landscape)"),
                reducedMotion: window.matchMedia("(prefers-reduced-motion: reduce)"),
                highContrast: window.matchMedia("(prefers-contrast: high)"),
                darkMode: window.matchMedia("(prefers-color-scheme: dark)")
            };
        } catch (error) {
            // Handle invalid media query syntax
            console.warn("Invalid media query syntax:", error);
            return null;
        }
    }, [
        customBreakpoints
    ]);
    // PERFORMANCE FIX: Memoize updateState with useCallback to prevent recreating on every render
    const updateState = (0, _react.useCallback)(()=>{
        if (typeof window === "undefined") return;
        const width = window.innerWidth;
        const height = window.innerHeight;
        // Use window dimensions as fallback if matchMedia is not available
        let isMobile, isTablet, isDesktop, isLargeDesktop;
        if (mediaQueries) {
            isMobile = mediaQueries.mobile.matches;
            isTablet = mediaQueries.tablet.matches;
            isDesktop = mediaQueries.desktop.matches && !mediaQueries.xl.matches;
            isLargeDesktop = mediaQueries.xl.matches;
        } else {
            // Fallback to window dimensions
            isMobile = width < 768;
            isTablet = width >= 768 && width < 1024;
            isDesktop = width >= 1024 && width < 1280;
            isLargeDesktop = width >= 1280;
        }
        const breakpoint = isMobile ? "sm" : isTablet ? "md" : isLargeDesktop ? "xl" : "lg";
        setState({
            isMobile,
            isTablet,
            isDesktop,
            isLargeDesktop,
            width,
            height,
            breakpoint,
            isPortrait: mediaQueries ? mediaQueries.portrait.matches : height > width,
            isLandscape: mediaQueries ? mediaQueries.landscape.matches : width >= height,
            isTouchDevice: typeof navigator !== "undefined" ? navigator.maxTouchPoints > 0 : false,
            prefersReducedMotion: mediaQueries ? mediaQueries.reducedMotion.matches : false,
            prefersHighContrast: mediaQueries ? mediaQueries.highContrast.matches : false,
            prefersDarkMode: mediaQueries ? mediaQueries.darkMode.matches : false
        });
    }, [
        mediaQueries
    ]);
    (0, _react.useEffect)(()=>{
        // PERFORMANCE FIX: Debounce resize events with requestAnimationFrame
        let rafId = null;
        const debouncedUpdateState = ()=>{
            if (rafId !== null) {
                cancelAnimationFrame(rafId);
            }
            rafId = requestAnimationFrame(()=>{
                updateState();
                rafId = null;
            });
        };
        // Initial call
        updateState();
        // Add event listeners
        if (mediaQueries) {
            const queries = Object.values(mediaQueries);
            queries.forEach((query)=>{
                if (query && query.addEventListener) {
                    // Use updateState directly for media query changes (they're already specific)
                    query.addEventListener("change", updateState);
                }
            });
        }
        // PERFORMANCE FIX: Use debounced version for resize events (fires frequently)
        if (typeof window !== "undefined") {
            window.addEventListener("resize", debouncedUpdateState);
        }
        // Cleanup
        return ()=>{
            // Cancel any pending animation frame
            if (rafId !== null) {
                cancelAnimationFrame(rafId);
            }
            if (mediaQueries) {
                const queries = Object.values(mediaQueries);
                queries.forEach((query)=>{
                    if (query && query.removeEventListener) {
                        query.removeEventListener("change", updateState);
                    }
                });
            }
            if (typeof window !== "undefined") {
                window.removeEventListener("resize", debouncedUpdateState);
            }
        };
    }, [
        mediaQueries,
        updateState
    ]);
    return state;
}
function useBreakpoint(breakpoint) {
    const [matches, setMatches] = (0, _react.useState)(false);
    (0, _react.useEffect)(()=>{
        if (typeof window === "undefined") {
            return;
        }
        function updateMatches() {
            const width = window.innerWidth;
            // Handle both media query strings and breakpoint names
            if (breakpoint.includes("(")) {
                // It's a media query string
                if (window.matchMedia) {
                    const mediaQuery = window.matchMedia(breakpoint);
                    setMatches(mediaQuery.matches);
                }
            } else {
                // It's a breakpoint name, use width-based logic
                let result = false;
                switch(breakpoint){
                    case "sm":
                        result = width < 768;
                        break;
                    case "md":
                        result = width >= 768 && width < 1024;
                        break;
                    case "lg":
                        result = width >= 1024 && width < 1280;
                        break;
                    case "xl":
                        result = width >= 1280;
                        break;
                    default:
                        // For other strings, try as media query if matchMedia is available
                        if (window.matchMedia) {
                            const mediaQuery = window.matchMedia(breakpoint);
                            result = mediaQuery.matches;
                        }
                }
                setMatches(result);
            }
        }
        updateMatches();
        // Set up listeners
        if (breakpoint.includes("(") && window.matchMedia) {
            const mediaQuery = window.matchMedia(breakpoint);
            mediaQuery.addEventListener("change", updateMatches);
            window.addEventListener("resize", updateMatches);
            return ()=>{
                mediaQuery.removeEventListener("change", updateMatches);
                window.removeEventListener("resize", updateMatches);
            };
        } else {
            window.addEventListener("resize", updateMatches);
            return ()=>window.removeEventListener("resize", updateMatches);
        }
    }, [
        breakpoint
    ]);
    return matches;
}
function useWindowSize() {
    const [size, setSize] = (0, _react.useState)({
        width: typeof window !== "undefined" ? window.innerWidth : 0,
        height: typeof window !== "undefined" ? window.innerHeight : 0
    });
    (0, _react.useEffect)(()=>{
        let rafId = null;
        const handleResize = ()=>{
            if (rafId !== null) {
                cancelAnimationFrame(rafId);
            }
            rafId = requestAnimationFrame(()=>{
                setSize({
                    width: window.innerWidth,
                    height: window.innerHeight
                });
                rafId = null;
            });
        };
        handleResize();
        window.addEventListener("resize", handleResize);
        return ()=>{
            if (rafId !== null) {
                cancelAnimationFrame(rafId);
            }
            window.removeEventListener("resize", handleResize);
        };
    }, []);
    return size;
}
function useOrientation() {
    const [orientation, setOrientation] = (0, _react.useState)("portrait");
    (0, _react.useEffect)(()=>{
        function handleOrientationChange() {
            setOrientation(window.innerHeight > window.innerWidth ? "portrait" : "landscape");
        }
        handleOrientationChange();
        window.addEventListener("resize", handleOrientationChange);
        return ()=>window.removeEventListener("resize", handleOrientationChange);
    }, []);
    return orientation;
}
const _default = useResponsive;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hZW5hL0RldmVsb3Blci9lY2hvL2Zyb250ZW5kL3NyYy9ob29rcy91c2VSZXNwb25zaXZlLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmVzcG9uc2l2ZSBEZXNpZ24gSG9va1xuICogQGRlc2NyaXB0aW9uIEN1c3RvbSBob29rIGZvciBkZXRlY3Rpbmcgdmlld3BvcnQgc2l6ZSBhbmQgcmVzcG9uc2l2ZSBicmVha3BvaW50c1xuICogQHZlcnNpb24gMS4wLjBcbiAqL1xuXG4ndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNpdmVTdGF0ZSB7XG4gIGlzTW9iaWxlOiBib29sZWFuO1xuICBpc1RhYmxldDogYm9vbGVhbjtcbiAgaXNEZXNrdG9wOiBib29sZWFuO1xuICBpc0xhcmdlRGVza3RvcDogYm9vbGVhbjtcbiAgd2lkdGg6IG51bWJlcjtcbiAgaGVpZ2h0OiBudW1iZXI7XG4gIGJyZWFrcG9pbnQ6ICdzbScgfCAnbWQnIHwgJ2xnJyB8ICd4bCc7XG4gIGlzUG9ydHJhaXQ/OiBib29sZWFuO1xuICBpc0xhbmRzY2FwZT86IGJvb2xlYW47XG4gIGlzVG91Y2hEZXZpY2U/OiBib29sZWFuO1xuICBwcmVmZXJzUmVkdWNlZE1vdGlvbj86IGJvb2xlYW47XG4gIHByZWZlcnNIaWdoQ29udHJhc3Q/OiBib29sZWFuO1xuICBwcmVmZXJzRGFya01vZGU/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgQnJlYWtwb2ludENvbmZpZyB7XG4gIG1vYmlsZT86IHN0cmluZztcbiAgdGFibGV0Pzogc3RyaW5nO1xuICBkZXNrdG9wPzogc3RyaW5nO1xuICB4bD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBIb29rIHRvIGRldGVjdCBjdXJyZW50IHZpZXdwb3J0IHNpemUgYW5kIGJyZWFrcG9pbnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZXNwb25zaXZlKFxuICBjdXN0b21CcmVha3BvaW50cz86IEJyZWFrcG9pbnRDb25maWdcbik6IFJlc3BvbnNpdmVTdGF0ZSB7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGU8UmVzcG9uc2l2ZVN0YXRlPigoKSA9PiB7XG4gICAgLy8gU1NSLXNhZmUgaW5pdGlhbCBzdGF0ZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNNb2JpbGU6IGZhbHNlLFxuICAgICAgICBpc1RhYmxldDogZmFsc2UsXG4gICAgICAgIGlzRGVza3RvcDogdHJ1ZSxcbiAgICAgICAgaXNMYXJnZURlc2t0b3A6IGZhbHNlLFxuICAgICAgICB3aWR0aDogMTAyNCxcbiAgICAgICAgaGVpZ2h0OiA3NjgsXG4gICAgICAgIGJyZWFrcG9pbnQ6ICdsZycsXG4gICAgICAgIGlzUG9ydHJhaXQ6IGZhbHNlLFxuICAgICAgICBpc0xhbmRzY2FwZTogdHJ1ZSxcbiAgICAgICAgaXNUb3VjaERldmljZTogZmFsc2UsXG4gICAgICAgIHByZWZlcnNSZWR1Y2VkTW90aW9uOiBmYWxzZSxcbiAgICAgICAgcHJlZmVyc0hpZ2hDb250cmFzdDogZmFsc2UsXG4gICAgICAgIHByZWZlcnNEYXJrTW9kZTogZmFsc2UsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBpbml0aWFsIHN0YXRlIGJhc2VkIG9uIGN1cnJlbnQgd2luZG93IGRpbWVuc2lvbnNcbiAgICBjb25zdCB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICBjb25zdCBpc01vYmlsZSA9IHdpZHRoIDwgNzY4O1xuICAgIGNvbnN0IGlzVGFibGV0ID0gd2lkdGggPj0gNzY4ICYmIHdpZHRoIDwgMTAyNDtcbiAgICBjb25zdCBpc0Rlc2t0b3AgPSB3aWR0aCA+PSAxMDI0ICYmIHdpZHRoIDwgMTI4MDtcbiAgICBjb25zdCBpc0xhcmdlRGVza3RvcCA9IHdpZHRoID49IDEyODA7XG4gICAgY29uc3QgYnJlYWtwb2ludDogUmVzcG9uc2l2ZVN0YXRlWydicmVha3BvaW50J10gPSBpc01vYmlsZVxuICAgICAgPyAnc20nXG4gICAgICA6IGlzVGFibGV0XG4gICAgICAgID8gJ21kJ1xuICAgICAgICA6IGlzTGFyZ2VEZXNrdG9wXG4gICAgICAgICAgPyAneGwnXG4gICAgICAgICAgOiAnbGcnO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTW9iaWxlLFxuICAgICAgaXNUYWJsZXQsXG4gICAgICBpc0Rlc2t0b3AsXG4gICAgICBpc0xhcmdlRGVza3RvcCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgYnJlYWtwb2ludCxcbiAgICAgIGlzUG9ydHJhaXQ6IGhlaWdodCA+IHdpZHRoLFxuICAgICAgaXNMYW5kc2NhcGU6IHdpZHRoID49IGhlaWdodCxcbiAgICAgIGlzVG91Y2hEZXZpY2U6XG4gICAgICAgIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnID8gbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMCA6IGZhbHNlLFxuICAgICAgcHJlZmVyc1JlZHVjZWRNb3Rpb246IGZhbHNlLFxuICAgICAgcHJlZmVyc0hpZ2hDb250cmFzdDogZmFsc2UsXG4gICAgICBwcmVmZXJzRGFya01vZGU6IGZhbHNlLFxuICAgIH07XG4gIH0pO1xuXG4gIGNvbnN0IG1lZGlhUXVlcmllcyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhd2luZG93Lm1hdGNoTWVkaWEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFVzZSBjdXN0b20gYnJlYWtwb2ludHMgaWYgcHJvdmlkZWQsIG90aGVyd2lzZSB1c2UgZGVmYXVsdHNcbiAgICBjb25zdCBicmVha3BvaW50cyA9IGN1c3RvbUJyZWFrcG9pbnRzIHx8IHtcbiAgICAgIG1vYmlsZTogJyhtYXgtd2lkdGg6IDc2N3B4KScsXG4gICAgICB0YWJsZXQ6ICcobWluLXdpZHRoOiA3NjhweCkgYW5kIChtYXgtd2lkdGg6IDEwMjNweCknLFxuICAgICAgZGVza3RvcDogJyhtaW4td2lkdGg6IDEwMjRweCknLFxuICAgICAgeGw6ICcobWluLXdpZHRoOiAxMjgwcHgpJyxcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vYmlsZTogd2luZG93Lm1hdGNoTWVkaWEoYnJlYWtwb2ludHMubW9iaWxlIHx8ICcobWF4LXdpZHRoOiA3NjdweCknKSxcbiAgICAgICAgdGFibGV0OiB3aW5kb3cubWF0Y2hNZWRpYShcbiAgICAgICAgICBicmVha3BvaW50cy50YWJsZXQgfHwgJyhtaW4td2lkdGg6IDc2OHB4KSBhbmQgKG1heC13aWR0aDogMTAyM3B4KSdcbiAgICAgICAgKSxcbiAgICAgICAgZGVza3RvcDogd2luZG93Lm1hdGNoTWVkaWEoXG4gICAgICAgICAgYnJlYWtwb2ludHMuZGVza3RvcCB8fCAnKG1pbi13aWR0aDogMTAyNHB4KSdcbiAgICAgICAgKSxcbiAgICAgICAgeGw6IHdpbmRvdy5tYXRjaE1lZGlhKGJyZWFrcG9pbnRzLnhsIHx8ICcobWluLXdpZHRoOiAxMjgwcHgpJyksXG4gICAgICAgIHBvcnRyYWl0OiB3aW5kb3cubWF0Y2hNZWRpYSgnKG9yaWVudGF0aW9uOiBwb3J0cmFpdCknKSxcbiAgICAgICAgbGFuZHNjYXBlOiB3aW5kb3cubWF0Y2hNZWRpYSgnKG9yaWVudGF0aW9uOiBsYW5kc2NhcGUpJyksXG4gICAgICAgIHJlZHVjZWRNb3Rpb246IHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKScpLFxuICAgICAgICBoaWdoQ29udHJhc3Q6IHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1jb250cmFzdDogaGlnaCknKSxcbiAgICAgICAgZGFya01vZGU6IHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspJyksXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBIYW5kbGUgaW52YWxpZCBtZWRpYSBxdWVyeSBzeW50YXhcbiAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBtZWRpYSBxdWVyeSBzeW50YXg6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCBbY3VzdG9tQnJlYWtwb2ludHNdKTtcblxuICAvLyBQRVJGT1JNQU5DRSBGSVg6IE1lbW9pemUgdXBkYXRlU3RhdGUgd2l0aCB1c2VDYWxsYmFjayB0byBwcmV2ZW50IHJlY3JlYXRpbmcgb24gZXZlcnkgcmVuZGVyXG4gIGNvbnN0IHVwZGF0ZVN0YXRlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuXG4gICAgY29uc3Qgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAvLyBVc2Ugd2luZG93IGRpbWVuc2lvbnMgYXMgZmFsbGJhY2sgaWYgbWF0Y2hNZWRpYSBpcyBub3QgYXZhaWxhYmxlXG4gICAgbGV0IGlzTW9iaWxlLCBpc1RhYmxldCwgaXNEZXNrdG9wLCBpc0xhcmdlRGVza3RvcDtcblxuICAgIGlmIChtZWRpYVF1ZXJpZXMpIHtcbiAgICAgIGlzTW9iaWxlID0gbWVkaWFRdWVyaWVzLm1vYmlsZS5tYXRjaGVzO1xuICAgICAgaXNUYWJsZXQgPSBtZWRpYVF1ZXJpZXMudGFibGV0Lm1hdGNoZXM7XG4gICAgICBpc0Rlc2t0b3AgPSBtZWRpYVF1ZXJpZXMuZGVza3RvcC5tYXRjaGVzICYmICFtZWRpYVF1ZXJpZXMueGwubWF0Y2hlcztcbiAgICAgIGlzTGFyZ2VEZXNrdG9wID0gbWVkaWFRdWVyaWVzLnhsLm1hdGNoZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHRvIHdpbmRvdyBkaW1lbnNpb25zXG4gICAgICBpc01vYmlsZSA9IHdpZHRoIDwgNzY4O1xuICAgICAgaXNUYWJsZXQgPSB3aWR0aCA+PSA3NjggJiYgd2lkdGggPCAxMDI0O1xuICAgICAgaXNEZXNrdG9wID0gd2lkdGggPj0gMTAyNCAmJiB3aWR0aCA8IDEyODA7XG4gICAgICBpc0xhcmdlRGVza3RvcCA9IHdpZHRoID49IDEyODA7XG4gICAgfVxuXG4gICAgY29uc3QgYnJlYWtwb2ludDogUmVzcG9uc2l2ZVN0YXRlWydicmVha3BvaW50J10gPSBpc01vYmlsZVxuICAgICAgPyAnc20nXG4gICAgICA6IGlzVGFibGV0XG4gICAgICAgID8gJ21kJ1xuICAgICAgICA6IGlzTGFyZ2VEZXNrdG9wXG4gICAgICAgICAgPyAneGwnXG4gICAgICAgICAgOiAnbGcnO1xuXG4gICAgc2V0U3RhdGUoe1xuICAgICAgaXNNb2JpbGUsXG4gICAgICBpc1RhYmxldCxcbiAgICAgIGlzRGVza3RvcCxcbiAgICAgIGlzTGFyZ2VEZXNrdG9wLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBicmVha3BvaW50LFxuICAgICAgaXNQb3J0cmFpdDogbWVkaWFRdWVyaWVzID8gbWVkaWFRdWVyaWVzLnBvcnRyYWl0Lm1hdGNoZXMgOiBoZWlnaHQgPiB3aWR0aCxcbiAgICAgIGlzTGFuZHNjYXBlOiBtZWRpYVF1ZXJpZXNcbiAgICAgICAgPyBtZWRpYVF1ZXJpZXMubGFuZHNjYXBlLm1hdGNoZXNcbiAgICAgICAgOiB3aWR0aCA+PSBoZWlnaHQsXG4gICAgICBpc1RvdWNoRGV2aWNlOlxuICAgICAgICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDAgOiBmYWxzZSxcbiAgICAgIHByZWZlcnNSZWR1Y2VkTW90aW9uOiBtZWRpYVF1ZXJpZXNcbiAgICAgICAgPyBtZWRpYVF1ZXJpZXMucmVkdWNlZE1vdGlvbi5tYXRjaGVzXG4gICAgICAgIDogZmFsc2UsXG4gICAgICBwcmVmZXJzSGlnaENvbnRyYXN0OiBtZWRpYVF1ZXJpZXNcbiAgICAgICAgPyBtZWRpYVF1ZXJpZXMuaGlnaENvbnRyYXN0Lm1hdGNoZXNcbiAgICAgICAgOiBmYWxzZSxcbiAgICAgIHByZWZlcnNEYXJrTW9kZTogbWVkaWFRdWVyaWVzID8gbWVkaWFRdWVyaWVzLmRhcmtNb2RlLm1hdGNoZXMgOiBmYWxzZSxcbiAgICB9KTtcbiAgfSwgW21lZGlhUXVlcmllc10pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gUEVSRk9STUFOQ0UgRklYOiBEZWJvdW5jZSByZXNpemUgZXZlbnRzIHdpdGggcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgbGV0IHJhZklkOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgICBjb25zdCBkZWJvdW5jZWRVcGRhdGVTdGF0ZSA9ICgpID0+IHtcbiAgICAgIGlmIChyYWZJZCAhPT0gbnVsbCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZJZCk7XG4gICAgICB9XG4gICAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHVwZGF0ZVN0YXRlKCk7XG4gICAgICAgIHJhZklkID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBJbml0aWFsIGNhbGxcbiAgICB1cGRhdGVTdGF0ZSgpO1xuXG4gICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVyc1xuICAgIGlmIChtZWRpYVF1ZXJpZXMpIHtcbiAgICAgIGNvbnN0IHF1ZXJpZXMgPSBPYmplY3QudmFsdWVzKG1lZGlhUXVlcmllcyk7XG4gICAgICBxdWVyaWVzLmZvckVhY2goKHF1ZXJ5KSA9PiB7XG4gICAgICAgIGlmIChxdWVyeSAmJiBxdWVyeS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgLy8gVXNlIHVwZGF0ZVN0YXRlIGRpcmVjdGx5IGZvciBtZWRpYSBxdWVyeSBjaGFuZ2VzICh0aGV5J3JlIGFscmVhZHkgc3BlY2lmaWMpXG4gICAgICAgICAgcXVlcnkuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlU3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBQRVJGT1JNQU5DRSBGSVg6IFVzZSBkZWJvdW5jZWQgdmVyc2lvbiBmb3IgcmVzaXplIGV2ZW50cyAoZmlyZXMgZnJlcXVlbnRseSlcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBkZWJvdW5jZWRVcGRhdGVTdGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYW51cFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBDYW5jZWwgYW55IHBlbmRpbmcgYW5pbWF0aW9uIGZyYW1lXG4gICAgICBpZiAocmFmSWQgIT09IG51bGwpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWFRdWVyaWVzKSB7XG4gICAgICAgIGNvbnN0IHF1ZXJpZXMgPSBPYmplY3QudmFsdWVzKG1lZGlhUXVlcmllcyk7XG4gICAgICAgIHF1ZXJpZXMuZm9yRWFjaCgocXVlcnkpID0+IHtcbiAgICAgICAgICBpZiAocXVlcnkgJiYgcXVlcnkucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgcXVlcnkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlU3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGRlYm91bmNlZFVwZGF0ZVN0YXRlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbbWVkaWFRdWVyaWVzLCB1cGRhdGVTdGF0ZV0pO1xuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBIb29rIHRvIGNoZWNrIGlmIHZpZXdwb3J0IG1hdGNoZXMgc3BlY2lmaWMgYnJlYWtwb2ludFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQnJlYWtwb2ludChicmVha3BvaW50OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgW21hdGNoZXMsIHNldE1hdGNoZXNdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlTWF0Y2hlcygpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG5cbiAgICAgIC8vIEhhbmRsZSBib3RoIG1lZGlhIHF1ZXJ5IHN0cmluZ3MgYW5kIGJyZWFrcG9pbnQgbmFtZXNcbiAgICAgIGlmIChicmVha3BvaW50LmluY2x1ZGVzKCcoJykpIHtcbiAgICAgICAgLy8gSXQncyBhIG1lZGlhIHF1ZXJ5IHN0cmluZ1xuICAgICAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEpIHtcbiAgICAgICAgICBjb25zdCBtZWRpYVF1ZXJ5ID0gd2luZG93Lm1hdGNoTWVkaWEoYnJlYWtwb2ludCk7XG4gICAgICAgICAgc2V0TWF0Y2hlcyhtZWRpYVF1ZXJ5Lm1hdGNoZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJdCdzIGEgYnJlYWtwb2ludCBuYW1lLCB1c2Ugd2lkdGgtYmFzZWQgbG9naWNcbiAgICAgICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBzd2l0Y2ggKGJyZWFrcG9pbnQpIHtcbiAgICAgICAgICBjYXNlICdzbSc6XG4gICAgICAgICAgICByZXN1bHQgPSB3aWR0aCA8IDc2ODtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ21kJzpcbiAgICAgICAgICAgIHJlc3VsdCA9IHdpZHRoID49IDc2OCAmJiB3aWR0aCA8IDEwMjQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdsZyc6XG4gICAgICAgICAgICByZXN1bHQgPSB3aWR0aCA+PSAxMDI0ICYmIHdpZHRoIDwgMTI4MDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3hsJzpcbiAgICAgICAgICAgIHJlc3VsdCA9IHdpZHRoID49IDEyODA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gRm9yIG90aGVyIHN0cmluZ3MsIHRyeSBhcyBtZWRpYSBxdWVyeSBpZiBtYXRjaE1lZGlhIGlzIGF2YWlsYWJsZVxuICAgICAgICAgICAgaWYgKHdpbmRvdy5tYXRjaE1lZGlhKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG1lZGlhUXVlcnkgPSB3aW5kb3cubWF0Y2hNZWRpYShicmVha3BvaW50KTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gbWVkaWFRdWVyeS5tYXRjaGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldE1hdGNoZXMocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVNYXRjaGVzKCk7XG5cbiAgICAvLyBTZXQgdXAgbGlzdGVuZXJzXG4gICAgaWYgKGJyZWFrcG9pbnQuaW5jbHVkZXMoJygnKSAmJiB3aW5kb3cubWF0Y2hNZWRpYSkge1xuICAgICAgY29uc3QgbWVkaWFRdWVyeSA9IHdpbmRvdy5tYXRjaE1lZGlhKGJyZWFrcG9pbnQpO1xuICAgICAgbWVkaWFRdWVyeS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB1cGRhdGVNYXRjaGVzKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVNYXRjaGVzKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIG1lZGlhUXVlcnkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlTWF0Y2hlcyk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVNYXRjaGVzKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVNYXRjaGVzKTtcbiAgICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlTWF0Y2hlcyk7XG4gICAgfVxuICB9LCBbYnJlYWtwb2ludF0pO1xuXG4gIHJldHVybiBtYXRjaGVzO1xufVxuXG4vKipcbiAqIEhvb2sgZm9yIHdpbmRvdyBkaW1lbnNpb25zXG4gKiBQRVJGT1JNQU5DRSBGSVg6IERlYm91bmNlZCB3aXRoIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlV2luZG93U2l6ZSgpIHtcbiAgY29uc3QgW3NpemUsIHNldFNpemVdID0gdXNlU3RhdGUoe1xuICAgIHdpZHRoOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5pbm5lcldpZHRoIDogMCxcbiAgICBoZWlnaHQ6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmlubmVySGVpZ2h0IDogMCxcbiAgfSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgcmFmSWQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuXG4gICAgY29uc3QgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgaWYgKHJhZklkICE9PSBudWxsKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZklkKTtcbiAgICAgIH1cbiAgICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgc2V0U2l6ZSh7XG4gICAgICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmFmSWQgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGhhbmRsZVJlc2l6ZSgpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAocmFmSWQgIT09IG51bGwpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpO1xuICAgICAgfVxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiBzaXplO1xufVxuXG4vKipcbiAqIEhvb2sgZm9yIG9yaWVudGF0aW9uIGRldGVjdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlT3JpZW50YXRpb24oKSB7XG4gIGNvbnN0IFtvcmllbnRhdGlvbiwgc2V0T3JpZW50YXRpb25dID0gdXNlU3RhdGU8J3BvcnRyYWl0JyB8ICdsYW5kc2NhcGUnPihcbiAgICAncG9ydHJhaXQnXG4gICk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBmdW5jdGlvbiBoYW5kbGVPcmllbnRhdGlvbkNoYW5nZSgpIHtcbiAgICAgIHNldE9yaWVudGF0aW9uKFxuICAgICAgICB3aW5kb3cuaW5uZXJIZWlnaHQgPiB3aW5kb3cuaW5uZXJXaWR0aCA/ICdwb3J0cmFpdCcgOiAnbGFuZHNjYXBlJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBoYW5kbGVPcmllbnRhdGlvbkNoYW5nZSgpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVPcmllbnRhdGlvbkNoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVPcmllbnRhdGlvbkNoYW5nZSk7XG4gIH0sIFtdKTtcblxuICByZXR1cm4gb3JpZW50YXRpb247XG59XG5cbmV4cG9ydCBkZWZhdWx0IHVzZVJlc3BvbnNpdmU7XG4iXSwibmFtZXMiOlsidXNlUmVzcG9uc2l2ZSIsInVzZUJyZWFrcG9pbnQiLCJ1c2VXaW5kb3dTaXplIiwidXNlT3JpZW50YXRpb24iLCJjdXN0b21CcmVha3BvaW50cyIsInN0YXRlIiwic2V0U3RhdGUiLCJ1c2VTdGF0ZSIsIndpbmRvdyIsImlzTW9iaWxlIiwiaXNUYWJsZXQiLCJpc0Rlc2t0b3AiLCJpc0xhcmdlRGVza3RvcCIsIndpZHRoIiwiaGVpZ2h0IiwiYnJlYWtwb2ludCIsImlzUG9ydHJhaXQiLCJpc0xhbmRzY2FwZSIsImlzVG91Y2hEZXZpY2UiLCJwcmVmZXJzUmVkdWNlZE1vdGlvbiIsInByZWZlcnNIaWdoQ29udHJhc3QiLCJwcmVmZXJzRGFya01vZGUiLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJuYXZpZ2F0b3IiLCJtYXhUb3VjaFBvaW50cyIsIm1lZGlhUXVlcmllcyIsInVzZU1lbW8iLCJtYXRjaE1lZGlhIiwiYnJlYWtwb2ludHMiLCJtb2JpbGUiLCJ0YWJsZXQiLCJkZXNrdG9wIiwieGwiLCJwb3J0cmFpdCIsImxhbmRzY2FwZSIsInJlZHVjZWRNb3Rpb24iLCJoaWdoQ29udHJhc3QiLCJkYXJrTW9kZSIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJ1cGRhdGVTdGF0ZSIsInVzZUNhbGxiYWNrIiwibWF0Y2hlcyIsInVzZUVmZmVjdCIsInJhZklkIiwiZGVib3VuY2VkVXBkYXRlU3RhdGUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInF1ZXJpZXMiLCJPYmplY3QiLCJ2YWx1ZXMiLCJmb3JFYWNoIiwicXVlcnkiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNldE1hdGNoZXMiLCJ1cGRhdGVNYXRjaGVzIiwiaW5jbHVkZXMiLCJtZWRpYVF1ZXJ5IiwicmVzdWx0Iiwic2l6ZSIsInNldFNpemUiLCJoYW5kbGVSZXNpemUiLCJvcmllbnRhdGlvbiIsInNldE9yaWVudGF0aW9uIiwiaGFuZGxlT3JpZW50YXRpb25DaGFuZ2UiXSwibWFwcGluZ3MiOiJBQUFBOzs7O0NBSUMsR0FFRDs7Ozs7Ozs7Ozs7O0lBOEJnQkEsYUFBYTtlQUFiQTs7SUE4TUFDLGFBQWE7ZUFBYkE7O0lBcUVBQyxhQUFhO2VBQWJBOztJQXNDQUMsY0FBYztlQUFkQTs7SUFvQmhCLE9BQTZCO2VBQTdCOzs7dUJBelcwRDtBQTRCbkQsU0FBU0gsY0FDZEksaUJBQW9DO0lBRXBDLE1BQU0sQ0FBQ0MsT0FBT0MsU0FBUyxHQUFHQyxJQUFBQSxlQUFRLEVBQWtCO1FBQ2xELHlCQUF5QjtRQUN6QixJQUFJLE9BQU9DLFdBQVcsYUFBYTtZQUNqQyxPQUFPO2dCQUNMQyxVQUFVO2dCQUNWQyxVQUFVO2dCQUNWQyxXQUFXO2dCQUNYQyxnQkFBZ0I7Z0JBQ2hCQyxPQUFPO2dCQUNQQyxRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxZQUFZO2dCQUNaQyxhQUFhO2dCQUNiQyxlQUFlO2dCQUNmQyxzQkFBc0I7Z0JBQ3RCQyxxQkFBcUI7Z0JBQ3JCQyxpQkFBaUI7WUFDbkI7UUFDRjtRQUVBLDZEQUE2RDtRQUM3RCxNQUFNUixRQUFRTCxPQUFPYyxVQUFVO1FBQy9CLE1BQU1SLFNBQVNOLE9BQU9lLFdBQVc7UUFDakMsTUFBTWQsV0FBV0ksUUFBUTtRQUN6QixNQUFNSCxXQUFXRyxTQUFTLE9BQU9BLFFBQVE7UUFDekMsTUFBTUYsWUFBWUUsU0FBUyxRQUFRQSxRQUFRO1FBQzNDLE1BQU1ELGlCQUFpQkMsU0FBUztRQUNoQyxNQUFNRSxhQUE0Q04sV0FDOUMsT0FDQUMsV0FDRSxPQUNBRSxpQkFDRSxPQUNBO1FBRVIsT0FBTztZQUNMSDtZQUNBQztZQUNBQztZQUNBQztZQUNBQztZQUNBQztZQUNBQztZQUNBQyxZ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