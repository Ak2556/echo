da8e9283323628097bff8ba9db36c0bc
/**
 * OTPInput Component Tests
 * Comprehensive test suite for OTP input functionality
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _userevent = /*#__PURE__*/ _interop_require_default(require("@testing-library/user-event"));
const _OTPInput = /*#__PURE__*/ _interop_require_default(require("../OTPInput"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
describe("OTPInput", ()=>{
    const user = _userevent.default.setup();
    const mockOnComplete = jest.fn();
    const mockOnChange = jest.fn();
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    describe("Component Rendering", ()=>{
        it("renders correct number of input fields", ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            expect(inputs).toHaveLength(6);
        });
        it("renders with custom length", ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 4,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            expect(inputs).toHaveLength(4);
        });
        it("renders with proper structure", ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const container = _react1.screen.getAllByRole("textbox")[0].closest(".otp-input-container");
            expect(container).toBeInTheDocument();
        });
        it("shows loading state", ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete,
                loading: true
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            inputs.forEach((input)=>{
                expect(input).toBeDisabled();
            });
        });
        it("shows error state", ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete,
                error: "Invalid OTP"
            }));
            expect(_react1.screen.getByText("Invalid OTP")).toBeInTheDocument();
        });
    });
    describe("Input Behavior", ()=>{
        it("accepts only numeric input", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const firstInput = _react1.screen.getAllByRole("textbox")[0];
            await user.type(firstInput, "a");
            expect(firstInput).toHaveValue("");
            await user.type(firstInput, "1");
            expect(firstInput).toHaveValue("1");
        });
        it("moves to next input after entering digit", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            await user.type(inputs[0], "1");
            expect(inputs[1]).toHaveFocus();
        });
        it("moves to previous input on backspace", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            // Type in first input and move to second
            await user.type(inputs[0], "1");
            expect(inputs[1]).toHaveFocus();
            // Backspace should move back to first input
            await user.keyboard("{Backspace}");
            expect(inputs[0]).toHaveFocus();
        });
        it("replaces existing digit when typing", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const firstInput = _react1.screen.getAllByRole("textbox")[0];
            await user.type(firstInput, "1");
            expect(firstInput).toHaveValue("1");
            // Clear and type new digit
            await user.clear(firstInput);
            await user.type(firstInput, "2");
            expect(firstInput).toHaveValue("2");
        });
        it("handles arrow key navigation", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            inputs[0].focus();
            await user.keyboard("{ArrowRight}");
            expect(inputs[1]).toHaveFocus();
            await user.keyboard("{ArrowLeft}");
            expect(inputs[0]).toHaveFocus();
        });
        it("handles Home key to jump to first input", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            inputs[3].focus();
            expect(inputs[3]).toHaveFocus();
            await user.keyboard("{Home}");
            expect(inputs[0]).toHaveFocus();
        });
        it("handles End key to jump to last input", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            inputs[2].focus();
            expect(inputs[2]).toHaveFocus();
            await user.keyboard("{End}");
            expect(inputs[5]).toHaveFocus();
        });
        it("handles backspace on filled input to clear it", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            // Fill first input
            await user.type(inputs[0], "1");
            expect(inputs[0]).toHaveValue("1");
            // Go back to first input
            inputs[0].focus();
            // Backspace should clear current input
            await user.keyboard("{Backspace}");
            expect(inputs[0]).toHaveValue("");
        });
        it("handles multi-character input from rapid typing", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            // Start from middle input
            inputs[2].focus();
            // Simulate rapid multi-character input
            _react1.fireEvent.change(inputs[2], {
                target: {
                    value: "345"
                }
            });
            await (0, _react1.waitFor)(()=>{
                expect(inputs[2]).toHaveValue("3");
                expect(inputs[3]).toHaveValue("4");
                expect(inputs[4]).toHaveValue("5");
            });
        });
    });
    describe("Paste Functionality", ()=>{
        it("handles paste of complete OTP", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const firstInput = _react1.screen.getAllByRole("textbox")[0];
            firstInput.focus();
            // Simulate paste event
            const pasteEvent = new ClipboardEvent("paste", {
                clipboardData: new DataTransfer()
            });
            pasteEvent.clipboardData?.setData("text/plain", "123456");
            _react1.fireEvent.paste(firstInput, pasteEvent);
            await (0, _react1.waitFor)(()=>{
                expect(mockOnComplete).toHaveBeenCalledWith("123456");
            });
        });
        it("handles paste of partial OTP", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const firstInput = _react1.screen.getAllByRole("textbox")[0];
            firstInput.focus();
            const pasteEvent = new ClipboardEvent("paste", {
                clipboardData: new DataTransfer()
            });
            pasteEvent.clipboardData?.setData("text/plain", "123");
            _react1.fireEvent.paste(firstInput, pasteEvent);
            await (0, _react1.waitFor)(()=>{
                const inputs = _react1.screen.getAllByRole("textbox");
                expect(inputs[0]).toHaveValue("1");
                expect(inputs[1]).toHaveValue("2");
                expect(inputs[2]).toHaveValue("3");
                expect(inputs[2]).toHaveFocus();
            });
        });
        it("ignores non-numeric paste content", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const firstInput = _react1.screen.getAllByRole("textbox")[0];
            firstInput.focus();
            const pasteEvent = new ClipboardEvent("paste", {
                clipboardData: new DataTransfer()
            });
            pasteEvent.clipboardData?.setData("text/plain", "abc123");
            _react1.fireEvent.paste(firstInput, pasteEvent);
            // Should not fill any inputs with invalid characters
            const inputs = _react1.screen.getAllByRole("textbox");
            inputs.forEach((input)=>{
                expect(input).toHaveValue("");
            });
        });
        it("handles paste longer than input length", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 4,
                onComplete: mockOnComplete
            }));
            const firstInput = _react1.screen.getAllByRole("textbox")[0];
            firstInput.focus();
            const pasteEvent = new ClipboardEvent("paste", {
                clipboardData: new DataTransfer()
            });
            pasteEvent.clipboardData?.setData("text/plain", "123456789");
            _react1.fireEvent.paste(firstInput, pasteEvent);
            await (0, _react1.waitFor)(()=>{
                expect(mockOnComplete).toHaveBeenCalledWith("1234");
            });
        });
    });
    describe("Completion Handling", ()=>{
        it("calls onComplete when all fields are filled", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 4,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            await user.type(inputs[0], "1");
            await user.type(inputs[1], "2");
            await user.type(inputs[2], "3");
            await user.type(inputs[3], "4");
            expect(mockOnComplete).toHaveBeenCalledWith("1234");
        });
        it("updates internal state on input change", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 4,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            await user.type(inputs[0], "1");
            expect(inputs[0]).toHaveValue("1");
            await user.type(inputs[1], "2");
            expect(inputs[1]).toHaveValue("2");
        });
        it("does not call onComplete for incomplete OTP", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            await user.type(inputs[0], "1");
            await user.type(inputs[1], "2");
            await user.type(inputs[2], "3");
            expect(mockOnComplete).not.toHaveBeenCalled();
        });
    });
    describe("Component State Management", ()=>{
        it("maintains internal state correctly", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            await user.type(inputs[0], "1");
            await user.type(inputs[1], "2");
            await user.type(inputs[2], "3");
            expect(inputs[0]).toHaveValue("1");
            expect(inputs[1]).toHaveValue("2");
            expect(inputs[2]).toHaveValue("3");
        });
        it("resets state when component remounts", ()=>{
            const { unmount } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            unmount();
            // Render a new instance
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            inputs.forEach((input)=>{
                expect(input).toHaveValue("");
            });
        });
    });
    describe("Accessibility", ()=>{
        it("has proper ARIA attributes", ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            inputs.forEach((input, index)=>{
                expect(input).toHaveAttribute("aria-label", `Digit ${index + 1} of 6`);
                expect(input).toHaveAttribute("inputMode", "numeric");
            });
        });
        it("supports screen readers with live region", ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const liveRegion = _react1.screen.getByRole("status");
            expect(liveRegion).toHaveAttribute("aria-live", "polite");
            expect(liveRegion).toHaveAttribute("aria-atomic", "true");
        });
        it("announces errors to screen readers", ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete,
                error: "Invalid OTP"
            }));
            const errorElement = _react1.screen.getByText("Invalid OTP");
            expect(errorElement).toHaveAttribute("role", "alert");
        });
    });
    describe("Security", ()=>{
        it("does not expose OTP in DOM attributes", ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            inputs.forEach((input)=>{
                expect(input).not.toHaveAttribute("data-value");
                expect(input).not.toHaveAttribute("title");
            });
        });
        it("uses proper input mode for numeric input", ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            inputs.forEach((input)=>{
                expect(input).toHaveAttribute("inputMode", "numeric");
                expect(input).toHaveAttribute("maxLength", "1");
            });
        });
    });
    describe("Edge Cases", ()=>{
        it("handles rapid typing", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            // Type rapidly in sequence
            await user.type(inputs[0], "123456");
            await (0, _react1.waitFor)(()=>{
                expect(mockOnComplete).toHaveBeenCalledWith("123456");
            });
        });
        it("handles focus events correctly", async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            // Focus on middle input
            inputs[2].focus();
            expect(inputs[2]).toHaveFocus();
            // Type should work from any focused input
            await user.type(inputs[2], "5");
            expect(inputs[2]).toHaveValue("5");
        });
        it("handles loading state correctly", ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete,
                loading: true
            }));
            const inputs = _react1.screen.getAllByRole("textbox");
            inputs.forEach((input)=>{
                expect(input).toBeDisabled();
            });
            expect(_react1.screen.getByText("Verifying...")).toBeInTheDocument();
        });
        it("handles error state correctly", ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete,
                error: "Invalid code"
            }));
            expect(_react1.screen.getByText("Invalid code")).toBeInTheDocument();
            expect(_react1.screen.getByRole("alert")).toBeInTheDocument();
        });
    });
    describe("Performance", ()=>{
        it("does not cause unnecessary re-renders", ()=>{
            const renderSpy = jest.fn();
            const TestComponent = ()=>{
                renderSpy();
                return /*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                });
            };
            const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            expect(renderSpy).toHaveBeenCalledTimes(1);
            // Re-render with same props
            rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            // Should not cause additional renders due to memoization
            expect(renderSpy).toHaveBeenCalledTimes(2);
        });
    });
    describe("Production Error Scenarios", ()=>{
        describe("Network and API Failures", ()=>{
            it("calls onComplete callback when code is complete", async ()=>{
                const successCallback = jest.fn();
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: successCallback
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                await user.type(inputs[0], "123456");
                await (0, _react1.waitFor)(()=>{
                    expect(successCallback).toHaveBeenCalledWith("123456");
                });
            });
            it("allows multiple callback invocations", async ()=>{
                const callback = jest.fn();
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 4,
                    onComplete: callback
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                // First code
                await user.type(inputs[0], "1234");
                await (0, _react1.waitFor)(()=>{
                    expect(callback).toHaveBeenCalledTimes(1);
                });
                // Clear and enter new code
                for(let i = 0; i < 4; i++){
                    await user.clear(inputs[i]);
                }
                await user.type(inputs[0], "5678");
                await (0, _react1.waitFor)(()=>{
                    expect(callback).toHaveBeenCalledTimes(2);
                });
            });
            it("passes correct code to callback", async ()=>{
                let receivedCode = "";
                const callback = jest.fn((code)=>{
                    receivedCode = code;
                });
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: callback
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                await user.type(inputs[0], "987654");
                await (0, _react1.waitFor)(()=>{
                    expect(receivedCode).toBe("987654");
                });
            });
        });
        describe("Memory and Resource Management", ()=>{
            it("cleans up event listeners on unmount", ()=>{
                const { unmount } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                // Component should unmount without errors
                expect(()=>unmount()).not.toThrow();
            });
            it("handles rapid component mount/unmount cycles", ()=>{
                for(let i = 0; i < 10; i++){
                    const { unmount } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                        length: 6,
                        onComplete: mockOnComplete
                    }));
                    unmount();
                }
                // Should not leak memory or throw errors
                expect(true).toBe(true);
            });
            it("handles extremely long OTP codes efficiently", ()=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 20,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                expect(inputs).toHaveLength(20);
                // Should render without performance issues
                expect(container).toBeInTheDocument();
            });
        });
        describe("Race Conditions and Timing Issues", ()=>{
            it("handles simultaneous input changes", async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                // Simulate rapid, simultaneous changes
                await user.type(inputs[0], "1");
                await user.type(inputs[1], "2");
                await user.type(inputs[2], "3");
                // Should handle gracefully - check that at least one input has a value
                const hasValues = inputs.some((input)=>input.getAttribute("value") !== "");
                expect(hasValues).toBe(true);
            });
            it("handles onChange during loading state", async ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    loading: false
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                await user.type(inputs[0], "1");
                // Switch to loading mid-input
                rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    loading: true
                }));
                // Inputs should be disabled
                const updatedInputs = _react1.screen.getAllByRole("textbox");
                updatedInputs.forEach((input)=>{
                    expect(input).toBeDisabled();
                });
            });
            it("handles onComplete being called multiple times for same code", async ()=>{
                const callback = jest.fn();
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 4,
                    onComplete: callback
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                await user.type(inputs[0], "1234");
                await (0, _react1.waitFor)(()=>{
                    expect(callback).toHaveBeenCalledTimes(1);
                });
                // Typing same code again
                await user.clear(inputs[0]);
                await user.type(inputs[0], "1234");
                // Should be called again
                expect(callback).toHaveBeenCalledTimes(2);
            });
            it("handles rapid error state changes", async ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    error: ""
                }));
                for(let i = 0; i < 10; i++){
                    rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                        length: 6,
                        onComplete: mockOnComplete,
                        error: `Error ${i}`
                    }));
                    await new Promise((resolve)=>setTimeout(resolve, 10));
                    rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                        length: 6,
                        onComplete: mockOnComplete,
                        error: ""
                    }));
                }
                // Should handle rapid changes without crashing
                expect(_react1.screen.getAllByRole("textbox")).toHaveLength(6);
            });
        });
        describe("Input Validation Edge Cases", ()=>{
            it("handles special Unicode digits", async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                // Try to input Unicode mathematical digits
                await user.type(inputs[0], "\uD835\uDFCF\uD835\uDFD0\uD835\uDFD1");
                // Should reject non-ASCII digits
                expect(inputs[0]).toHaveValue("");
            });
            it("handles mixed valid and invalid characters in paste", async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const firstInput = _react1.screen.getAllByRole("textbox")[0];
                firstInput.focus();
                const pasteEvent = new ClipboardEvent("paste", {
                    clipboardData: new DataTransfer()
                });
                pasteEvent.clipboardData?.setData("text/plain", "12abc34");
                _react1.fireEvent.paste(firstInput, pasteEvent);
                // Should reject entire paste due to invalid characters
                const inputs = _react1.screen.getAllByRole("textbox");
                inputs.forEach((input)=>{
                    expect(input).toHaveValue("");
                });
            });
            it("handles whitespace in pasted content", async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const firstInput = _react1.screen.getAllByRole("textbox")[0];
                firstInput.focus();
                const pasteEvent = new ClipboardEvent("paste", {
                    clipboardData: new DataTransfer()
                });
                pasteEvent.clipboardData?.setData("text/plain", "  123456  ");
                _react1.fireEvent.paste(firstInput, pasteEvent);
                await (0, _react1.waitFor)(()=>{
                    expect(mockOnComplete).toHaveBeenCalledWith("123456");
                });
            });
            it("handles newlines in pasted content", async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const firstInput = _react1.screen.getAllByRole("textbox")[0];
                firstInput.focus();
                const pasteEvent = new ClipboardEvent("paste", {
                    clipboardData: new DataTransfer()
                });
                pasteEvent.clipboardData?.setData("text/plain", "123\n456");
                _react1.fireEvent.paste(firstInput, pasteEvent);
                // Should reject due to newline
                const inputs = _react1.screen.getAllByRole("textbox");
                inputs.forEach((input)=>{
                    expect(input).toHaveValue("");
                });
            });
            it("handles zero-width characters", async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                // Try to input zero-width space
                await user.type(inputs[0], "1â€‹2");
                // Should only accept the digits
                expect(inputs[0]).toHaveValue("1");
            });
        });
        describe("Browser Compatibility Edge Cases", ()=>{
            it("handles missing clipboardData gracefully", ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const firstInput = _react1.screen.getAllByRole("textbox")[0];
                // Simulate old browser without clipboardData
                const pasteEvent = new Event("paste");
                (0, _react1.fireEvent)(firstInput, pasteEvent);
                // Should not crash
                expect(firstInput).toBeInTheDocument();
            });
            it("handles inputs without select method", async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                // Component should handle missing select method gracefully
                // This tests defensive programming for older browsers
                expect(inputs[0]).toBeInTheDocument();
                expect(typeof inputs[0].select).toBe("function");
            });
            it("handles focus on null refs gracefully", ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                // Component should handle null refs internally
                expect(_react1.screen.getAllByRole("textbox")).toHaveLength(6);
            });
        });
        describe("High Load Scenarios", ()=>{
            it("handles 1000+ rapid keystrokes", async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                // Simulate user mashing keys rapidly
                for(let i = 0; i < 1000; i++){
                    const randomInput = inputs[Math.floor(Math.random() * inputs.length)];
                    const randomKey = Math.floor(Math.random() * 10).toString();
                    _react1.fireEvent.change(randomInput, {
                        target: {
                            value: randomKey
                        }
                    });
                }
                // Should still be functional
                expect(inputs[0]).toBeInTheDocument();
            });
            it("handles continuous paste operations", async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const firstInput = _react1.screen.getAllByRole("textbox")[0];
                for(let i = 0; i < 100; i++){
                    const pasteEvent = new ClipboardEvent("paste", {
                        clipboardData: new DataTransfer()
                    });
                    pasteEvent.clipboardData?.setData("text/plain", `${100000 + i}`.slice(0, 6));
                    _react1.fireEvent.paste(firstInput, pasteEvent);
                }
                // Should handle without memory leaks
                expect(firstInput).toBeInTheDocument();
            });
            it("handles alternating focus between all inputs", async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                // Rapidly switch focus
                for(let i = 0; i < 100; i++){
                    inputs[i % 6].focus();
                }
                // Should handle gracefully
                expect(inputs.some((input)=>input === document.activeElement)).toBe(true);
            });
        });
        describe("Accessibility Under Stress", ()=>{
            it("maintains ARIA attributes during rapid state changes", async ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                for(let i = 0; i < 10; i++){
                    rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                        length: 6,
                        onComplete: mockOnComplete,
                        error: `Error ${i}`
                    }));
                    const inputs = _react1.screen.getAllByRole("textbox");
                    inputs.forEach((input, idx)=>{
                        expect(input).toHaveAttribute("aria-label", `Digit ${idx + 1} of 6`);
                        expect(input).toHaveAttribute("aria-invalid", "true");
                    });
                    rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                        length: 6,
                        onComplete: mockOnComplete,
                        error: ""
                    }));
                }
            });
            it("maintains live region updates during high activity", async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const liveRegion = _react1.screen.getByRole("status");
                const inputs = _react1.screen.getAllByRole("textbox");
                for(let i = 0; i < 6; i++){
                    await user.type(inputs[i], (i + 1).toString());
                    expect(liveRegion).toBeInTheDocument();
                }
            });
        });
        describe("Component Lifecycle Edge Cases", ()=>{
            it("handles length prop changing dynamically", ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 4,
                    onComplete: mockOnComplete
                }));
                expect(_react1.screen.getAllByRole("textbox")).toHaveLength(4);
                // Changing length prop creates a new component instance
                // The component doesn't dynamically resize, so this test documents the behavior
                rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 8,
                    onComplete: mockOnComplete
                }));
                // Component will still have 4 inputs as it doesn't re-initialize
                expect(_react1.screen.getAllByRole("textbox").length).toBeGreaterThan(0);
            });
            it("handles onComplete callback changing", async ()=>{
                const callback1 = jest.fn();
                const callback2 = jest.fn();
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 4,
                    onComplete: callback1
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                await user.type(inputs[0], "1234");
                await (0, _react1.waitFor)(()=>{
                    expect(callback1).toHaveBeenCalled();
                });
                // Change callback
                rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 4,
                    onComplete: callback2
                }));
                await user.clear(inputs[0]);
                await user.type(inputs[0], "5678");
                await (0, _react1.waitFor)(()=>{
                    expect(callback2).toHaveBeenCalled();
                });
            });
            it("handles parent component re-renders", ()=>{
                const ParentComponent = ({ count })=>/*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                        children: [
                            /*#__PURE__*/ (0, _jsxruntime.jsx)("span", {
                                children: count
                            }),
                            /*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                                length: 6,
                                onComplete: mockOnComplete
                            })
                        ]
                    });
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(ParentComponent, {
                    count: 0
                }));
                for(let i = 0; i < 100; i++){
                    rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(ParentComponent, {
                        count: i
                    }));
                }
                expect(_react1.screen.getAllByRole("textbox")).toHaveLength(6);
            });
        });
        describe("Error Recovery", ()=>{
            it("recovers from error state when user corrects input", async ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    error: "Invalid code"
                }));
                expect(_react1.screen.getByText("Invalid code")).toBeInTheDocument();
                rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    error: ""
                }));
                expect(_react1.screen.queryByText("Invalid code")).not.toBeInTheDocument();
            });
            it("allows re-entry after error", async ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    error: "Try again"
                }));
                rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    error: ""
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                await user.type(inputs[0], "123456");
                await (0, _react1.waitFor)(()=>{
                    expect(mockOnComplete).toHaveBeenCalledWith("123456");
                });
            });
            it("clears input when error is shown", async ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole("textbox");
                await user.type(inputs[0], "123");
                // Show error - simulating failed verification
                rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    error: "Invalid"
                }));
                // User should be able to clear and retry
                await user.clear(inputs[0]);
                await user.type(inputs[0], "456");
                expect(inputs[0]).toHaveValue("4");
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hZW5hL0RldmVsb3Blci9lY2hvL2Zyb250ZW5kL3NyYy9jb21wb25lbnRzL2F1dGgvX190ZXN0c19fL09UUElucHV0LnRlc3QudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogT1RQSW5wdXQgQ29tcG9uZW50IFRlc3RzXG4gKiBDb21wcmVoZW5zaXZlIHRlc3Qgc3VpdGUgZm9yIE9UUCBpbnB1dCBmdW5jdGlvbmFsaXR5XG4gKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHJlbmRlciwgc2NyZWVuLCBmaXJlRXZlbnQsIHdhaXRGb3IgfSBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3JlYWN0JztcbmltcG9ydCB1c2VyRXZlbnQgZnJvbSAnQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50JztcbmltcG9ydCBPVFBJbnB1dCBmcm9tICdAL2NvbXBvbmVudHMvYXV0aC9PVFBJbnB1dCc7XG5cbmRlc2NyaWJlKCdPVFBJbnB1dCcsICgpID0+IHtcbiAgY29uc3QgdXNlciA9IHVzZXJFdmVudC5zZXR1cCgpO1xuICBjb25zdCBtb2NrT25Db21wbGV0ZSA9IGplc3QuZm4oKTtcbiAgY29uc3QgbW9ja09uQ2hhbmdlID0gamVzdC5mbigpO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ29tcG9uZW50IFJlbmRlcmluZycsICgpID0+IHtcbiAgICBpdCgncmVuZGVycyBjb3JyZWN0IG51bWJlciBvZiBpbnB1dCBmaWVsZHMnLCAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuICAgICAgZXhwZWN0KGlucHV0cykudG9IYXZlTGVuZ3RoKDYpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3JlbmRlcnMgd2l0aCBjdXN0b20gbGVuZ3RoJywgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezR9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcbiAgICAgIGV4cGVjdChpbnB1dHMpLnRvSGF2ZUxlbmd0aCg0KTtcbiAgICB9KTtcblxuICAgIGl0KCdyZW5kZXJzIHdpdGggcHJvcGVyIHN0cnVjdHVyZScsICgpID0+IHtcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuXG4gICAgICBjb25zdCBjb250YWluZXIgPSBzY3JlZW5cbiAgICAgICAgLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpWzBdXG4gICAgICAgIC5jbG9zZXN0KCcub3RwLWlucHV0LWNvbnRhaW5lcicpO1xuICAgICAgZXhwZWN0KGNvbnRhaW5lcikudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG93cyBsb2FkaW5nIHN0YXRlJywgKCkgPT4ge1xuICAgICAgcmVuZGVyKFxuICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gbG9hZGluZz17dHJ1ZX0gLz5cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcbiAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgICBleHBlY3QoaW5wdXQpLnRvQmVEaXNhYmxlZCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvd3MgZXJyb3Igc3RhdGUnLCAoKSA9PiB7XG4gICAgICByZW5kZXIoXG4gICAgICAgIDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSBlcnJvcj1cIkludmFsaWQgT1RQXCIgLz5cbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdJbnZhbGlkIE9UUCcpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnSW5wdXQgQmVoYXZpb3InLCAoKSA9PiB7XG4gICAgaXQoJ2FjY2VwdHMgb25seSBudW1lcmljIGlucHV0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGZpcnN0SW5wdXQgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94JylbMF07XG5cbiAgICAgIGF3YWl0IHVzZXIudHlwZShmaXJzdElucHV0LCAnYScpO1xuICAgICAgZXhwZWN0KGZpcnN0SW5wdXQpLnRvSGF2ZVZhbHVlKCcnKTtcblxuICAgICAgYXdhaXQgdXNlci50eXBlKGZpcnN0SW5wdXQsICcxJyk7XG4gICAgICBleHBlY3QoZmlyc3RJbnB1dCkudG9IYXZlVmFsdWUoJzEnKTtcbiAgICB9KTtcblxuICAgIGl0KCdtb3ZlcyB0byBuZXh0IGlucHV0IGFmdGVyIGVudGVyaW5nIGRpZ2l0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcblxuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzEnKTtcbiAgICAgIGV4cGVjdChpbnB1dHNbMV0pLnRvSGF2ZUZvY3VzKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnbW92ZXMgdG8gcHJldmlvdXMgaW5wdXQgb24gYmFja3NwYWNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcblxuICAgICAgLy8gVHlwZSBpbiBmaXJzdCBpbnB1dCBhbmQgbW92ZSB0byBzZWNvbmRcbiAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMF0sICcxJyk7XG4gICAgICBleHBlY3QoaW5wdXRzWzFdKS50b0hhdmVGb2N1cygpO1xuXG4gICAgICAvLyBCYWNrc3BhY2Ugc2hvdWxkIG1vdmUgYmFjayB0byBmaXJzdCBpbnB1dFxuICAgICAgYXdhaXQgdXNlci5rZXlib2FyZCgne0JhY2tzcGFjZX0nKTtcbiAgICAgIGV4cGVjdChpbnB1dHNbMF0pLnRvSGF2ZUZvY3VzKCk7XG4gICAgfSk7XG5cbiAgICBpdCgncmVwbGFjZXMgZXhpc3RpbmcgZGlnaXQgd2hlbiB0eXBpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgZmlyc3RJbnB1dCA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKVswXTtcblxuICAgICAgYXdhaXQgdXNlci50eXBlKGZpcnN0SW5wdXQsICcxJyk7XG4gICAgICBleHBlY3QoZmlyc3RJbnB1dCkudG9IYXZlVmFsdWUoJzEnKTtcblxuICAgICAgLy8gQ2xlYXIgYW5kIHR5cGUgbmV3IGRpZ2l0XG4gICAgICBhd2FpdCB1c2VyLmNsZWFyKGZpcnN0SW5wdXQpO1xuICAgICAgYXdhaXQgdXNlci50eXBlKGZpcnN0SW5wdXQsICcyJyk7XG4gICAgICBleHBlY3QoZmlyc3RJbnB1dCkudG9IYXZlVmFsdWUoJzInKTtcbiAgICB9KTtcblxuICAgIGl0KCdoYW5kbGVzIGFycm93IGtleSBuYXZpZ2F0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcblxuICAgICAgaW5wdXRzWzBdLmZvY3VzKCk7XG5cbiAgICAgIGF3YWl0IHVzZXIua2V5Ym9hcmQoJ3tBcnJvd1JpZ2h0fScpO1xuICAgICAgZXhwZWN0KGlucHV0c1sxXSkudG9IYXZlRm9jdXMoKTtcblxuICAgICAgYXdhaXQgdXNlci5rZXlib2FyZCgne0Fycm93TGVmdH0nKTtcbiAgICAgIGV4cGVjdChpbnB1dHNbMF0pLnRvSGF2ZUZvY3VzKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyBIb21lIGtleSB0byBqdW1wIHRvIGZpcnN0IGlucHV0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcblxuICAgICAgaW5wdXRzWzNdLmZvY3VzKCk7XG4gICAgICBleHBlY3QoaW5wdXRzWzNdKS50b0hhdmVGb2N1cygpO1xuXG4gICAgICBhd2FpdCB1c2VyLmtleWJvYXJkKCd7SG9tZX0nKTtcbiAgICAgIGV4cGVjdChpbnB1dHNbMF0pLnRvSGF2ZUZvY3VzKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyBFbmQga2V5IHRvIGp1bXAgdG8gbGFzdCBpbnB1dCcsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuXG4gICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgIGlucHV0c1syXS5mb2N1cygpO1xuICAgICAgZXhwZWN0KGlucHV0c1syXSkudG9IYXZlRm9jdXMoKTtcblxuICAgICAgYXdhaXQgdXNlci5rZXlib2FyZCgne0VuZH0nKTtcbiAgICAgIGV4cGVjdChpbnB1dHNbNV0pLnRvSGF2ZUZvY3VzKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyBiYWNrc3BhY2Ugb24gZmlsbGVkIGlucHV0IHRvIGNsZWFyIGl0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcblxuICAgICAgLy8gRmlsbCBmaXJzdCBpbnB1dFxuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzEnKTtcbiAgICAgIGV4cGVjdChpbnB1dHNbMF0pLnRvSGF2ZVZhbHVlKCcxJyk7XG5cbiAgICAgIC8vIEdvIGJhY2sgdG8gZmlyc3QgaW5wdXRcbiAgICAgIGlucHV0c1swXS5mb2N1cygpO1xuXG4gICAgICAvLyBCYWNrc3BhY2Ugc2hvdWxkIGNsZWFyIGN1cnJlbnQgaW5wdXRcbiAgICAgIGF3YWl0IHVzZXIua2V5Ym9hcmQoJ3tCYWNrc3BhY2V9Jyk7XG4gICAgICBleHBlY3QoaW5wdXRzWzBdKS50b0hhdmVWYWx1ZSgnJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyBtdWx0aS1jaGFyYWN0ZXIgaW5wdXQgZnJvbSByYXBpZCB0eXBpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICAvLyBTdGFydCBmcm9tIG1pZGRsZSBpbnB1dFxuICAgICAgaW5wdXRzWzJdLmZvY3VzKCk7XG5cbiAgICAgIC8vIFNpbXVsYXRlIHJhcGlkIG11bHRpLWNoYXJhY3RlciBpbnB1dFxuICAgICAgZmlyZUV2ZW50LmNoYW5nZShpbnB1dHNbMl0sIHsgdGFyZ2V0OiB7IHZhbHVlOiAnMzQ1JyB9IH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KGlucHV0c1syXSkudG9IYXZlVmFsdWUoJzMnKTtcbiAgICAgICAgZXhwZWN0KGlucHV0c1szXSkudG9IYXZlVmFsdWUoJzQnKTtcbiAgICAgICAgZXhwZWN0KGlucHV0c1s0XSkudG9IYXZlVmFsdWUoJzUnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUGFzdGUgRnVuY3Rpb25hbGl0eScsICgpID0+IHtcbiAgICBpdCgnaGFuZGxlcyBwYXN0ZSBvZiBjb21wbGV0ZSBPVFAnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgZmlyc3RJbnB1dCA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKVswXTtcbiAgICAgIGZpcnN0SW5wdXQuZm9jdXMoKTtcblxuICAgICAgLy8gU2ltdWxhdGUgcGFzdGUgZXZlbnRcbiAgICAgIGNvbnN0IHBhc3RlRXZlbnQgPSBuZXcgQ2xpcGJvYXJkRXZlbnQoJ3Bhc3RlJywge1xuICAgICAgICBjbGlwYm9hcmREYXRhOiBuZXcgRGF0YVRyYW5zZmVyKCksXG4gICAgICB9KTtcbiAgICAgIHBhc3RlRXZlbnQuY2xpcGJvYXJkRGF0YT8uc2V0RGF0YSgndGV4dC9wbGFpbicsICcxMjM0NTYnKTtcblxuICAgICAgZmlyZUV2ZW50LnBhc3RlKGZpcnN0SW5wdXQsIHBhc3RlRXZlbnQpO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KG1vY2tPbkNvbXBsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnMTIzNDU2Jyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdoYW5kbGVzIHBhc3RlIG9mIHBhcnRpYWwgT1RQJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGZpcnN0SW5wdXQgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94JylbMF07XG4gICAgICBmaXJzdElucHV0LmZvY3VzKCk7XG5cbiAgICAgIGNvbnN0IHBhc3RlRXZlbnQgPSBuZXcgQ2xpcGJvYXJkRXZlbnQoJ3Bhc3RlJywge1xuICAgICAgICBjbGlwYm9hcmREYXRhOiBuZXcgRGF0YVRyYW5zZmVyKCksXG4gICAgICB9KTtcbiAgICAgIHBhc3RlRXZlbnQuY2xpcGJvYXJkRGF0YT8uc2V0RGF0YSgndGV4dC9wbGFpbicsICcxMjMnKTtcblxuICAgICAgZmlyZUV2ZW50LnBhc3RlKGZpcnN0SW5wdXQsIHBhc3RlRXZlbnQpO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuICAgICAgICBleHBlY3QoaW5wdXRzWzBdKS50b0hhdmVWYWx1ZSgnMScpO1xuICAgICAgICBleHBlY3QoaW5wdXRzWzFdKS50b0hhdmVWYWx1ZSgnMicpO1xuICAgICAgICBleHBlY3QoaW5wdXRzWzJdKS50b0hhdmVWYWx1ZSgnMycpO1xuICAgICAgICBleHBlY3QoaW5wdXRzWzJdKS50b0hhdmVGb2N1cygpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnaWdub3JlcyBub24tbnVtZXJpYyBwYXN0ZSBjb250ZW50JywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGZpcnN0SW5wdXQgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94JylbMF07XG4gICAgICBmaXJzdElucHV0LmZvY3VzKCk7XG5cbiAgICAgIGNvbnN0IHBhc3RlRXZlbnQgPSBuZXcgQ2xpcGJvYXJkRXZlbnQoJ3Bhc3RlJywge1xuICAgICAgICBjbGlwYm9hcmREYXRhOiBuZXcgRGF0YVRyYW5zZmVyKCksXG4gICAgICB9KTtcbiAgICAgIHBhc3RlRXZlbnQuY2xpcGJvYXJkRGF0YT8uc2V0RGF0YSgndGV4dC9wbGFpbicsICdhYmMxMjMnKTtcblxuICAgICAgZmlyZUV2ZW50LnBhc3RlKGZpcnN0SW5wdXQsIHBhc3RlRXZlbnQpO1xuXG4gICAgICAvLyBTaG91bGQgbm90IGZpbGwgYW55IGlucHV0cyB3aXRoIGludmFsaWQgY2hhcmFjdGVyc1xuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuICAgICAgaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICAgIGV4cGVjdChpbnB1dCkudG9IYXZlVmFsdWUoJycpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyBwYXN0ZSBsb25nZXIgdGhhbiBpbnB1dCBsZW5ndGgnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17NH0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgZmlyc3RJbnB1dCA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKVswXTtcbiAgICAgIGZpcnN0SW5wdXQuZm9jdXMoKTtcblxuICAgICAgY29uc3QgcGFzdGVFdmVudCA9IG5ldyBDbGlwYm9hcmRFdmVudCgncGFzdGUnLCB7XG4gICAgICAgIGNsaXBib2FyZERhdGE6IG5ldyBEYXRhVHJhbnNmZXIoKSxcbiAgICAgIH0pO1xuICAgICAgcGFzdGVFdmVudC5jbGlwYm9hcmREYXRhPy5zZXREYXRhKCd0ZXh0L3BsYWluJywgJzEyMzQ1Njc4OScpO1xuXG4gICAgICBmaXJlRXZlbnQucGFzdGUoZmlyc3RJbnB1dCwgcGFzdGVFdmVudCk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QobW9ja09uQ29tcGxldGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcxMjM0Jyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvbXBsZXRpb24gSGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ2NhbGxzIG9uQ29tcGxldGUgd2hlbiBhbGwgZmllbGRzIGFyZSBmaWxsZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17NH0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnMScpO1xuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1sxXSwgJzInKTtcbiAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMl0sICczJyk7XG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzNdLCAnNCcpO1xuXG4gICAgICBleHBlY3QobW9ja09uQ29tcGxldGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcxMjM0Jyk7XG4gICAgfSk7XG5cbiAgICBpdCgndXBkYXRlcyBpbnRlcm5hbCBzdGF0ZSBvbiBpbnB1dCBjaGFuZ2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17NH0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnMScpO1xuICAgICAgZXhwZWN0KGlucHV0c1swXSkudG9IYXZlVmFsdWUoJzEnKTtcblxuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1sxXSwgJzInKTtcbiAgICAgIGV4cGVjdChpbnB1dHNbMV0pLnRvSGF2ZVZhbHVlKCcyJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnZG9lcyBub3QgY2FsbCBvbkNvbXBsZXRlIGZvciBpbmNvbXBsZXRlIE9UUCcsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuXG4gICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMF0sICcxJyk7XG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzFdLCAnMicpO1xuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1syXSwgJzMnKTtcblxuICAgICAgZXhwZWN0KG1vY2tPbkNvbXBsZXRlKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ29tcG9uZW50IFN0YXRlIE1hbmFnZW1lbnQnLCAoKSA9PiB7XG4gICAgaXQoJ21haW50YWlucyBpbnRlcm5hbCBzdGF0ZSBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnMScpO1xuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1sxXSwgJzInKTtcbiAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMl0sICczJyk7XG5cbiAgICAgIGV4cGVjdChpbnB1dHNbMF0pLnRvSGF2ZVZhbHVlKCcxJyk7XG4gICAgICBleHBlY3QoaW5wdXRzWzFdKS50b0hhdmVWYWx1ZSgnMicpO1xuICAgICAgZXhwZWN0KGlucHV0c1syXSkudG9IYXZlVmFsdWUoJzMnKTtcbiAgICB9KTtcblxuICAgIGl0KCdyZXNldHMgc3RhdGUgd2hlbiBjb21wb25lbnQgcmVtb3VudHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHVubW91bnQgfSA9IHJlbmRlcihcbiAgICAgICAgPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+XG4gICAgICApO1xuXG4gICAgICB1bm1vdW50KCk7XG5cbiAgICAgIC8vIFJlbmRlciBhIG5ldyBpbnN0YW5jZVxuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcbiAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgICBleHBlY3QoaW5wdXQpLnRvSGF2ZVZhbHVlKCcnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQWNjZXNzaWJpbGl0eScsICgpID0+IHtcbiAgICBpdCgnaGFzIHByb3BlciBBUklBIGF0dHJpYnV0ZXMnLCAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuICAgICAgaW5wdXRzLmZvckVhY2goKGlucHV0LCBpbmRleCkgPT4ge1xuICAgICAgICBleHBlY3QoaW5wdXQpLnRvSGF2ZUF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGBEaWdpdCAke2luZGV4ICsgMX0gb2YgNmApO1xuICAgICAgICBleHBlY3QoaW5wdXQpLnRvSGF2ZUF0dHJpYnV0ZSgnaW5wdXRNb2RlJywgJ251bWVyaWMnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3N1cHBvcnRzIHNjcmVlbiByZWFkZXJzIHdpdGggbGl2ZSByZWdpb24nLCAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgbGl2ZVJlZ2lvbiA9IHNjcmVlbi5nZXRCeVJvbGUoJ3N0YXR1cycpO1xuICAgICAgZXhwZWN0KGxpdmVSZWdpb24pLnRvSGF2ZUF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ3BvbGl0ZScpO1xuICAgICAgZXhwZWN0KGxpdmVSZWdpb24pLnRvSGF2ZUF0dHJpYnV0ZSgnYXJpYS1hdG9taWMnLCAndHJ1ZScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2Fubm91bmNlcyBlcnJvcnMgdG8gc2NyZWVuIHJlYWRlcnMnLCAoKSA9PiB7XG4gICAgICByZW5kZXIoXG4gICAgICAgIDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSBlcnJvcj1cIkludmFsaWQgT1RQXCIgLz5cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGVycm9yRWxlbWVudCA9IHNjcmVlbi5nZXRCeVRleHQoJ0ludmFsaWQgT1RQJyk7XG4gICAgICBleHBlY3QoZXJyb3JFbGVtZW50KS50b0hhdmVBdHRyaWJ1dGUoJ3JvbGUnLCAnYWxlcnQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1NlY3VyaXR5JywgKCkgPT4ge1xuICAgIGl0KCdkb2VzIG5vdCBleHBvc2UgT1RQIGluIERPTSBhdHRyaWJ1dGVzJywgKCkgPT4ge1xuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcbiAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgICBleHBlY3QoaW5wdXQpLm5vdC50b0hhdmVBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnKTtcbiAgICAgICAgZXhwZWN0KGlucHV0KS5ub3QudG9IYXZlQXR0cmlidXRlKCd0aXRsZScpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgndXNlcyBwcm9wZXIgaW5wdXQgbW9kZSBmb3IgbnVtZXJpYyBpbnB1dCcsICgpID0+IHtcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuXG4gICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG4gICAgICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgICAgZXhwZWN0KGlucHV0KS50b0hhdmVBdHRyaWJ1dGUoJ2lucHV0TW9kZScsICdudW1lcmljJyk7XG4gICAgICAgIGV4cGVjdChpbnB1dCkudG9IYXZlQXR0cmlidXRlKCdtYXhMZW5ndGgnLCAnMScpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFZGdlIENhc2VzJywgKCkgPT4ge1xuICAgIGl0KCdoYW5kbGVzIHJhcGlkIHR5cGluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuXG4gICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgIC8vIFR5cGUgcmFwaWRseSBpbiBzZXF1ZW5jZVxuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzEyMzQ1NicpO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KG1vY2tPbkNvbXBsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnMTIzNDU2Jyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdoYW5kbGVzIGZvY3VzIGV2ZW50cyBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcblxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICAvLyBGb2N1cyBvbiBtaWRkbGUgaW5wdXRcbiAgICAgIGlucHV0c1syXS5mb2N1cygpO1xuICAgICAgZXhwZWN0KGlucHV0c1syXSkudG9IYXZlRm9jdXMoKTtcblxuICAgICAgLy8gVHlwZSBzaG91bGQgd29yayBmcm9tIGFueSBmb2N1c2VkIGlucHV0XG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzJdLCAnNScpO1xuICAgICAgZXhwZWN0KGlucHV0c1syXSkudG9IYXZlVmFsdWUoJzUnKTtcbiAgICB9KTtcblxuICAgIGl0KCdoYW5kbGVzIGxvYWRpbmcgc3RhdGUgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgcmVuZGVyKFxuICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gbG9hZGluZz17dHJ1ZX0gLz5cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcbiAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgICBleHBlY3QoaW5wdXQpLnRvQmVEaXNhYmxlZCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdWZXJpZnlpbmcuLi4nKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdoYW5kbGVzIGVycm9yIHN0YXRlIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIHJlbmRlcihcbiAgICAgICAgPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IGVycm9yPVwiSW52YWxpZCBjb2RlXCIgLz5cbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdJbnZhbGlkIGNvZGUnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlSb2xlKCdhbGVydCcpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgaXQoJ2RvZXMgbm90IGNhdXNlIHVubmVjZXNzYXJ5IHJlLXJlbmRlcnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCByZW5kZXJTcHkgPSBqZXN0LmZuKCk7XG5cbiAgICAgIGNvbnN0IFRlc3RDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICAgIHJlbmRlclNweSgpO1xuICAgICAgICByZXR1cm4gPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+O1xuICAgICAgfTtcblxuICAgICAgY29uc3QgeyByZXJlbmRlciB9ID0gcmVuZGVyKDxUZXN0Q29tcG9uZW50IC8+KTtcblxuICAgICAgZXhwZWN0KHJlbmRlclNweSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuXG4gICAgICAvLyBSZS1yZW5kZXIgd2l0aCBzYW1lIHByb3BzXG4gICAgICByZXJlbmRlcig8VGVzdENvbXBvbmVudCAvPik7XG5cbiAgICAgIC8vIFNob3VsZCBub3QgY2F1c2UgYWRkaXRpb25hbCByZW5kZXJzIGR1ZSB0byBtZW1vaXphdGlvblxuICAgICAgZXhwZWN0KHJlbmRlclNweSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUHJvZHVjdGlvbiBFcnJvciBTY2VuYXJpb3MnLCAoKSA9PiB7XG4gICAgZGVzY3JpYmUoJ05ldHdvcmsgYW5kIEFQSSBGYWlsdXJlcycsICgpID0+IHtcbiAgICAgIGl0KCdjYWxscyBvbkNvbXBsZXRlIGNhbGxiYWNrIHdoZW4gY29kZSBpcyBjb21wbGV0ZScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3Qgc3VjY2Vzc0NhbGxiYWNrID0gamVzdC5mbigpO1xuXG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXtzdWNjZXNzQ2FsbGJhY2t9IC8+KTtcbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMF0sICcxMjM0NTYnKTtcblxuICAgICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgICBleHBlY3Qoc3VjY2Vzc0NhbGxiYWNrKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnMTIzNDU2Jyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdhbGxvd3MgbXVsdGlwbGUgY2FsbGJhY2sgaW52b2NhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gamVzdC5mbigpO1xuXG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs0fSBvbkNvbXBsZXRlPXtjYWxsYmFja30gLz4pO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgICAgLy8gRmlyc3QgY29kZVxuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnMTIzNCcpO1xuXG4gICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChjYWxsYmFjaykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDbGVhciBhbmQgZW50ZXIgbmV3IGNvZGVcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICBhd2FpdCB1c2VyLmNsZWFyKGlucHV0c1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnNTY3OCcpO1xuXG4gICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChjYWxsYmFjaykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgncGFzc2VzIGNvcnJlY3QgY29kZSB0byBjYWxsYmFjaycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbGV0IHJlY2VpdmVkQ29kZSA9ICcnO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IGplc3QuZm4oKGNvZGU6IHN0cmluZykgPT4ge1xuICAgICAgICAgIHJlY2VpdmVkQ29kZSA9IGNvZGU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXtjYWxsYmFja30gLz4pO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzk4NzY1NCcpO1xuXG4gICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChyZWNlaXZlZENvZGUpLnRvQmUoJzk4NzY1NCcpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ01lbW9yeSBhbmQgUmVzb3VyY2UgTWFuYWdlbWVudCcsICgpID0+IHtcbiAgICAgIGl0KCdjbGVhbnMgdXAgZXZlbnQgbGlzdGVuZXJzIG9uIHVubW91bnQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdW5tb3VudCB9ID0gcmVuZGVyKFxuICAgICAgICAgIDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPlxuICAgICAgICApO1xuXG4gICAgICAgIC8vIENvbXBvbmVudCBzaG91bGQgdW5tb3VudCB3aXRob3V0IGVycm9yc1xuICAgICAgICBleHBlY3QoKCkgPT4gdW5tb3VudCgpKS5ub3QudG9UaHJvdygpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdoYW5kbGVzIHJhcGlkIGNvbXBvbmVudCBtb3VudC91bm1vdW50IGN5Y2xlcycsICgpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgeyB1bm1vdW50IH0gPSByZW5kZXIoXG4gICAgICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz5cbiAgICAgICAgICApO1xuICAgICAgICAgIHVubW91bnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNob3VsZCBub3QgbGVhayBtZW1vcnkgb3IgdGhyb3cgZXJyb3JzXG4gICAgICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdoYW5kbGVzIGV4dHJlbWVseSBsb25nIE9UUCBjb2RlcyBlZmZpY2llbnRseScsICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBjb250YWluZXIgfSA9IHJlbmRlcihcbiAgICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXsyMH0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+XG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuICAgICAgICBleHBlY3QoaW5wdXRzKS50b0hhdmVMZW5ndGgoMjApO1xuXG4gICAgICAgIC8vIFNob3VsZCByZW5kZXIgd2l0aG91dCBwZXJmb3JtYW5jZSBpc3N1ZXNcbiAgICAgICAgZXhwZWN0KGNvbnRhaW5lcikudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ1JhY2UgQ29uZGl0aW9ucyBhbmQgVGltaW5nIElzc3VlcycsICgpID0+IHtcbiAgICAgIGl0KCdoYW5kbGVzIHNpbXVsdGFuZW91cyBpbnB1dCBjaGFuZ2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICAgIC8vIFNpbXVsYXRlIHJhcGlkLCBzaW11bHRhbmVvdXMgY2hhbmdlc1xuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnMScpO1xuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzFdLCAnMicpO1xuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzJdLCAnMycpO1xuXG4gICAgICAgIC8vIFNob3VsZCBoYW5kbGUgZ3JhY2VmdWxseSAtIGNoZWNrIHRoYXQgYXQgbGVhc3Qgb25lIGlucHV0IGhhcyBhIHZhbHVlXG4gICAgICAgIGNvbnN0IGhhc1ZhbHVlcyA9IGlucHV0cy5zb21lKFxuICAgICAgICAgIChpbnB1dCkgPT4gaW5wdXQuZ2V0QXR0cmlidXRlKCd2YWx1ZScpICE9PSAnJ1xuICAgICAgICApO1xuICAgICAgICBleHBlY3QoaGFzVmFsdWVzKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdoYW5kbGVzIG9uQ2hhbmdlIGR1cmluZyBsb2FkaW5nIHN0YXRlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlcmVuZGVyIH0gPSByZW5kZXIoXG4gICAgICAgICAgPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IGxvYWRpbmc9e2ZhbHNlfSAvPlxuICAgICAgICApO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzEnKTtcblxuICAgICAgICAvLyBTd2l0Y2ggdG8gbG9hZGluZyBtaWQtaW5wdXRcbiAgICAgICAgcmVyZW5kZXIoXG4gICAgICAgICAgPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IGxvYWRpbmc9e3RydWV9IC8+XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gSW5wdXRzIHNob3VsZCBiZSBkaXNhYmxlZFxuICAgICAgICBjb25zdCB1cGRhdGVkSW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuICAgICAgICB1cGRhdGVkSW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICAgICAgZXhwZWN0KGlucHV0KS50b0JlRGlzYWJsZWQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ2hhbmRsZXMgb25Db21wbGV0ZSBiZWluZyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgZm9yIHNhbWUgY29kZScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBqZXN0LmZuKCk7XG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs0fSBvbkNvbXBsZXRlPXtjYWxsYmFja30gLz4pO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzEyMzQnKTtcblxuICAgICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgICBleHBlY3QoY2FsbGJhY2spLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVHlwaW5nIHNhbWUgY29kZSBhZ2FpblxuICAgICAgICBhd2FpdCB1c2VyLmNsZWFyKGlucHV0c1swXSk7XG4gICAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMF0sICcxMjM0Jyk7XG5cbiAgICAgICAgLy8gU2hvdWxkIGJlIGNhbGxlZCBhZ2FpblxuICAgICAgICBleHBlY3QoY2FsbGJhY2spLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygyKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnaGFuZGxlcyByYXBpZCBlcnJvciBzdGF0ZSBjaGFuZ2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlcmVuZGVyIH0gPSByZW5kZXIoXG4gICAgICAgICAgPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IGVycm9yPVwiXCIgLz5cbiAgICAgICAgKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgICByZXJlbmRlcihcbiAgICAgICAgICAgIDxPVFBJbnB1dFxuICAgICAgICAgICAgICBsZW5ndGg9ezZ9XG4gICAgICAgICAgICAgIG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfVxuICAgICAgICAgICAgICBlcnJvcj17YEVycm9yICR7aX1gfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApO1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwKSk7XG4gICAgICAgICAgcmVyZW5kZXIoXG4gICAgICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gZXJyb3I9XCJcIiAvPlxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaG91bGQgaGFuZGxlIHJhcGlkIGNoYW5nZXMgd2l0aG91dCBjcmFzaGluZ1xuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpKS50b0hhdmVMZW5ndGgoNik7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdJbnB1dCBWYWxpZGF0aW9uIEVkZ2UgQ2FzZXMnLCAoKSA9PiB7XG4gICAgICBpdCgnaGFuZGxlcyBzcGVjaWFsIFVuaWNvZGUgZGlnaXRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICAgIC8vIFRyeSB0byBpbnB1dCBVbmljb2RlIG1hdGhlbWF0aWNhbCBkaWdpdHNcbiAgICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJ/Cdn4/wnZ+Q8J2fkScpO1xuXG4gICAgICAgIC8vIFNob3VsZCByZWplY3Qgbm9uLUFTQ0lJIGRpZ2l0c1xuICAgICAgICBleHBlY3QoaW5wdXRzWzBdKS50b0hhdmVWYWx1ZSgnJyk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ2hhbmRsZXMgbWl4ZWQgdmFsaWQgYW5kIGludmFsaWQgY2hhcmFjdGVycyBpbiBwYXN0ZScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG4gICAgICAgIGNvbnN0IGZpcnN0SW5wdXQgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94JylbMF07XG4gICAgICAgIGZpcnN0SW5wdXQuZm9jdXMoKTtcblxuICAgICAgICBjb25zdCBwYXN0ZUV2ZW50ID0gbmV3IENsaXBib2FyZEV2ZW50KCdwYXN0ZScsIHtcbiAgICAgICAgICBjbGlwYm9hcmREYXRhOiBuZXcgRGF0YVRyYW5zZmVyKCksXG4gICAgICAgIH0pO1xuICAgICAgICBwYXN0ZUV2ZW50LmNsaXBib2FyZERhdGE/LnNldERhdGEoJ3RleHQvcGxhaW4nLCAnMTJhYmMzNCcpO1xuXG4gICAgICAgIGZpcmVFdmVudC5wYXN0ZShmaXJzdElucHV0LCBwYXN0ZUV2ZW50KTtcblxuICAgICAgICAvLyBTaG91bGQgcmVqZWN0IGVudGlyZSBwYXN0ZSBkdWUgdG8gaW52YWxpZCBjaGFyYWN0ZXJzXG4gICAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcbiAgICAgICAgaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICAgICAgZXhwZWN0KGlucHV0KS50b0hhdmVWYWx1ZSgnJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdoYW5kbGVzIHdoaXRlc3BhY2UgaW4gcGFzdGVkIGNvbnRlbnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuICAgICAgICBjb25zdCBmaXJzdElucHV0ID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpWzBdO1xuICAgICAgICBmaXJzdElucHV0LmZvY3VzKCk7XG5cbiAgICAgICAgY29uc3QgcGFzdGVFdmVudCA9IG5ldyBDbGlwYm9hcmRFdmVudCgncGFzdGUnLCB7XG4gICAgICAgICAgY2xpcGJvYXJkRGF0YTogbmV3IERhdGFUcmFuc2ZlcigpLFxuICAgICAgICB9KTtcbiAgICAgICAgcGFzdGVFdmVudC5jbGlwYm9hcmREYXRhPy5zZXREYXRhKCd0ZXh0L3BsYWluJywgJyAgMTIzNDU2ICAnKTtcblxuICAgICAgICBmaXJlRXZlbnQucGFzdGUoZmlyc3RJbnB1dCwgcGFzdGVFdmVudCk7XG5cbiAgICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgICAgZXhwZWN0KG1vY2tPbkNvbXBsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnMTIzNDU2Jyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdoYW5kbGVzIG5ld2xpbmVzIGluIHBhc3RlZCBjb250ZW50JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcbiAgICAgICAgY29uc3QgZmlyc3RJbnB1dCA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKVswXTtcbiAgICAgICAgZmlyc3RJbnB1dC5mb2N1cygpO1xuXG4gICAgICAgIGNvbnN0IHBhc3RlRXZlbnQgPSBuZXcgQ2xpcGJvYXJkRXZlbnQoJ3Bhc3RlJywge1xuICAgICAgICAgIGNsaXBib2FyZERhdGE6IG5ldyBEYXRhVHJhbnNmZXIoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHBhc3RlRXZlbnQuY2xpcGJvYXJkRGF0YT8uc2V0RGF0YSgndGV4dC9wbGFpbicsICcxMjNcXG40NTYnKTtcblxuICAgICAgICBmaXJlRXZlbnQucGFzdGUoZmlyc3RJbnB1dCwgcGFzdGVFdmVudCk7XG5cbiAgICAgICAgLy8gU2hvdWxkIHJlamVjdCBkdWUgdG8gbmV3bGluZVxuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG4gICAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChpbnB1dCkudG9IYXZlVmFsdWUoJycpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnaGFuZGxlcyB6ZXJvLXdpZHRoIGNoYXJhY3RlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgICAgLy8gVHJ5IHRvIGlucHV0IHplcm8td2lkdGggc3BhY2VcbiAgICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzFcXHUyMDBCMicpO1xuXG4gICAgICAgIC8vIFNob3VsZCBvbmx5IGFjY2VwdCB0aGUgZGlnaXRzXG4gICAgICAgIGV4cGVjdChpbnB1dHNbMF0pLnRvSGF2ZVZhbHVlKCcxJyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdCcm93c2VyIENvbXBhdGliaWxpdHkgRWRnZSBDYXNlcycsICgpID0+IHtcbiAgICAgIGl0KCdoYW5kbGVzIG1pc3NpbmcgY2xpcGJvYXJkRGF0YSBncmFjZWZ1bGx5JywgKCkgPT4ge1xuICAgICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcbiAgICAgICAgY29uc3QgZmlyc3RJbnB1dCA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKVswXTtcblxuICAgICAgICAvLyBTaW11bGF0ZSBvbGQgYnJvd3NlciB3aXRob3V0IGNsaXBib2FyZERhdGFcbiAgICAgICAgY29uc3QgcGFzdGVFdmVudCA9IG5ldyBFdmVudCgncGFzdGUnKSBhcyBhbnk7XG4gICAgICAgIGZpcmVFdmVudChmaXJzdElucHV0LCBwYXN0ZUV2ZW50KTtcblxuICAgICAgICAvLyBTaG91bGQgbm90IGNyYXNoXG4gICAgICAgIGV4cGVjdChmaXJzdElucHV0KS50b0JlSW5UaGVEb2N1bWVudCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdoYW5kbGVzIGlucHV0cyB3aXRob3V0IHNlbGVjdCBtZXRob2QnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XG5cbiAgICAgICAgLy8gQ29tcG9uZW50IHNob3VsZCBoYW5kbGUgbWlzc2luZyBzZWxlY3QgbWV0aG9kIGdyYWNlZnVsbHlcbiAgICAgICAgLy8gVGhpcyB0ZXN0cyBkZWZlbnNpdmUgcHJvZ3JhbW1pbmcgZm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGV4cGVjdChpbnB1dHNbMF0pLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICAgIGV4cGVjdCh0eXBlb2YgKGlucHV0c1swXSBhcyBIVE1MSW5wdXRFbGVtZW50KS5zZWxlY3QpLnRvQmUoJ2Z1bmN0aW9uJyk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ2hhbmRsZXMgZm9jdXMgb24gbnVsbCByZWZzIGdyYWNlZnVsbHknLCAoKSA9PiB7XG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuXG4gICAgICAgIC8vIENvbXBvbmVudCBzaG91bGQgaGFuZGxlIG51bGwgcmVmcyBpbnRlcm5hbGx5XG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94JykpLnRvSGF2ZUxlbmd0aCg2KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ0hpZ2ggTG9hZCBTY2VuYXJpb3MnLCAoKSA9PiB7XG4gICAgICBpdCgnaGFuZGxlcyAxMDAwKyByYXBpZCBrZXlzdHJva2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICAgIC8vIFNpbXVsYXRlIHVzZXIgbWFzaGluZyBrZXlzIHJhcGlkbHlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDAwOyBpKyspIHtcbiAgICAgICAgICBjb25zdCByYW5kb21JbnB1dCA9IGlucHV0c1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBpbnB1dHMubGVuZ3RoKV07XG4gICAgICAgICAgY29uc3QgcmFuZG9tS2V5ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTApLnRvU3RyaW5nKCk7XG4gICAgICAgICAgZmlyZUV2ZW50LmNoYW5nZShyYW5kb21JbnB1dCwgeyB0YXJnZXQ6IHsgdmFsdWU6IHJhbmRvbUtleSB9IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hvdWxkIHN0aWxsIGJlIGZ1bmN0aW9uYWxcbiAgICAgICAgZXhwZWN0KGlucHV0c1swXSkudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnaGFuZGxlcyBjb250aW51b3VzIHBhc3RlIG9wZXJhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuICAgICAgICBjb25zdCBmaXJzdElucHV0ID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpWzBdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBwYXN0ZUV2ZW50ID0gbmV3IENsaXBib2FyZEV2ZW50KCdwYXN0ZScsIHtcbiAgICAgICAgICAgIGNsaXBib2FyZERhdGE6IG5ldyBEYXRhVHJhbnNmZXIoKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwYXN0ZUV2ZW50LmNsaXBib2FyZERhdGE/LnNldERhdGEoXG4gICAgICAgICAgICAndGV4dC9wbGFpbicsXG4gICAgICAgICAgICBgJHsxMDAwMDAgKyBpfWAuc2xpY2UoMCwgNilcbiAgICAgICAgICApO1xuICAgICAgICAgIGZpcmVFdmVudC5wYXN0ZShmaXJzdElucHV0LCBwYXN0ZUV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNob3VsZCBoYW5kbGUgd2l0aG91dCBtZW1vcnkgbGVha3NcbiAgICAgICAgZXhwZWN0KGZpcnN0SW5wdXQpLnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ2hhbmRsZXMgYWx0ZXJuYXRpbmcgZm9jdXMgYmV0d2VlbiBhbGwgaW5wdXRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICAgIC8vIFJhcGlkbHkgc3dpdGNoIGZvY3VzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwOyBpKyspIHtcbiAgICAgICAgICBpbnB1dHNbaSAlIDZdLmZvY3VzKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaG91bGQgaGFuZGxlIGdyYWNlZnVsbHlcbiAgICAgICAgZXhwZWN0KGlucHV0cy5zb21lKChpbnB1dCkgPT4gaW5wdXQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKS50b0JlKFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ0FjY2Vzc2liaWxpdHkgVW5kZXIgU3RyZXNzJywgKCkgPT4ge1xuICAgICAgaXQoJ21haW50YWlucyBBUklBIGF0dHJpYnV0ZXMgZHVyaW5nIHJhcGlkIHN0YXRlIGNoYW5nZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVyZW5kZXIgfSA9IHJlbmRlcihcbiAgICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz5cbiAgICAgICAgKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgICByZXJlbmRlcihcbiAgICAgICAgICAgIDxPVFBJbnB1dFxuICAgICAgICAgICAgICBsZW5ndGg9ezZ9XG4gICAgICAgICAgICAgIG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfVxuICAgICAgICAgICAgICBlcnJvcj17YEVycm9yICR7aX1gfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApO1xuXG4gICAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuICAgICAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCwgaWR4KSA9PiB7XG4gICAgICAgICAgICBleHBlY3QoaW5wdXQpLnRvSGF2ZUF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgJ2FyaWEtbGFiZWwnLFxuICAgICAgICAgICAgICBgRGlnaXQgJHtpZHggKyAxfSBvZiA2YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGV4cGVjdChpbnB1dCkudG9IYXZlQXR0cmlidXRlKCdhcmlhLWludmFsaWQnLCAndHJ1ZScpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmVyZW5kZXIoXG4gICAgICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gZXJyb3I9XCJcIiAvPlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpdCgnbWFpbnRhaW5zIGxpdmUgcmVnaW9uIHVwZGF0ZXMgZHVyaW5nIGhpZ2ggYWN0aXZpdHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xuICAgICAgICBjb25zdCBsaXZlUmVnaW9uID0gc2NyZWVuLmdldEJ5Um9sZSgnc3RhdHVzJyk7XG5cbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1tpXSwgKGkgKyAxKS50b1N0cmluZygpKTtcbiAgICAgICAgICBleHBlY3QobGl2ZVJlZ2lvbikudG9CZUluVGhlRG9jdW1lbnQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnQ29tcG9uZW50IExpZmVjeWNsZSBFZGdlIENhc2VzJywgKCkgPT4ge1xuICAgICAgaXQoJ2hhbmRsZXMgbGVuZ3RoIHByb3AgY2hhbmdpbmcgZHluYW1pY2FsbHknLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVyZW5kZXIgfSA9IHJlbmRlcihcbiAgICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs0fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz5cbiAgICAgICAgKTtcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKSkudG9IYXZlTGVuZ3RoKDQpO1xuXG4gICAgICAgIC8vIENoYW5naW5nIGxlbmd0aCBwcm9wIGNyZWF0ZXMgYSBuZXcgY29tcG9uZW50IGluc3RhbmNlXG4gICAgICAgIC8vIFRoZSBjb21wb25lbnQgZG9lc24ndCBkeW5hbWljYWxseSByZXNpemUsIHNvIHRoaXMgdGVzdCBkb2N1bWVudHMgdGhlIGJlaGF2aW9yXG4gICAgICAgIHJlcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezh9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XG4gICAgICAgIC8vIENvbXBvbmVudCB3aWxsIHN0aWxsIGhhdmUgNCBpbnB1dHMgYXMgaXQgZG9lc24ndCByZS1pbml0aWFsaXplXG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94JykubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ2hhbmRsZXMgb25Db21wbGV0ZSBjYWxsYmFjayBjaGFuZ2luZycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sxID0gamVzdC5mbigpO1xuICAgICAgICBjb25zdCBjYWxsYmFjazIgPSBqZXN0LmZuKCk7XG5cbiAgICAgICAgY29uc3QgeyByZXJlbmRlciB9ID0gcmVuZGVyKFxuICAgICAgICAgIDxPVFBJbnB1dCBsZW5ndGg9ezR9IG9uQ29tcGxldGU9e2NhbGxiYWNrMX0gLz5cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMF0sICcxMjM0Jyk7XG5cbiAgICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgICAgZXhwZWN0KGNhbGxiYWNrMSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDaGFuZ2UgY2FsbGJhY2tcbiAgICAgICAgcmVyZW5kZXIoPE9UUElucHV0IGxlbmd0aD17NH0gb25Db21wbGV0ZT17Y2FsbGJhY2syfSAvPik7XG5cbiAgICAgICAgYXdhaXQgdXNlci5jbGVhcihpbnB1dHNbMF0pO1xuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnNTY3OCcpO1xuXG4gICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChjYWxsYmFjazIpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ2hhbmRsZXMgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBQYXJlbnRDb21wb25lbnQgPSAoeyBjb3VudCB9OiB7IGNvdW50OiBudW1iZXIgfSkgPT4gKFxuICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8c3Bhbj57Y291bnR9PC9zcGFuPlxuICAgICAgICAgICAgPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgeyByZXJlbmRlciB9ID0gcmVuZGVyKDxQYXJlbnRDb21wb25lbnQgY291bnQ9ezB9IC8+KTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDsgaSsrKSB7XG4gICAgICAgICAgcmVyZW5kZXIoPFBhcmVudENvbXBvbmVudCBjb3VudD17aX0gLz4pO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKSkudG9IYXZlTGVuZ3RoKDYpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnRXJyb3IgUmVjb3ZlcnknLCAoKSA9PiB7XG4gICAgICBpdCgncmVjb3ZlcnMgZnJvbSBlcnJvciBzdGF0ZSB3aGVuIHVzZXIgY29ycmVjdHMgaW5wdXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVyZW5kZXIgfSA9IHJlbmRlcihcbiAgICAgICAgICA8T1RQSW5wdXRcbiAgICAgICAgICAgIGxlbmd0aD17Nn1cbiAgICAgICAgICAgIG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfVxuICAgICAgICAgICAgZXJyb3I9XCJJbnZhbGlkIGNvZGVcIlxuICAgICAgICAgIC8+XG4gICAgICAgICk7XG5cbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ0ludmFsaWQgY29kZScpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xuXG4gICAgICAgIHJlcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSBlcnJvcj1cIlwiIC8+KTtcblxuICAgICAgICBleHBlY3Qoc2NyZWVuLnF1ZXJ5QnlUZXh0KCdJbnZhbGlkIGNvZGUnKSkubm90LnRvQmVJblRoZURvY3VtZW50KCk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ2FsbG93cyByZS1lbnRyeSBhZnRlciBlcnJvcicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgeyByZXJlbmRlciB9ID0gcmVuZGVyKFxuICAgICAgICAgIDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSBlcnJvcj1cIlRyeSBhZ2FpblwiIC8+XG4gICAgICAgICk7XG5cbiAgICAgICAgcmVyZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IGVycm9yPVwiXCIgLz4pO1xuXG4gICAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcbiAgICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzEyMzQ1NicpO1xuXG4gICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChtb2NrT25Db21wbGV0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJzEyMzQ1NicpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnY2xlYXJzIGlucHV0IHdoZW4gZXJyb3IgaXMgc2hvd24nLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVyZW5kZXIgfSA9IHJlbmRlcihcbiAgICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz5cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xuXG4gICAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMF0sICcxMjMnKTtcblxuICAgICAgICAvLyBTaG93IGVycm9yIC0gc2ltdWxhdGluZyBmYWlsZWQgdmVyaWZpY2F0aW9uXG4gICAgICAgIHJlcmVuZGVyKFxuICAgICAgICAgIDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSBlcnJvcj1cIkludmFsaWRcIiAvPlxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFVzZXIgc2hvdWxkIGJlIGFibGUgdG8gY2xlYXIgYW5kIHJldHJ5XG4gICAgICAgIGF3YWl0IHVzZXIuY2xlYXIoaW5wdXRzWzBdKTtcbiAgICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzQ1NicpO1xuXG4gICAgICAgIGV4cGVjdChpbnB1dHNbMF0pLnRvSGF2ZVZhbHVlKCc0Jyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJkZXNjcmliZSIsInVzZXIiLCJ1c2VyRXZlbnQiLCJzZXR1cCIsIm1vY2tPbkNvbXBsZXRlIiwiamVzdCIsImZuIiwibW9ja09uQ2hhbmdlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJpdCIsInJlbmRlciIsIk9UUElucHV0IiwibGVuZ3RoIiwib25Db21wbGV0ZSIsImlucHV0cyIsInNjcmVlbiIsImdldEFsbEJ5Um9sZSIsImV4cGVjdCIsInRvSGF2ZUxlbmd0aCIsImNvbnRhaW5lciIsImNsb3Nlc3QiLCJ0b0JlSW5UaGVEb2N1bWVudCIsImxvYWRpbmciLCJmb3JFYWNoIiwiaW5wdXQiLCJ0b0JlRGlzYWJsZWQiLCJlcnJvciIsImdldEJ5VGV4dCIsImZpcnN0SW5wdXQiLCJ0eXBlIiwidG9IYXZlVmFsdWUiLCJ0b0hhdmVGb2N1cyIsImtleWJvYXJkIiwiY2xlYXIiLCJmb2N1cyIsImZpcmVFdmVudCIsImNoYW5nZSIsInRhcmdldCIsInZhbHVlIiwid2FpdEZvciIsInBhc3RlRXZlbnQiLCJDbGlwYm9hcmRFdmVudCIsImNsaXBib2FyZERhdGEiLCJEYXRhVHJhbnNmZXIiLCJzZXREYXRhIiwicGFzdGUiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsIm5vdCIsInRvSGF2ZUJlZW5DYWxsZWQiLCJ1bm1vdW50IiwiaW5kZXgiLCJ0b0hhdmVBdHRyaWJ1dGUiLCJsaXZlUmVnaW9uIiwiZ2V0QnlSb2xlIiwiZXJyb3JFbGVtZW50IiwicmVuZGVyU3B5IiwiVGVzdENvbXBvbmVudCIsInJlcmVuZGVyIiwidG9IYXZlQmVlbkNhbGxlZFRpbWVzIiwic3VjY2Vzc0NhbGxiYWNrIiwiY2FsbGJhY2siLCJpIiwicmVjZWl2ZWRDb2RlIiwiY29kZSIsInRvQmUiLCJ0b1Rocm93IiwiaGFzVmFsdWVzIiwic29tZSIsImdldEF0dHJpYnV0ZSIsInVwZGF0ZWRJbnB1dHMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJFdmVudCIsInNlbGVjdCIsInJhbmRvbUlucHV0IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwicmFuZG9tS2V5IiwidG9TdHJpbmciLCJzbGljZSIsImRvY3VtZW50IiwiYWN0aXZlRWxlbWVudCIsImlkeCIsInRvQmVHcmVhdGVyVGhhbiIsImNhbGxiYWNrMSIsImNhbGxiYWNrMiIsIlBhcmVudENvbXBvbmVudCIsImNvdW50IiwiZGl2Iiwic3BhbiIsInF1ZXJ5QnlUZXh0Il0sIm1hcHBpbmdzIjoiQUFBQTs7O0NBR0M7Ozs7OzhEQUVpQjt3QkFDaUM7a0VBQzdCO2lFQUNEOzs7Ozs7QUFFckJBLFNBQVMsWUFBWTtJQUNuQixNQUFNQyxPQUFPQyxrQkFBUyxDQUFDQyxLQUFLO0lBQzVCLE1BQU1DLGlCQUFpQkMsS0FBS0MsRUFBRTtJQUM5QixNQUFNQyxlQUFlRixLQUFLQyxFQUFFO0lBRTVCRSxXQUFXO1FBQ1RILEtBQUtJLGFBQWE7SUFDcEI7SUFFQVQsU0FBUyx1QkFBdUI7UUFDOUJVLEdBQUcsMENBQTBDO1lBQzNDQyxJQUFBQSxjQUFNLGdCQUFDLHFCQUFDQyxpQkFBUTtnQkFBQ0MsUUFBUTtnQkFBR0MsWUFBWVY7O1lBRXhDLE1BQU1XLFNBQVNDLGNBQU0sQ0FBQ0MsWUFBWSxDQUFDO1lBQ25DQyxPQUFPSCxRQUFRSSxZQUFZLENBQUM7UUFDOUI7UUFFQVQsR0FBRyw4QkFBOEI7WUFDL0JDLElBQUFBLGNBQU0sZ0JBQUMscUJBQUNDLGlCQUFRO2dCQUFDQyxRQUFRO2dCQUFHQyxZQUFZVjs7WUFFeEMsTUFBTVcsU0FBU0MsY0FBTSxDQUFDQyxZQUFZLENBQUM7WUFDbkNDLE9BQU9ILFFBQVFJLFlBQVksQ0FBQztRQUM5QjtRQUVBVCxHQUFHLGlDQUFp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