406ef28df82f04013b8ddd53c932a895
/**
 * Simple OTPInput Component Tests
 * Basic functionality tests without complex dependencies
 */ "use strict";
// Mock framer-motion to avoid animation issues in tests
jest.mock('framer-motion', ()=>({
        motion: {
            div: ({ children, ...props })=>/*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                    ...props,
                    children: children
                }),
            p: ({ children, ...props })=>/*#__PURE__*/ (0, _jsxruntime.jsx)("p", {
                    ...props,
                    children: children
                })
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _userevent = /*#__PURE__*/ _interop_require_default(require("@testing-library/user-event"));
const _OTPInput = /*#__PURE__*/ _interop_require_default(require("../OTPInput"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
describe('OTPInput - Basic Functionality', ()=>{
    const user = _userevent.default.setup();
    const mockOnComplete = jest.fn();
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    describe('Component Rendering', ()=>{
        it('renders correct number of input fields', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            expect(inputs).toHaveLength(6);
        });
        it('renders with custom length', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 4,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            expect(inputs).toHaveLength(4);
        });
        it('shows loading state', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete,
                loading: true
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            inputs.forEach((input)=>{
                expect(input).toBeDisabled();
            });
            expect(_react1.screen.getByText('Verifying...')).toBeInTheDocument();
        });
        it('shows error state', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete,
                error: "Invalid OTP"
            }));
            expect(_react1.screen.getByText('Invalid OTP')).toBeInTheDocument();
            expect(_react1.screen.getByRole('alert')).toBeInTheDocument();
        });
    });
    describe('Input Behavior', ()=>{
        it('accepts only numeric input', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const firstInput = _react1.screen.getAllByRole('textbox')[0];
            await user.type(firstInput, 'a');
            expect(firstInput).toHaveValue('');
            await user.type(firstInput, '1');
            expect(firstInput).toHaveValue('1');
        });
        it('moves to next input after entering digit', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            await user.type(inputs[0], '1');
            expect(inputs[1]).toHaveFocus();
        });
        it('handles backspace navigation', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            // Type in first input and move to second
            await user.type(inputs[0], '1');
            expect(inputs[1]).toHaveFocus();
            // Backspace should move back to first input
            await user.keyboard('{Backspace}');
            expect(inputs[0]).toHaveFocus();
        });
        it('replaces existing digit when typing', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const firstInput = _react1.screen.getAllByRole('textbox')[0];
            await user.type(firstInput, '1');
            expect(firstInput).toHaveValue('1');
            // Clear and type new digit
            await user.clear(firstInput);
            await user.type(firstInput, '2');
            expect(firstInput).toHaveValue('2');
        });
    });
    describe('Completion Handling', ()=>{
        it('calls onComplete when all fields are filled', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 4,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            await user.type(inputs[0], '1');
            await user.type(inputs[1], '2');
            await user.type(inputs[2], '3');
            await user.type(inputs[3], '4');
            await (0, _react1.waitFor)(()=>{
                expect(mockOnComplete).toHaveBeenCalledWith('1234');
            });
        });
        it('does not call onComplete for incomplete OTP', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            await user.type(inputs[0], '1');
            await user.type(inputs[1], '2');
            await user.type(inputs[2], '3');
            expect(mockOnComplete).not.toHaveBeenCalled();
        });
    });
    describe('Accessibility', ()=>{
        it('has proper ARIA attributes', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            inputs.forEach((input, index)=>{
                expect(input).toHaveAttribute('aria-label', `Digit ${index + 1} of 6`);
                expect(input).toHaveAttribute('inputMode', 'numeric');
            });
        });
        it('supports screen readers with live region', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const liveRegion = _react1.screen.getByRole('status');
            expect(liveRegion).toHaveAttribute('aria-live', 'polite');
            expect(liveRegion).toHaveAttribute('aria-atomic', 'true');
        });
        it('announces errors to screen readers', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete,
                error: "Invalid OTP"
            }));
            const errorElement = _react1.screen.getByText('Invalid OTP');
            expect(errorElement).toHaveAttribute('role', 'alert');
        });
    });
    describe('Edge Cases', ()=>{
        it('handles focus events correctly', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            // Focus on middle input
            inputs[2].focus();
            expect(inputs[2]).toHaveFocus();
            // Type should work from any focused input
            await user.type(inputs[2], '5');
            expect(inputs[2]).toHaveValue('5');
        });
        it('handles loading state correctly', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete,
                loading: true
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            inputs.forEach((input)=>{
                expect(input).toBeDisabled();
            });
            expect(_react1.screen.getByText('Verifying...')).toBeInTheDocument();
        });
        it('handles error state correctly', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete,
                error: "Invalid code"
            }));
            expect(_react1.screen.getByText('Invalid code')).toBeInTheDocument();
            expect(_react1.screen.getByRole('alert')).toBeInTheDocument();
        });
    });
    describe('Security', ()=>{
        it('does not expose OTP in DOM attributes', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            inputs.forEach((input)=>{
                expect(input).not.toHaveAttribute('data-value');
                expect(input).not.toHaveAttribute('title');
            });
        });
        it('uses proper input mode for numeric input', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            inputs.forEach((input)=>{
                expect(input).toHaveAttribute('inputMode', 'numeric');
                expect(input).toHaveAttribute('maxLength', '1');
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQS5QXFxEb2N1bWVudHNcXERFVlxcZWNoby1tYWluXFxmcm9udGVuZFxcc3JjXFxjb21wb25lbnRzXFxhdXRoXFxfX3Rlc3RzX19cXE9UUElucHV0LnNpbXBsZS50ZXN0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogU2ltcGxlIE9UUElucHV0IENvbXBvbmVudCBUZXN0c1xyXG4gKiBCYXNpYyBmdW5jdGlvbmFsaXR5IHRlc3RzIHdpdGhvdXQgY29tcGxleCBkZXBlbmRlbmNpZXNcclxuICovXHJcblxyXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyByZW5kZXIsIHNjcmVlbiwgZmlyZUV2ZW50LCB3YWl0Rm9yIH0gZnJvbSAnQHRlc3RpbmctbGlicmFyeS9yZWFjdCc7XHJcbmltcG9ydCB1c2VyRXZlbnQgZnJvbSAnQHRlc3RpbmctbGlicmFyeS91c2VyLWV2ZW50JztcclxuaW1wb3J0IE9UUElucHV0IGZyb20gJ0AvY29tcG9uZW50cy9hdXRoL09UUElucHV0JztcclxuXHJcbi8vIE1vY2sgZnJhbWVyLW1vdGlvbiB0byBhdm9pZCBhbmltYXRpb24gaXNzdWVzIGluIHRlc3RzXHJcbmplc3QubW9jaygnZnJhbWVyLW1vdGlvbicsICgpID0+ICh7XHJcbiAgbW90aW9uOiB7XHJcbiAgICBkaXY6ICh7IGNoaWxkcmVuLCAuLi5wcm9wcyB9OiBhbnkpID0+IDxkaXYgey4uLnByb3BzfT57Y2hpbGRyZW59PC9kaXY+LFxyXG4gICAgcDogKHsgY2hpbGRyZW4sIC4uLnByb3BzIH06IGFueSkgPT4gPHAgey4uLnByb3BzfT57Y2hpbGRyZW59PC9wPixcclxuICB9LFxyXG59KSk7XHJcblxyXG5kZXNjcmliZSgnT1RQSW5wdXQgLSBCYXNpYyBGdW5jdGlvbmFsaXR5JywgKCkgPT4ge1xyXG4gIGNvbnN0IHVzZXIgPSB1c2VyRXZlbnQuc2V0dXAoKTtcclxuICBjb25zdCBtb2NrT25Db21wbGV0ZSA9IGplc3QuZm4oKTtcclxuXHJcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XHJcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ0NvbXBvbmVudCBSZW5kZXJpbmcnLCAoKSA9PiB7XHJcbiAgICBpdCgncmVuZGVycyBjb3JyZWN0IG51bWJlciBvZiBpbnB1dCBmaWVsZHMnLCAoKSA9PiB7XHJcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xyXG5cclxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xyXG4gICAgICBleHBlY3QoaW5wdXRzKS50b0hhdmVMZW5ndGgoNik7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgncmVuZGVycyB3aXRoIGN1c3RvbSBsZW5ndGgnLCAoKSA9PiB7XHJcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs0fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xyXG5cclxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xyXG4gICAgICBleHBlY3QoaW5wdXRzKS50b0hhdmVMZW5ndGgoNCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvd3MgbG9hZGluZyBzdGF0ZScsICgpID0+IHtcclxuICAgICAgcmVuZGVyKFxyXG4gICAgICAgIDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSBsb2FkaW5nPXt0cnVlfSAvPlxyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xyXG4gICAgICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IHtcclxuICAgICAgICBleHBlY3QoaW5wdXQpLnRvQmVEaXNhYmxlZCgpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdWZXJpZnlpbmcuLi4nKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG93cyBlcnJvciBzdGF0ZScsICgpID0+IHtcclxuICAgICAgcmVuZGVyKFxyXG4gICAgICAgIDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSBlcnJvcj1cIkludmFsaWQgT1RQXCIgLz5cclxuICAgICAgKTtcclxuXHJcbiAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KCdJbnZhbGlkIE9UUCcpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xyXG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5Um9sZSgnYWxlcnQnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnSW5wdXQgQmVoYXZpb3InLCAoKSA9PiB7XHJcbiAgICBpdCgnYWNjZXB0cyBvbmx5IG51bWVyaWMgaW5wdXQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xyXG5cclxuICAgICAgY29uc3QgZmlyc3RJbnB1dCA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKVswXTtcclxuXHJcbiAgICAgIGF3YWl0IHVzZXIudHlwZShmaXJzdElucHV0LCAnYScpO1xyXG4gICAgICBleHBlY3QoZmlyc3RJbnB1dCkudG9IYXZlVmFsdWUoJycpO1xyXG5cclxuICAgICAgYXdhaXQgdXNlci50eXBlKGZpcnN0SW5wdXQsICcxJyk7XHJcbiAgICAgIGV4cGVjdChmaXJzdElucHV0KS50b0hhdmVWYWx1ZSgnMScpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ21vdmVzIHRvIG5leHQgaW5wdXQgYWZ0ZXIgZW50ZXJpbmcgZGlnaXQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xyXG5cclxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xyXG5cclxuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzEnKTtcclxuICAgICAgZXhwZWN0KGlucHV0c1sxXSkudG9IYXZlRm9jdXMoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdoYW5kbGVzIGJhY2tzcGFjZSBuYXZpZ2F0aW9uJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcclxuXHJcbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcclxuXHJcbiAgICAgIC8vIFR5cGUgaW4gZmlyc3QgaW5wdXQgYW5kIG1vdmUgdG8gc2Vjb25kXHJcbiAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMF0sICcxJyk7XHJcbiAgICAgIGV4cGVjdChpbnB1dHNbMV0pLnRvSGF2ZUZvY3VzKCk7XHJcblxyXG4gICAgICAvLyBCYWNrc3BhY2Ugc2hvdWxkIG1vdmUgYmFjayB0byBmaXJzdCBpbnB1dFxyXG4gICAgICBhd2FpdCB1c2VyLmtleWJvYXJkKCd7QmFja3NwYWNlfScpO1xyXG4gICAgICBleHBlY3QoaW5wdXRzWzBdKS50b0hhdmVGb2N1cygpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3JlcGxhY2VzIGV4aXN0aW5nIGRpZ2l0IHdoZW4gdHlwaW5nJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcclxuXHJcbiAgICAgIGNvbnN0IGZpcnN0SW5wdXQgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94JylbMF07XHJcblxyXG4gICAgICBhd2FpdCB1c2VyLnR5cGUoZmlyc3RJbnB1dCwgJzEnKTtcclxuICAgICAgZXhwZWN0KGZpcnN0SW5wdXQpLnRvSGF2ZVZhbHVlKCcxJyk7XHJcblxyXG4gICAgICAvLyBDbGVhciBhbmQgdHlwZSBuZXcgZGlnaXRcclxuICAgICAgYXdhaXQgdXNlci5jbGVhcihmaXJzdElucHV0KTtcclxuICAgICAgYXdhaXQgdXNlci50eXBlKGZpcnN0SW5wdXQsICcyJyk7XHJcbiAgICAgIGV4cGVjdChmaXJzdElucHV0KS50b0hhdmVWYWx1ZSgnMicpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdDb21wbGV0aW9uIEhhbmRsaW5nJywgKCkgPT4ge1xyXG4gICAgaXQoJ2NhbGxzIG9uQ29tcGxldGUgd2hlbiBhbGwgZmllbGRzIGFyZSBmaWxsZWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs0fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xyXG5cclxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xyXG5cclxuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzEnKTtcclxuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1sxXSwgJzInKTtcclxuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1syXSwgJzMnKTtcclxuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1szXSwgJzQnKTtcclxuXHJcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICAgIGV4cGVjdChtb2NrT25Db21wbGV0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJzEyMzQnKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnZG9lcyBub3QgY2FsbCBvbkNvbXBsZXRlIGZvciBpbmNvbXBsZXRlIE9UUCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XHJcblxyXG4gICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XHJcblxyXG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnMScpO1xyXG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzFdLCAnMicpO1xyXG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzJdLCAnMycpO1xyXG5cclxuICAgICAgZXhwZWN0KG1vY2tPbkNvbXBsZXRlKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdBY2Nlc3NpYmlsaXR5JywgKCkgPT4ge1xyXG4gICAgaXQoJ2hhcyBwcm9wZXIgQVJJQSBhdHRyaWJ1dGVzJywgKCkgPT4ge1xyXG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcclxuXHJcbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcclxuICAgICAgaW5wdXRzLmZvckVhY2goKGlucHV0LCBpbmRleCkgPT4ge1xyXG4gICAgICAgIGV4cGVjdChpbnB1dCkudG9IYXZlQXR0cmlidXRlKCdhcmlhLWxhYmVsJywgYERpZ2l0ICR7aW5kZXggKyAxfSBvZiA2YCk7XHJcbiAgICAgICAgZXhwZWN0KGlucHV0KS50b0hhdmVBdHRyaWJ1dGUoJ2lucHV0TW9kZScsICdudW1lcmljJyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3N1cHBvcnRzIHNjcmVlbiByZWFkZXJzIHdpdGggbGl2ZSByZWdpb24nLCAoKSA9PiB7XHJcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xyXG5cclxuICAgICAgY29uc3QgbGl2ZVJlZ2lvbiA9IHNjcmVlbi5nZXRCeVJvbGUoJ3N0YXR1cycpO1xyXG4gICAgICBleHBlY3QobGl2ZVJlZ2lvbikudG9IYXZlQXR0cmlidXRlKCdhcmlhLWxpdmUnLCAncG9saXRlJyk7XHJcbiAgICAgIGV4cGVjdChsaXZlUmVnaW9uKS50b0hhdmVBdHRyaWJ1dGUoJ2FyaWEtYXRvbWljJywgJ3RydWUnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdhbm5vdW5jZXMgZXJyb3JzIHRvIHNjcmVlbiByZWFkZXJzJywgKCkgPT4ge1xyXG4gICAgICByZW5kZXIoXHJcbiAgICAgICAgPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IGVycm9yPVwiSW52YWxpZCBPVFBcIiAvPlxyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc3QgZXJyb3JFbGVtZW50ID0gc2NyZWVuLmdldEJ5VGV4dCgnSW52YWxpZCBPVFAnKTtcclxuICAgICAgZXhwZWN0KGVycm9yRWxlbWVudCkudG9IYXZlQXR0cmlidXRlKCdyb2xlJywgJ2FsZXJ0Jyk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ0VkZ2UgQ2FzZXMnLCAoKSA9PiB7XHJcbiAgICBpdCgnaGFuZGxlcyBmb2N1cyBldmVudHMgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcclxuXHJcbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcclxuXHJcbiAgICAgIC8vIEZvY3VzIG9uIG1pZGRsZSBpbnB1dFxyXG4gICAgICBpbnB1dHNbMl0uZm9jdXMoKTtcclxuICAgICAgZXhwZWN0KGlucHV0c1syXSkudG9IYXZlRm9jdXMoKTtcclxuXHJcbiAgICAgIC8vIFR5cGUgc2hvdWxkIHdvcmsgZnJvbSBhbnkgZm9jdXNlZCBpbnB1dFxyXG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzJdLCAnNScpO1xyXG4gICAgICBleHBlY3QoaW5wdXRzWzJdKS50b0hhdmVWYWx1ZSgnNScpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ2hhbmRsZXMgbG9hZGluZyBzdGF0ZSBjb3JyZWN0bHknLCAoKSA9PiB7XHJcbiAgICAgIHJlbmRlcihcclxuICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gbG9hZGluZz17dHJ1ZX0gLz5cclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcclxuICAgICAgaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XHJcbiAgICAgICAgZXhwZWN0KGlucHV0KS50b0JlRGlzYWJsZWQoKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnVmVyaWZ5aW5nLi4uJykpLnRvQmVJblRoZURvY3VtZW50KCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnaGFuZGxlcyBlcnJvciBzdGF0ZSBjb3JyZWN0bHknLCAoKSA9PiB7XHJcbiAgICAgIHJlbmRlcihcclxuICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gZXJyb3I9XCJJbnZhbGlkIGNvZGVcIiAvPlxyXG4gICAgICApO1xyXG5cclxuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ0ludmFsaWQgY29kZScpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xyXG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5Um9sZSgnYWxlcnQnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnU2VjdXJpdHknLCAoKSA9PiB7XHJcbiAgICBpdCgnZG9lcyBub3QgZXhwb3NlIE9UUCBpbiBET00gYXR0cmlidXRlcycsICgpID0+IHtcclxuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XHJcblxyXG4gICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XHJcbiAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xyXG4gICAgICAgIGV4cGVjdChpbnB1dCkubm90LnRvSGF2ZUF0dHJpYnV0ZSgnZGF0YS12YWx1ZScpO1xyXG4gICAgICAgIGV4cGVjdChpbnB1dCkubm90LnRvSGF2ZUF0dHJpYnV0ZSgndGl0bGUnKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgndXNlcyBwcm9wZXIgaW5wdXQgbW9kZSBmb3IgbnVtZXJpYyBpbnB1dCcsICgpID0+IHtcclxuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XHJcblxyXG4gICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XHJcbiAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xyXG4gICAgICAgIGV4cGVjdChpbnB1dCkudG9IYXZlQXR0cmlidXRlKCdpbnB1dE1vZGUnLCAnbnVtZXJpYycpO1xyXG4gICAgICAgIGV4cGVjdChpbnB1dCkudG9IYXZlQXR0cmlidXRlKCdtYXhMZW5ndGgnLCAnMScpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59KTtcclxuIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwibW90aW9uIiwiZGl2IiwiY2hpbGRyZW4iLCJwcm9wcyIsInAiLCJkZXNjcmliZSIsInVzZXIiLCJ1c2VyRXZlbnQiLCJzZXR1cCIsIm1vY2tPbkNvbXBsZXRlIiwiZm4iLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIml0IiwicmVuZGVyIiwiT1RQSW5wdXQiLCJsZW5ndGgiLCJvbkNvbXBsZXRlIiwiaW5wdXRzIiwic2NyZWVuIiwiZ2V0QWxsQnlSb2xlIiwiZXhwZWN0IiwidG9IYXZlTGVuZ3RoIiwibG9hZGluZyIsImZvckVhY2giLCJpbnB1dCIsInRvQmVEaXNhYmxlZCIsImdldEJ5VGV4dCIsInRvQmVJblRoZURvY3VtZW50IiwiZXJyb3IiLCJnZXRCeVJvbGUiLCJmaXJzdElucHV0IiwidHlwZSIsInRvSGF2ZVZhbHVlIiwidG9IYXZlRm9jdXMiLCJrZXlib2FyZCIsImNsZWFyIiwid2FpdEZvciIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwibm90IiwidG9IYXZlQmVlbkNhbGxlZCIsImluZGV4IiwidG9IYXZlQXR0cmlidXRlIiwibGl2ZVJlZ2lvbiIsImVycm9yRWxlbWVudCIsImZvY3VzIl0sIm1hcHBpbmdzIjoiQUFBQTs7O0NBR0M7QUFPRCx3REFBd0Q7QUFDeERBLEtBQUtDLElBQUksQ0FBQyxpQkFBaUIsSUFBTyxDQUFBO1FBQ2hDQyxRQUFRO1lBQ05DLEtBQUssQ0FBQyxFQUFFQyxRQUFRLEVBQUUsR0FBR0MsT0FBWSxpQkFBSyxxQkFBQ0Y7b0JBQUssR0FBR0UsS0FBSzs4QkFBR0Q7O1lBQ3ZERSxHQUFHLENBQUMsRUFBRUYsUUFBUSxFQUFFLEdBQUdDLE9BQVksaUJBQUsscUJBQUNDO29CQUFHLEdBQUdELEtBQUs7OEJBQUdEOztRQUNyRDtJQUNGLENBQUE7Ozs7OzhEQVhrQjt3QkFDaUM7a0VBQzdCO2lFQUNEOzs7Ozs7QUFVckJHLFNBQVMsa0NBQWtDO0lBQ3pDLE1BQU1DLE9BQU9DLGtCQUFTLENBQUNDLEtBQUs7SUFDNUIsTUFBTUMsaUJBQWlCWCxLQUFLWSxFQUFFO0lBRTlCQyxXQUFXO1FBQ1RiLEtBQUtjLGFBQWE7SUFDcEI7SUFFQVAsU0FBUyx1QkFBdUI7UUFDOUJRLEdBQUcsMENBQTBD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