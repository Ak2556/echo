{"version":3,"sources":["C:\\Users\\A.P\\Documents\\DEV\\echo-main\\frontend\\src\\utils\\DSAUtils.ts"],"sourcesContent":["'use client';\r\n\r\n// Enhanced Data Structures and Algorithms Utility for Best Performance\r\n\r\n/**\r\n * Priority Queue implementation using Binary Heap\r\n * Time Complexity: O(log n) for insert/extract, O(1) for peek\r\n */\r\nexport class PriorityQueue<T> {\r\n  private heap: T[] = [];\r\n  private compareFn: (a: T, b: T) => number;\r\n\r\n  constructor(compareFn?: (a: T, b: T) => number) {\r\n    this.compareFn =\r\n      compareFn || ((a: any, b: any) => (a < b ? -1 : a > b ? 1 : 0));\r\n  }\r\n\r\n  enqueue(item: T): void {\r\n    this.heap.push(item);\r\n    this.heapifyUp(this.heap.length - 1);\r\n  }\r\n\r\n  dequeue(): T | undefined {\r\n    if (this.heap.length === 0) return undefined;\r\n    if (this.heap.length === 1) return this.heap.pop()!;\r\n\r\n    const result = this.heap[0];\r\n    this.heap[0] = this.heap.pop()!;\r\n    this.heapifyDown(0);\r\n    return result;\r\n  }\r\n\r\n  peek(): T | undefined {\r\n    return this.heap.length > 0 ? this.heap[0] : undefined;\r\n  }\r\n\r\n  size(): number {\r\n    return this.heap.length;\r\n  }\r\n\r\n  isEmpty(): boolean {\r\n    return this.heap.length === 0;\r\n  }\r\n\r\n  // Legacy methods for backward compatibility\r\n  insert(item: T, priority: number): void {\r\n    this.heap.push({ item, priority } as any);\r\n    this.heapifyUp(this.heap.length - 1);\r\n  }\r\n\r\n  extractMax(): T | null {\r\n    if (this.heap.length === 0) return null;\r\n    if (this.heap.length === 1)\r\n      return (this.heap.pop() as any).item || this.heap.pop()!;\r\n\r\n    const max = (this.heap[0] as any).item || this.heap[0];\r\n    this.heap[0] = this.heap.pop()!;\r\n    this.heapifyDown(0);\r\n    return max;\r\n  }\r\n\r\n  private heapifyUp(index: number): void {\r\n    while (index > 0) {\r\n      const parentIndex = Math.floor((index - 1) / 2);\r\n      // For min heap: break if parent <= child\r\n      if (this.compareFn(this.heap[parentIndex], this.heap[index]) <= 0) break;\r\n      this.swap(parentIndex, index);\r\n      index = parentIndex;\r\n    }\r\n  }\r\n\r\n  private heapifyDown(index: number): void {\r\n    while (true) {\r\n      let minIndex = index;\r\n      const leftChild = 2 * index + 1;\r\n      const rightChild = 2 * index + 2;\r\n\r\n      // For min heap: pick the smaller child\r\n      if (\r\n        leftChild < this.heap.length &&\r\n        this.compareFn(this.heap[leftChild], this.heap[minIndex]) < 0\r\n      ) {\r\n        minIndex = leftChild;\r\n      }\r\n\r\n      if (\r\n        rightChild < this.heap.length &&\r\n        this.compareFn(this.heap[rightChild], this.heap[minIndex]) < 0\r\n      ) {\r\n        minIndex = rightChild;\r\n      }\r\n\r\n      if (minIndex === index) break;\r\n      this.swap(index, minIndex);\r\n      index = minIndex;\r\n    }\r\n  }\r\n\r\n  private swap(i: number, j: number): void {\r\n    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];\r\n  }\r\n}\r\n\r\n/**\r\n * Trie data structure for efficient string operations\r\n * Time Complexity: O(m) for insert/search where m is string length\r\n */\r\nexport class Trie {\r\n  private root: TrieNode = new TrieNode();\r\n\r\n  insert(word: string): void {\r\n    let current = this.root;\r\n    for (const char of word.toLowerCase()) {\r\n      if (!current.children.has(char)) {\r\n        current.children.set(char, new TrieNode());\r\n      }\r\n      current = current.children.get(char)!;\r\n    }\r\n    current.isEndOfWord = true;\r\n  }\r\n\r\n  search(word: string): boolean {\r\n    let current = this.root;\r\n    for (const char of word.toLowerCase()) {\r\n      if (!current.children.has(char)) return false;\r\n      current = current.children.get(char)!;\r\n    }\r\n    return current.isEndOfWord;\r\n  }\r\n\r\n  startsWith(prefix: string): boolean {\r\n    let current = this.root;\r\n    for (const char of prefix.toLowerCase()) {\r\n      if (!current.children.has(char)) return false;\r\n      current = current.children.get(char)!;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  getWordsWithPrefix(prefix: string): string[] {\r\n    let current = this.root;\r\n    for (const char of prefix.toLowerCase()) {\r\n      if (!current.children.has(char)) return [];\r\n      current = current.children.get(char)!;\r\n    }\r\n\r\n    const words: string[] = [];\r\n    this.dfs(current, prefix, words);\r\n    return words;\r\n  }\r\n\r\n  findWordsWithPrefix(prefix: string): string[] {\r\n    return this.getWordsWithPrefix(prefix);\r\n  }\r\n\r\n  delete(word: string): boolean {\r\n    return this.deleteHelper(this.root, word.toLowerCase(), 0);\r\n  }\r\n\r\n  private deleteHelper(node: TrieNode, word: string, index: number): boolean {\r\n    if (index === word.length) {\r\n      if (!node.isEndOfWord) return false;\r\n      node.isEndOfWord = false;\r\n      return node.children.size === 0;\r\n    }\r\n\r\n    const char = word[index];\r\n    const childNode = node.children.get(char);\r\n    if (!childNode) return false;\r\n\r\n    const shouldDeleteChild = this.deleteHelper(childNode, word, index + 1);\r\n\r\n    if (shouldDeleteChild) {\r\n      node.children.delete(char);\r\n      return node.children.size === 0 && !node.isEndOfWord;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  private dfs(node: TrieNode, currentWord: string, words: string[]): void {\r\n    if (node.isEndOfWord) {\r\n      words.push(currentWord);\r\n    }\r\n\r\n    for (const [char, childNode] of node.children) {\r\n      this.dfs(childNode, currentWord + char, words);\r\n    }\r\n  }\r\n}\r\n\r\nclass TrieNode {\r\n  children: Map<string, TrieNode> = new Map();\r\n  isEndOfWord: boolean = false;\r\n}\r\n\r\n/**\r\n * LRU Cache implementation using HashMap + Doubly Linked List\r\n * Time Complexity: O(1) for get/put operations\r\n */\r\nexport class LRUCache<K, V> {\r\n  private capacity: number;\r\n  private cache: Map<K, Node<K, V>> = new Map();\r\n  private head: Node<K, V>;\r\n  private tail: Node<K, V>;\r\n\r\n  constructor(capacity: number) {\r\n    this.capacity = capacity;\r\n    this.head = new Node(null as any, null as any);\r\n    this.tail = new Node(null as any, null as any);\r\n    this.head.next = this.tail;\r\n    this.tail.prev = this.head;\r\n  }\r\n\r\n  get(key: K): V | undefined {\r\n    const node = this.cache.get(key);\r\n    if (!node) return undefined;\r\n\r\n    this.moveToHead(node);\r\n    return node.value;\r\n  }\r\n\r\n  get size(): number {\r\n    return this.cache.size;\r\n  }\r\n\r\n  clear(): void {\r\n    this.cache.clear();\r\n    this.head.next = this.tail;\r\n    this.tail.prev = this.head;\r\n  }\r\n\r\n  put(key: K, value: V): void {\r\n    const existingNode = this.cache.get(key);\r\n\r\n    if (existingNode) {\r\n      existingNode.value = value;\r\n      this.moveToHead(existingNode);\r\n    } else {\r\n      const newNode = new Node(key, value);\r\n\r\n      if (this.cache.size >= this.capacity) {\r\n        const lastNode = this.removeTail();\r\n        this.cache.delete(lastNode.key);\r\n      }\r\n\r\n      this.cache.set(key, newNode);\r\n      this.addToHead(newNode);\r\n    }\r\n  }\r\n\r\n  private addToHead(node: Node<K, V>): void {\r\n    node.prev = this.head;\r\n    node.next = this.head.next;\r\n    this.head.next!.prev = node;\r\n    this.head.next = node;\r\n  }\r\n\r\n  private removeNode(node: Node<K, V>): void {\r\n    node.prev!.next = node.next;\r\n    node.next!.prev = node.prev;\r\n  }\r\n\r\n  private moveToHead(node: Node<K, V>): void {\r\n    this.removeNode(node);\r\n    this.addToHead(node);\r\n  }\r\n\r\n  private removeTail(): Node<K, V> {\r\n    const lastNode = this.tail.prev!;\r\n    this.removeNode(lastNode);\r\n    return lastNode;\r\n  }\r\n}\r\n\r\nclass Node<K, V> {\r\n  key: K;\r\n  value: V;\r\n  prev: Node<K, V> | null = null;\r\n  next: Node<K, V> | null = null;\r\n\r\n  constructor(key: K, value: V) {\r\n    this.key = key;\r\n    this.value = value;\r\n  }\r\n}\r\n\r\n/**\r\n * Advanced Search Algorithms\r\n */\r\nexport class SearchAlgorithms {\r\n  /**\r\n   * Binary search - O(log n)\r\n   */\r\n  static binarySearch<T>(\r\n    array: T[],\r\n    target: T,\r\n    compareFn: (a: T, b: T) => number\r\n  ): number {\r\n    let left = 0;\r\n    let right = array.length - 1;\r\n\r\n    while (left <= right) {\r\n      const mid = Math.floor((left + right) / 2);\r\n      const cmp = compareFn(array[mid], target);\r\n\r\n      if (cmp === 0) return mid;\r\n      if (cmp < 0) left = mid + 1;\r\n      else right = mid - 1;\r\n    }\r\n\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Boyer-Moore string search - O(n/m) average case\r\n   */\r\n  static boyerMooreSearch(text: string, pattern: string): number[] {\r\n    const positions: number[] = [];\r\n    const m = pattern.length;\r\n    const n = text.length;\r\n\r\n    if (m === 0) return positions;\r\n\r\n    const badChar = this.buildBadCharTable(pattern);\r\n\r\n    let skip = 0;\r\n    while (skip <= n - m) {\r\n      let j = m - 1;\r\n\r\n      while (j >= 0 && pattern[j] === text[skip + j]) {\r\n        j--;\r\n      }\r\n\r\n      if (j < 0) {\r\n        positions.push(skip);\r\n        skip += skip + m < n ? m - badChar[text.charCodeAt(skip + m)] : 1;\r\n      } else {\r\n        skip += Math.max(1, j - badChar[text.charCodeAt(skip + j)]);\r\n      }\r\n    }\r\n\r\n    return positions;\r\n  }\r\n\r\n  private static buildBadCharTable(pattern: string): number[] {\r\n    const table = new Array(256).fill(-1);\r\n    for (let i = 0; i < pattern.length; i++) {\r\n      table[pattern.charCodeAt(i)] = i;\r\n    }\r\n    return table;\r\n  }\r\n\r\n  /**\r\n   * Fuzzy search using Levenshtein distance with optimizations\r\n   */\r\n  static fuzzySearch(\r\n    query: string,\r\n    candidates: string[],\r\n    threshold: number = 0.6\r\n  ): Array<{ item: string; score: number }> {\r\n    const results = candidates.map((candidate) => ({\r\n      item: candidate,\r\n      score: this.jaroWinklerSimilarity(\r\n        query.toLowerCase(),\r\n        candidate.toLowerCase()\r\n      ),\r\n    }));\r\n\r\n    return results\r\n      .filter((result) => result.score >= threshold)\r\n      .sort((a, b) => b.score - a.score);\r\n  }\r\n\r\n  private static jaroWinklerSimilarity(s1: string, s2: string): number {\r\n    const jaro = this.jaroSimilarity(s1, s2);\r\n    const prefixLength = this.commonPrefixLength(s1, s2, 4);\r\n    return jaro + 0.1 * prefixLength * (1 - jaro);\r\n  }\r\n\r\n  private static jaroSimilarity(s1: string, s2: string): number {\r\n    if (s1.length === 0 && s2.length === 0) return 1;\r\n    if (s1.length === 0 || s2.length === 0) return 0;\r\n\r\n    const matchWindow = Math.floor(Math.max(s1.length, s2.length) / 2) - 1;\r\n    const s1Matches = new Array(s1.length).fill(false);\r\n    const s2Matches = new Array(s2.length).fill(false);\r\n\r\n    let matches = 0;\r\n    let transpositions = 0;\r\n\r\n    // Find matches\r\n    for (let i = 0; i < s1.length; i++) {\r\n      const start = Math.max(0, i - matchWindow);\r\n      const end = Math.min(i + matchWindow + 1, s2.length);\r\n\r\n      for (let j = start; j < end; j++) {\r\n        if (s2Matches[j] || s1[i] !== s2[j]) continue;\r\n        s1Matches[i] = s2Matches[j] = true;\r\n        matches++;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (matches === 0) return 0;\r\n\r\n    // Count transpositions\r\n    let k = 0;\r\n    for (let i = 0; i < s1.length; i++) {\r\n      if (!s1Matches[i]) continue;\r\n      while (!s2Matches[k]) k++;\r\n      if (s1[i] !== s2[k]) transpositions++;\r\n      k++;\r\n    }\r\n\r\n    return (\r\n      (matches / s1.length +\r\n        matches / s2.length +\r\n        (matches - transpositions / 2) / matches) /\r\n      3\r\n    );\r\n  }\r\n\r\n  private static commonPrefixLength(\r\n    s1: string,\r\n    s2: string,\r\n    maxLength: number\r\n  ): number {\r\n    let length = 0;\r\n    for (let i = 0; i < Math.min(s1.length, s2.length, maxLength); i++) {\r\n      if (s1[i] === s2[i]) length++;\r\n      else break;\r\n    }\r\n    return length;\r\n  }\r\n}\r\n\r\n/**\r\n * Graph algorithms for relationship and network analysis\r\n */\r\nexport class GraphAlgorithms {\r\n  /**\r\n   * Find shortest path using Dijkstra's algorithm\r\n   */\r\n  static dijkstra<T>(\r\n    graph: Map<T, Array<{ node: T; weight: number }>>,\r\n    start: T,\r\n    end: T\r\n  ): { path: T[]; distance: number } | null {\r\n    const distances = new Map<T, number>();\r\n    const previous = new Map<T, T | null>();\r\n    const unvisited = new PriorityQueue<T>();\r\n\r\n    // Initialize distances\r\n    for (const node of graph.keys()) {\r\n      distances.set(node, node === start ? 0 : Infinity);\r\n      previous.set(node, null);\r\n      unvisited.insert(node, node === start ? 0 : -Infinity);\r\n    }\r\n\r\n    while (unvisited.size() > 0) {\r\n      const current = unvisited.extractMax()!;\r\n\r\n      if (current === end) break;\r\n      if (distances.get(current) === Infinity) break;\r\n\r\n      const neighbors = graph.get(current) || [];\r\n      for (const neighbor of neighbors) {\r\n        const alt = distances.get(current)! + neighbor.weight;\r\n        if (alt < distances.get(neighbor.node)!) {\r\n          distances.set(neighbor.node, alt);\r\n          previous.set(neighbor.node, current);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Reconstruct path\r\n    const path: T[] = [];\r\n    let current: T | null = end;\r\n    while (current !== null) {\r\n      path.unshift(current);\r\n      current = previous.get(current) || null;\r\n    }\r\n\r\n    if (path[0] !== start) return null;\r\n\r\n    return {\r\n      path,\r\n      distance: distances.get(end)!,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Detect cycles in directed graph using DFS\r\n   */\r\n  static hasCycle<T>(graph: Map<T, T[]>): boolean {\r\n    const visited = new Set<T>();\r\n    const recursionStack = new Set<T>();\r\n\r\n    for (const node of graph.keys()) {\r\n      if (!visited.has(node)) {\r\n        if (this.hasCycleDFS(graph, node, visited, recursionStack)) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  private static hasCycleDFS<T>(\r\n    graph: Map<T, T[]>,\r\n    node: T,\r\n    visited: Set<T>,\r\n    recursionStack: Set<T>\r\n  ): boolean {\r\n    visited.add(node);\r\n    recursionStack.add(node);\r\n\r\n    const neighbors = graph.get(node) || [];\r\n    for (const neighbor of neighbors) {\r\n      if (!visited.has(neighbor)) {\r\n        if (this.hasCycleDFS(graph, neighbor, visited, recursionStack)) {\r\n          return true;\r\n        }\r\n      } else if (recursionStack.has(neighbor)) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    recursionStack.delete(node);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Advanced sorting with multiple algorithms and optimizations\r\n */\r\nexport class OptimizedSorting {\r\n  /**\r\n   * Hybrid sorting algorithm that chooses best approach based on data characteristics\r\n   */\r\n  static smartSort<T>(array: T[], compareFn?: (a: T, b: T) => number): T[] {\r\n    if (array.length <= 1) return [...array];\r\n\r\n    const compare = compareFn || ((a, b) => (a < b ? -1 : a > b ? 1 : 0));\r\n\r\n    // Choose algorithm based on array characteristics\r\n    if (array.length < 50) {\r\n      return this.insertionSort([...array], compare);\r\n    } else if (this.isNearlySorted(array, compare)) {\r\n      return this.timSort([...array], compare);\r\n    } else if (array.length > 10000) {\r\n      return this.parallelQuickSort([...array], compare);\r\n    } else {\r\n      return this.quickSort([...array], compare);\r\n    }\r\n  }\r\n\r\n  private static isNearlySorted<T>(\r\n    array: T[],\r\n    compare: (a: T, b: T) => number\r\n  ): boolean {\r\n    let inversions = 0;\r\n    for (let i = 0; i < array.length - 1; i++) {\r\n      if (compare(array[i], array[i + 1]) > 0) {\r\n        inversions++;\r\n        if (inversions > array.length * 0.1) return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private static insertionSort<T>(\r\n    array: T[],\r\n    compare: (a: T, b: T) => number\r\n  ): T[] {\r\n    for (let i = 1; i < array.length; i++) {\r\n      const key = array[i];\r\n      let j = i - 1;\r\n      while (j >= 0 && compare(array[j], key) > 0) {\r\n        array[j + 1] = array[j];\r\n        j--;\r\n      }\r\n      array[j + 1] = key;\r\n    }\r\n    return array;\r\n  }\r\n\r\n  private static quickSort<T>(\r\n    array: T[],\r\n    compare: (a: T, b: T) => number\r\n  ): T[] {\r\n    if (array.length <= 1) return array;\r\n\r\n    const pivot = array[Math.floor(array.length / 2)];\r\n    const left = array.filter((x) => compare(x, pivot) < 0);\r\n    const middle = array.filter((x) => compare(x, pivot) === 0);\r\n    const right = array.filter((x) => compare(x, pivot) > 0);\r\n\r\n    return [\r\n      ...this.quickSort(left, compare),\r\n      ...middle,\r\n      ...this.quickSort(right, compare),\r\n    ];\r\n  }\r\n\r\n  private static timSort<T>(array: T[], compare: (a: T, b: T) => number): T[] {\r\n    // Simplified TimSort implementation\r\n    const minMerge = 32;\r\n\r\n    if (array.length < minMerge) {\r\n      return this.insertionSort(array, compare);\r\n    }\r\n\r\n    const mid = Math.floor(array.length / 2);\r\n    const left = this.timSort(array.slice(0, mid), compare);\r\n    const right = this.timSort(array.slice(mid), compare);\r\n\r\n    return this.merge(left, right, compare);\r\n  }\r\n\r\n  private static merge<T>(\r\n    left: T[],\r\n    right: T[],\r\n    compare: (a: T, b: T) => number\r\n  ): T[] {\r\n    const result: T[] = [];\r\n    let i = 0,\r\n      j = 0;\r\n\r\n    while (i < left.length && j < right.length) {\r\n      if (compare(left[i], right[j]) <= 0) {\r\n        result.push(left[i++]);\r\n      } else {\r\n        result.push(right[j++]);\r\n      }\r\n    }\r\n\r\n    return result.concat(left.slice(i)).concat(right.slice(j));\r\n  }\r\n\r\n  private static parallelQuickSort<T>(\r\n    array: T[],\r\n    compare: (a: T, b: T) => number\r\n  ): T[] {\r\n    // Simplified parallel sorting (would use Web Workers in real implementation)\r\n    return this.quickSort(array, compare);\r\n  }\r\n}\r\n\r\n/**\r\n * Memory-efficient data operations\r\n */\r\nexport class MemoryOptimizedOperations {\r\n  /**\r\n   * Process large datasets in chunks to avoid memory issues\r\n   */\r\n  static async processInChunks<T, R>(\r\n    data: T[],\r\n    processor: (chunk: T[]) => R[],\r\n    chunkSize: number = 1000\r\n  ): Promise<R[]> {\r\n    const results: R[] = [];\r\n\r\n    for (let i = 0; i < data.length; i += chunkSize) {\r\n      const chunk = data.slice(i, i + chunkSize);\r\n      const chunkResults = processor(chunk);\r\n      results.push(...chunkResults);\r\n\r\n      // Allow garbage collection between chunks\r\n      await new Promise((resolve) => setTimeout(resolve, 0));\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Virtual scrolling for large lists\r\n   */\r\n  static calculateVisibleItems(\r\n    totalItems: number,\r\n    itemHeight: number,\r\n    containerHeight: number,\r\n    scrollTop: number,\r\n    buffer: number = 5\r\n  ): { startIndex: number; endIndex: number; offsetY: number } {\r\n    const visibleCount = Math.ceil(containerHeight / itemHeight);\r\n    const startIndex = Math.max(0, Math.floor(scrollTop / itemHeight) - buffer);\r\n    const endIndex = Math.min(\r\n      totalItems - 1,\r\n      startIndex + visibleCount + 2 * buffer\r\n    );\r\n    const offsetY = startIndex * itemHeight;\r\n\r\n    return { startIndex, endIndex, offsetY };\r\n  }\r\n}\r\n\r\n/**\r\n * Performance monitoring and analytics\r\n */\r\nexport class PerformanceAnalytics {\r\n  private static measurements = new Map<string, number[]>();\r\n\r\n  static measure<T>(name: string, fn: () => T): T {\r\n    const start = performance.now();\r\n    const result = fn();\r\n    const end = performance.now();\r\n\r\n    if (!this.measurements.has(name)) {\r\n      this.measurements.set(name, []);\r\n    }\r\n    this.measurements.get(name)!.push(end - start);\r\n\r\n    return result;\r\n  }\r\n\r\n  static async measureAsync<T>(name: string, fn: () => Promise<T>): Promise<T> {\r\n    const start = performance.now();\r\n    const result = await fn();\r\n    const end = performance.now();\r\n\r\n    if (!this.measurements.has(name)) {\r\n      this.measurements.set(name, []);\r\n    }\r\n    this.measurements.get(name)!.push(end - start);\r\n\r\n    return result;\r\n  }\r\n\r\n  static getStats(name: string): {\r\n    count: number;\r\n    totalTime: number;\r\n    averageTime: number;\r\n    minTime: number;\r\n    maxTime: number;\r\n  } | null {\r\n    const times = this.measurements.get(name);\r\n    if (!times) return null;\r\n\r\n    // Return zeros for empty measurements (after clear)\r\n    if (times.length === 0) {\r\n      return {\r\n        count: 0,\r\n        totalTime: 0,\r\n        averageTime: 0,\r\n        minTime: 0,\r\n        maxTime: 0,\r\n      };\r\n    }\r\n\r\n    const sum = times.reduce((a, b) => a + b, 0);\r\n    return {\r\n      count: times.length,\r\n      totalTime: sum,\r\n      averageTime: sum / times.length,\r\n      minTime: Math.min(...times),\r\n      maxTime: Math.max(...times),\r\n    };\r\n  }\r\n\r\n  static clearMeasurements(name?: string): void {\r\n    if (name) {\r\n      this.measurements.set(name, []);\r\n    } else {\r\n      // Clear all measurements but keep the keys\r\n      for (const key of this.measurements.keys()) {\r\n        this.measurements.set(key, []);\r\n      }\r\n    }\r\n  }\r\n}\r\n"],"names":["GraphAlgorithms","LRUCache","MemoryOptimizedOperations","OptimizedSorting","PerformanceAnalytics","PriorityQueue","SearchAlgorithms","Trie","compareFn","heap","a","b","enqueue","item","push","heapifyUp","length","dequeue","undefined","pop","result","heapifyDown","peek","size","isEmpty","insert","priority","extractMax","max","index","parentIndex","Math","floor","swap","minIndex","leftChild","rightChild","i","j","word","current","root","char","toLowerCase","children","has","set","TrieNode","get","isEndOfWord","search","startsWith","prefix","getWordsWithPrefix","words","dfs","findWordsWithPrefix","delete","deleteHelper","node","childNode","shouldDeleteChild","currentWord","Map","capacity","cache","head","Node","tail","next","prev","key","moveToHead","value","clear","put","existingNode","newNode","lastNode","removeTail","addToHead","removeNode","binarySearch","array","target","left","right","mid","cmp","boyerMooreSearch","text","pattern","positions","m","n","badChar","buildBadCharTable","skip","charCodeAt","table","Array","fill","fuzzySearch","query","candidates","threshold","results","map","candidate","score","jaroWinklerSimilarity","filter","sort","s1","s2","jaro","jaroSimilarity","prefixLength","commonPrefixLength","matchWindow","s1Matches","s2Matches","matches","transpositions","start","end","min","k","maxLength","dijkstra","graph","distances","previous","unvisited","keys","Infinity","neighbors","neighbor","alt","weight","path","unshift","distance","hasCycle","visited","Set","recursionStack","hasCycleDFS","add","smartSort","compare","insertionSort","isNearlySorted","timSort","parallelQuickSort","quickSort","inversions","pivot","x","middle","minMerge","slice","merge","concat","processInChunks","data","processor","chunkSize","chunk","chunkResults","Promise","resolve","setTimeout","calculateVisibleItems","totalItems","itemHeight","containerHeight","scrollTop","buffer","visibleCount","ceil","startIndex","endIndex","offsetY","measurements","measure","name","fn","performance","now","measureAsync","getStats","times","count","totalTime","averageTime","minTime","maxTime","sum","reduce","clearMeasurements"],"mappings":"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"}