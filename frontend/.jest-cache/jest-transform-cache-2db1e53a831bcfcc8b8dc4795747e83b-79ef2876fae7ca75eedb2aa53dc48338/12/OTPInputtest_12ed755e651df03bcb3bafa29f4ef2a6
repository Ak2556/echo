6768e8154e4416a2be1713976575cb5f
/**
 * OTPInput Component Tests
 * Comprehensive test suite for OTP input functionality
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _userevent = /*#__PURE__*/ _interop_require_default(require("@testing-library/user-event"));
const _OTPInput = /*#__PURE__*/ _interop_require_default(require("../OTPInput"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
describe('OTPInput', ()=>{
    const user = _userevent.default.setup();
    const mockOnComplete = jest.fn();
    const mockOnChange = jest.fn();
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    describe('Component Rendering', ()=>{
        it('renders correct number of input fields', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            expect(inputs).toHaveLength(6);
        });
        it('renders with custom length', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 4,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            expect(inputs).toHaveLength(4);
        });
        it('renders with proper structure', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const container = _react1.screen.getAllByRole('textbox')[0].closest('.otp-input-container');
            expect(container).toBeInTheDocument();
        });
        it('shows loading state', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete,
                loading: true
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            inputs.forEach((input)=>{
                expect(input).toBeDisabled();
            });
        });
        it('shows error state', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete,
                error: "Invalid OTP"
            }));
            expect(_react1.screen.getByText('Invalid OTP')).toBeInTheDocument();
        });
    });
    describe('Input Behavior', ()=>{
        it('accepts only numeric input', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const firstInput = _react1.screen.getAllByRole('textbox')[0];
            await user.type(firstInput, 'a');
            expect(firstInput).toHaveValue('');
            await user.type(firstInput, '1');
            expect(firstInput).toHaveValue('1');
        });
        it('moves to next input after entering digit', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            await user.type(inputs[0], '1');
            expect(inputs[1]).toHaveFocus();
        });
        it('moves to previous input on backspace', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            // Type in first input and move to second
            await user.type(inputs[0], '1');
            expect(inputs[1]).toHaveFocus();
            // Backspace should move back to first input
            await user.keyboard('{Backspace}');
            expect(inputs[0]).toHaveFocus();
        });
        it('replaces existing digit when typing', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const firstInput = _react1.screen.getAllByRole('textbox')[0];
            await user.type(firstInput, '1');
            expect(firstInput).toHaveValue('1');
            // Clear and type new digit
            await user.clear(firstInput);
            await user.type(firstInput, '2');
            expect(firstInput).toHaveValue('2');
        });
        it('handles arrow key navigation', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            inputs[0].focus();
            await user.keyboard('{ArrowRight}');
            expect(inputs[1]).toHaveFocus();
            await user.keyboard('{ArrowLeft}');
            expect(inputs[0]).toHaveFocus();
        });
        it('handles Home key to jump to first input', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            inputs[3].focus();
            expect(inputs[3]).toHaveFocus();
            await user.keyboard('{Home}');
            expect(inputs[0]).toHaveFocus();
        });
        it('handles End key to jump to last input', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            inputs[2].focus();
            expect(inputs[2]).toHaveFocus();
            await user.keyboard('{End}');
            expect(inputs[5]).toHaveFocus();
        });
        it('handles backspace on filled input to clear it', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            // Fill first input
            await user.type(inputs[0], '1');
            expect(inputs[0]).toHaveValue('1');
            // Go back to first input
            inputs[0].focus();
            // Backspace should clear current input
            await user.keyboard('{Backspace}');
            expect(inputs[0]).toHaveValue('');
        });
        it('handles multi-character input from rapid typing', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            // Start from middle input
            inputs[2].focus();
            // Simulate rapid multi-character input
            _react1.fireEvent.change(inputs[2], {
                target: {
                    value: '345'
                }
            });
            await (0, _react1.waitFor)(()=>{
                expect(inputs[2]).toHaveValue('3');
                expect(inputs[3]).toHaveValue('4');
                expect(inputs[4]).toHaveValue('5');
            });
        });
    });
    describe('Paste Functionality', ()=>{
        it('handles paste of complete OTP', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const firstInput = _react1.screen.getAllByRole('textbox')[0];
            firstInput.focus();
            // Simulate paste event
            const pasteEvent = new ClipboardEvent('paste', {
                clipboardData: new DataTransfer()
            });
            pasteEvent.clipboardData?.setData('text/plain', '123456');
            _react1.fireEvent.paste(firstInput, pasteEvent);
            await (0, _react1.waitFor)(()=>{
                expect(mockOnComplete).toHaveBeenCalledWith('123456');
            });
        });
        it('handles paste of partial OTP', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const firstInput = _react1.screen.getAllByRole('textbox')[0];
            firstInput.focus();
            const pasteEvent = new ClipboardEvent('paste', {
                clipboardData: new DataTransfer()
            });
            pasteEvent.clipboardData?.setData('text/plain', '123');
            _react1.fireEvent.paste(firstInput, pasteEvent);
            await (0, _react1.waitFor)(()=>{
                const inputs = _react1.screen.getAllByRole('textbox');
                expect(inputs[0]).toHaveValue('1');
                expect(inputs[1]).toHaveValue('2');
                expect(inputs[2]).toHaveValue('3');
                expect(inputs[2]).toHaveFocus();
            });
        });
        it('ignores non-numeric paste content', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const firstInput = _react1.screen.getAllByRole('textbox')[0];
            firstInput.focus();
            const pasteEvent = new ClipboardEvent('paste', {
                clipboardData: new DataTransfer()
            });
            pasteEvent.clipboardData?.setData('text/plain', 'abc123');
            _react1.fireEvent.paste(firstInput, pasteEvent);
            // Should not fill any inputs with invalid characters
            const inputs = _react1.screen.getAllByRole('textbox');
            inputs.forEach((input)=>{
                expect(input).toHaveValue('');
            });
        });
        it('handles paste longer than input length', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 4,
                onComplete: mockOnComplete
            }));
            const firstInput = _react1.screen.getAllByRole('textbox')[0];
            firstInput.focus();
            const pasteEvent = new ClipboardEvent('paste', {
                clipboardData: new DataTransfer()
            });
            pasteEvent.clipboardData?.setData('text/plain', '123456789');
            _react1.fireEvent.paste(firstInput, pasteEvent);
            await (0, _react1.waitFor)(()=>{
                expect(mockOnComplete).toHaveBeenCalledWith('1234');
            });
        });
    });
    describe('Completion Handling', ()=>{
        it('calls onComplete when all fields are filled', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 4,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            await user.type(inputs[0], '1');
            await user.type(inputs[1], '2');
            await user.type(inputs[2], '3');
            await user.type(inputs[3], '4');
            expect(mockOnComplete).toHaveBeenCalledWith('1234');
        });
        it('updates internal state on input change', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 4,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            await user.type(inputs[0], '1');
            expect(inputs[0]).toHaveValue('1');
            await user.type(inputs[1], '2');
            expect(inputs[1]).toHaveValue('2');
        });
        it('does not call onComplete for incomplete OTP', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            await user.type(inputs[0], '1');
            await user.type(inputs[1], '2');
            await user.type(inputs[2], '3');
            expect(mockOnComplete).not.toHaveBeenCalled();
        });
    });
    describe('Component State Management', ()=>{
        it('maintains internal state correctly', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            await user.type(inputs[0], '1');
            await user.type(inputs[1], '2');
            await user.type(inputs[2], '3');
            expect(inputs[0]).toHaveValue('1');
            expect(inputs[1]).toHaveValue('2');
            expect(inputs[2]).toHaveValue('3');
        });
        it('resets state when component remounts', ()=>{
            const { unmount } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            unmount();
            // Render a new instance
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            inputs.forEach((input)=>{
                expect(input).toHaveValue('');
            });
        });
    });
    describe('Accessibility', ()=>{
        it('has proper ARIA attributes', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            inputs.forEach((input, index)=>{
                expect(input).toHaveAttribute('aria-label', `Digit ${index + 1} of 6`);
                expect(input).toHaveAttribute('inputMode', 'numeric');
            });
        });
        it('supports screen readers with live region', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const liveRegion = _react1.screen.getByRole('status');
            expect(liveRegion).toHaveAttribute('aria-live', 'polite');
            expect(liveRegion).toHaveAttribute('aria-atomic', 'true');
        });
        it('announces errors to screen readers', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete,
                error: "Invalid OTP"
            }));
            const errorElement = _react1.screen.getByText('Invalid OTP');
            expect(errorElement).toHaveAttribute('role', 'alert');
        });
    });
    describe('Security', ()=>{
        it('does not expose OTP in DOM attributes', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            inputs.forEach((input)=>{
                expect(input).not.toHaveAttribute('data-value');
                expect(input).not.toHaveAttribute('title');
            });
        });
        it('uses proper input mode for numeric input', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            inputs.forEach((input)=>{
                expect(input).toHaveAttribute('inputMode', 'numeric');
                expect(input).toHaveAttribute('maxLength', '1');
            });
        });
    });
    describe('Edge Cases', ()=>{
        it('handles rapid typing', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            // Type rapidly in sequence
            await user.type(inputs[0], '123456');
            await (0, _react1.waitFor)(()=>{
                expect(mockOnComplete).toHaveBeenCalledWith('123456');
            });
        });
        it('handles focus events correctly', async ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            // Focus on middle input
            inputs[2].focus();
            expect(inputs[2]).toHaveFocus();
            // Type should work from any focused input
            await user.type(inputs[2], '5');
            expect(inputs[2]).toHaveValue('5');
        });
        it('handles loading state correctly', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete,
                loading: true
            }));
            const inputs = _react1.screen.getAllByRole('textbox');
            inputs.forEach((input)=>{
                expect(input).toBeDisabled();
            });
            expect(_react1.screen.getByText('Verifying...')).toBeInTheDocument();
        });
        it('handles error state correctly', ()=>{
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                length: 6,
                onComplete: mockOnComplete,
                error: "Invalid code"
            }));
            expect(_react1.screen.getByText('Invalid code')).toBeInTheDocument();
            expect(_react1.screen.getByRole('alert')).toBeInTheDocument();
        });
    });
    describe('Performance', ()=>{
        it('does not cause unnecessary re-renders', ()=>{
            const renderSpy = jest.fn();
            const TestComponent = ()=>{
                renderSpy();
                return /*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                });
            };
            const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            expect(renderSpy).toHaveBeenCalledTimes(1);
            // Re-render with same props
            rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
            // Should not cause additional renders due to memoization
            expect(renderSpy).toHaveBeenCalledTimes(2);
        });
    });
    describe('Production Error Scenarios', ()=>{
        describe('Network and API Failures', ()=>{
            it('calls onComplete callback when code is complete', async ()=>{
                const successCallback = jest.fn();
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: successCallback
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                await user.type(inputs[0], '123456');
                await (0, _react1.waitFor)(()=>{
                    expect(successCallback).toHaveBeenCalledWith('123456');
                });
            });
            it('allows multiple callback invocations', async ()=>{
                const callback = jest.fn();
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 4,
                    onComplete: callback
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                // First code
                await user.type(inputs[0], '1234');
                await (0, _react1.waitFor)(()=>{
                    expect(callback).toHaveBeenCalledTimes(1);
                });
                // Clear and enter new code
                for(let i = 0; i < 4; i++){
                    await user.clear(inputs[i]);
                }
                await user.type(inputs[0], '5678');
                await (0, _react1.waitFor)(()=>{
                    expect(callback).toHaveBeenCalledTimes(2);
                });
            });
            it('passes correct code to callback', async ()=>{
                let receivedCode = '';
                const callback = jest.fn((code)=>{
                    receivedCode = code;
                });
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: callback
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                await user.type(inputs[0], '987654');
                await (0, _react1.waitFor)(()=>{
                    expect(receivedCode).toBe('987654');
                });
            });
        });
        describe('Memory and Resource Management', ()=>{
            it('cleans up event listeners on unmount', ()=>{
                const { unmount } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                // Component should unmount without errors
                expect(()=>unmount()).not.toThrow();
            });
            it('handles rapid component mount/unmount cycles', ()=>{
                for(let i = 0; i < 10; i++){
                    const { unmount } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                        length: 6,
                        onComplete: mockOnComplete
                    }));
                    unmount();
                }
                // Should not leak memory or throw errors
                expect(true).toBe(true);
            });
            it('handles extremely long OTP codes efficiently', ()=>{
                const { container } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 20,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                expect(inputs).toHaveLength(20);
                // Should render without performance issues
                expect(container).toBeInTheDocument();
            });
        });
        describe('Race Conditions and Timing Issues', ()=>{
            it('handles simultaneous input changes', async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                // Simulate rapid, simultaneous changes
                await user.type(inputs[0], '1');
                await user.type(inputs[1], '2');
                await user.type(inputs[2], '3');
                // Should handle gracefully - check that at least one input has a value
                const hasValues = inputs.some((input)=>input.getAttribute('value') !== '');
                expect(hasValues).toBe(true);
            });
            it('handles onChange during loading state', async ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    loading: false
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                await user.type(inputs[0], '1');
                // Switch to loading mid-input
                rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    loading: true
                }));
                // Inputs should be disabled
                const updatedInputs = _react1.screen.getAllByRole('textbox');
                updatedInputs.forEach((input)=>{
                    expect(input).toBeDisabled();
                });
            });
            it('handles onComplete being called multiple times for same code', async ()=>{
                const callback = jest.fn();
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 4,
                    onComplete: callback
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                await user.type(inputs[0], '1234');
                await (0, _react1.waitFor)(()=>{
                    expect(callback).toHaveBeenCalledTimes(1);
                });
                // Typing same code again
                await user.clear(inputs[0]);
                await user.type(inputs[0], '1234');
                // Should be called again
                expect(callback).toHaveBeenCalledTimes(2);
            });
            it('handles rapid error state changes', async ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    error: ""
                }));
                for(let i = 0; i < 10; i++){
                    rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                        length: 6,
                        onComplete: mockOnComplete,
                        error: `Error ${i}`
                    }));
                    await new Promise((resolve)=>setTimeout(resolve, 10));
                    rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                        length: 6,
                        onComplete: mockOnComplete,
                        error: ""
                    }));
                }
                // Should handle rapid changes without crashing
                expect(_react1.screen.getAllByRole('textbox')).toHaveLength(6);
            });
        });
        describe('Input Validation Edge Cases', ()=>{
            it('handles special Unicode digits', async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                // Try to input Unicode mathematical digits
                await user.type(inputs[0], 'ðŸðŸðŸ‘');
                // Should reject non-ASCII digits
                expect(inputs[0]).toHaveValue('');
            });
            it('handles mixed valid and invalid characters in paste', async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const firstInput = _react1.screen.getAllByRole('textbox')[0];
                firstInput.focus();
                const pasteEvent = new ClipboardEvent('paste', {
                    clipboardData: new DataTransfer()
                });
                pasteEvent.clipboardData?.setData('text/plain', '12abc34');
                _react1.fireEvent.paste(firstInput, pasteEvent);
                // Should reject entire paste due to invalid characters
                const inputs = _react1.screen.getAllByRole('textbox');
                inputs.forEach((input)=>{
                    expect(input).toHaveValue('');
                });
            });
            it('handles whitespace in pasted content', async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const firstInput = _react1.screen.getAllByRole('textbox')[0];
                firstInput.focus();
                const pasteEvent = new ClipboardEvent('paste', {
                    clipboardData: new DataTransfer()
                });
                pasteEvent.clipboardData?.setData('text/plain', '  123456  ');
                _react1.fireEvent.paste(firstInput, pasteEvent);
                await (0, _react1.waitFor)(()=>{
                    expect(mockOnComplete).toHaveBeenCalledWith('123456');
                });
            });
            it('handles newlines in pasted content', async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const firstInput = _react1.screen.getAllByRole('textbox')[0];
                firstInput.focus();
                const pasteEvent = new ClipboardEvent('paste', {
                    clipboardData: new DataTransfer()
                });
                pasteEvent.clipboardData?.setData('text/plain', '123\n456');
                _react1.fireEvent.paste(firstInput, pasteEvent);
                // Should reject due to newline
                const inputs = _react1.screen.getAllByRole('textbox');
                inputs.forEach((input)=>{
                    expect(input).toHaveValue('');
                });
            });
            it('handles zero-width characters', async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                // Try to input zero-width space
                await user.type(inputs[0], '1\u200B2');
                // Should only accept the digits
                expect(inputs[0]).toHaveValue('1');
            });
        });
        describe('Browser Compatibility Edge Cases', ()=>{
            it('handles missing clipboardData gracefully', ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const firstInput = _react1.screen.getAllByRole('textbox')[0];
                // Simulate old browser without clipboardData
                const pasteEvent = new Event('paste');
                (0, _react1.fireEvent)(firstInput, pasteEvent);
                // Should not crash
                expect(firstInput).toBeInTheDocument();
            });
            it('handles inputs without select method', async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                // Component should handle missing select method gracefully
                // This tests defensive programming for older browsers
                expect(inputs[0]).toBeInTheDocument();
                expect(typeof inputs[0].select).toBe('function');
            });
            it('handles focus on null refs gracefully', ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                // Component should handle null refs internally
                expect(_react1.screen.getAllByRole('textbox')).toHaveLength(6);
            });
        });
        describe('High Load Scenarios', ()=>{
            it('handles 1000+ rapid keystrokes', async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                // Simulate user mashing keys rapidly
                for(let i = 0; i < 1000; i++){
                    const randomInput = inputs[Math.floor(Math.random() * inputs.length)];
                    const randomKey = Math.floor(Math.random() * 10).toString();
                    _react1.fireEvent.change(randomInput, {
                        target: {
                            value: randomKey
                        }
                    });
                }
                // Should still be functional
                expect(inputs[0]).toBeInTheDocument();
            });
            it('handles continuous paste operations', async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const firstInput = _react1.screen.getAllByRole('textbox')[0];
                for(let i = 0; i < 100; i++){
                    const pasteEvent = new ClipboardEvent('paste', {
                        clipboardData: new DataTransfer()
                    });
                    pasteEvent.clipboardData?.setData('text/plain', `${100000 + i}`.slice(0, 6));
                    _react1.fireEvent.paste(firstInput, pasteEvent);
                }
                // Should handle without memory leaks
                expect(firstInput).toBeInTheDocument();
            });
            it('handles alternating focus between all inputs', async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                // Rapidly switch focus
                for(let i = 0; i < 100; i++){
                    inputs[i % 6].focus();
                }
                // Should handle gracefully
                expect(inputs.some((input)=>input === document.activeElement)).toBe(true);
            });
        });
        describe('Accessibility Under Stress', ()=>{
            it('maintains ARIA attributes during rapid state changes', async ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                for(let i = 0; i < 10; i++){
                    rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                        length: 6,
                        onComplete: mockOnComplete,
                        error: `Error ${i}`
                    }));
                    const inputs = _react1.screen.getAllByRole('textbox');
                    inputs.forEach((input, idx)=>{
                        expect(input).toHaveAttribute('aria-label', `Digit ${idx + 1} of 6`);
                        expect(input).toHaveAttribute('aria-invalid', 'true');
                    });
                    rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                        length: 6,
                        onComplete: mockOnComplete,
                        error: ""
                    }));
                }
            });
            it('maintains live region updates during high activity', async ()=>{
                (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const liveRegion = _react1.screen.getByRole('status');
                const inputs = _react1.screen.getAllByRole('textbox');
                for(let i = 0; i < 6; i++){
                    await user.type(inputs[i], (i + 1).toString());
                    expect(liveRegion).toBeInTheDocument();
                }
            });
        });
        describe('Component Lifecycle Edge Cases', ()=>{
            it('handles length prop changing dynamically', ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 4,
                    onComplete: mockOnComplete
                }));
                expect(_react1.screen.getAllByRole('textbox')).toHaveLength(4);
                // Changing length prop creates a new component instance
                // The component doesn't dynamically resize, so this test documents the behavior
                rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 8,
                    onComplete: mockOnComplete
                }));
                // Component will still have 4 inputs as it doesn't re-initialize
                expect(_react1.screen.getAllByRole('textbox').length).toBeGreaterThan(0);
            });
            it('handles onComplete callback changing', async ()=>{
                const callback1 = jest.fn();
                const callback2 = jest.fn();
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 4,
                    onComplete: callback1
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                await user.type(inputs[0], '1234');
                await (0, _react1.waitFor)(()=>{
                    expect(callback1).toHaveBeenCalled();
                });
                // Change callback
                rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 4,
                    onComplete: callback2
                }));
                await user.clear(inputs[0]);
                await user.type(inputs[0], '5678');
                await (0, _react1.waitFor)(()=>{
                    expect(callback2).toHaveBeenCalled();
                });
            });
            it('handles parent component re-renders', ()=>{
                const ParentComponent = ({ count })=>/*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                        children: [
                            /*#__PURE__*/ (0, _jsxruntime.jsx)("span", {
                                children: count
                            }),
                            /*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                                length: 6,
                                onComplete: mockOnComplete
                            })
                        ]
                    });
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(ParentComponent, {
                    count: 0
                }));
                for(let i = 0; i < 100; i++){
                    rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(ParentComponent, {
                        count: i
                    }));
                }
                expect(_react1.screen.getAllByRole('textbox')).toHaveLength(6);
            });
        });
        describe('Error Recovery', ()=>{
            it('recovers from error state when user corrects input', async ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    error: "Invalid code"
                }));
                expect(_react1.screen.getByText('Invalid code')).toBeInTheDocument();
                rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    error: ""
                }));
                expect(_react1.screen.queryByText('Invalid code')).not.toBeInTheDocument();
            });
            it('allows re-entry after error', async ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    error: "Try again"
                }));
                rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    error: ""
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                await user.type(inputs[0], '123456');
                await (0, _react1.waitFor)(()=>{
                    expect(mockOnComplete).toHaveBeenCalledWith('123456');
                });
            });
            it('clears input when error is shown', async ()=>{
                const { rerender } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete
                }));
                const inputs = _react1.screen.getAllByRole('textbox');
                await user.type(inputs[0], '123');
                // Show error - simulating failed verification
                rerender(/*#__PURE__*/ (0, _jsxruntime.jsx)(_OTPInput.default, {
                    length: 6,
                    onComplete: mockOnComplete,
                    error: "Invalid"
                }));
                // User should be able to clear and retry
                await user.clear(inputs[0]);
                await user.type(inputs[0], '456');
                expect(inputs[0]).toHaveValue('4');
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQS5QXFxEb2N1bWVudHNcXERFVlxcZWNoby1tYWluXFxmcm9udGVuZFxcc3JjXFxjb21wb25lbnRzXFxhdXRoXFxfX3Rlc3RzX19cXE9UUElucHV0LnRlc3QudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBPVFBJbnB1dCBDb21wb25lbnQgVGVzdHNcclxuICogQ29tcHJlaGVuc2l2ZSB0ZXN0IHN1aXRlIGZvciBPVFAgaW5wdXQgZnVuY3Rpb25hbGl0eVxyXG4gKi9cclxuXHJcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IHJlbmRlciwgc2NyZWVuLCBmaXJlRXZlbnQsIHdhaXRGb3IgfSBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3JlYWN0JztcclxuaW1wb3J0IHVzZXJFdmVudCBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3VzZXItZXZlbnQnO1xyXG5pbXBvcnQgT1RQSW5wdXQgZnJvbSAnQC9jb21wb25lbnRzL2F1dGgvT1RQSW5wdXQnO1xyXG5cclxuZGVzY3JpYmUoJ09UUElucHV0JywgKCkgPT4ge1xyXG4gIGNvbnN0IHVzZXIgPSB1c2VyRXZlbnQuc2V0dXAoKTtcclxuICBjb25zdCBtb2NrT25Db21wbGV0ZSA9IGplc3QuZm4oKTtcclxuICBjb25zdCBtb2NrT25DaGFuZ2UgPSBqZXN0LmZuKCk7XHJcblxyXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xyXG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdDb21wb25lbnQgUmVuZGVyaW5nJywgKCkgPT4ge1xyXG4gICAgaXQoJ3JlbmRlcnMgY29ycmVjdCBudW1iZXIgb2YgaW5wdXQgZmllbGRzJywgKCkgPT4ge1xyXG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcclxuXHJcbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcclxuICAgICAgZXhwZWN0KGlucHV0cykudG9IYXZlTGVuZ3RoKDYpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3JlbmRlcnMgd2l0aCBjdXN0b20gbGVuZ3RoJywgKCkgPT4ge1xyXG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17NH0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcclxuXHJcbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcclxuICAgICAgZXhwZWN0KGlucHV0cykudG9IYXZlTGVuZ3RoKDQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3JlbmRlcnMgd2l0aCBwcm9wZXIgc3RydWN0dXJlJywgKCkgPT4ge1xyXG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcclxuXHJcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHNjcmVlblxyXG4gICAgICAgIC5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKVswXVxyXG4gICAgICAgIC5jbG9zZXN0KCcub3RwLWlucHV0LWNvbnRhaW5lcicpO1xyXG4gICAgICBleHBlY3QoY29udGFpbmVyKS50b0JlSW5UaGVEb2N1bWVudCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3dzIGxvYWRpbmcgc3RhdGUnLCAoKSA9PiB7XHJcbiAgICAgIHJlbmRlcihcclxuICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gbG9hZGluZz17dHJ1ZX0gLz5cclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcclxuICAgICAgaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XHJcbiAgICAgICAgZXhwZWN0KGlucHV0KS50b0JlRGlzYWJsZWQoKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvd3MgZXJyb3Igc3RhdGUnLCAoKSA9PiB7XHJcbiAgICAgIHJlbmRlcihcclxuICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gZXJyb3I9XCJJbnZhbGlkIE9UUFwiIC8+XHJcbiAgICAgICk7XHJcblxyXG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnSW52YWxpZCBPVFAnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnSW5wdXQgQmVoYXZpb3InLCAoKSA9PiB7XHJcbiAgICBpdCgnYWNjZXB0cyBvbmx5IG51bWVyaWMgaW5wdXQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xyXG5cclxuICAgICAgY29uc3QgZmlyc3RJbnB1dCA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKVswXTtcclxuXHJcbiAgICAgIGF3YWl0IHVzZXIudHlwZShmaXJzdElucHV0LCAnYScpO1xyXG4gICAgICBleHBlY3QoZmlyc3RJbnB1dCkudG9IYXZlVmFsdWUoJycpO1xyXG5cclxuICAgICAgYXdhaXQgdXNlci50eXBlKGZpcnN0SW5wdXQsICcxJyk7XHJcbiAgICAgIGV4cGVjdChmaXJzdElucHV0KS50b0hhdmVWYWx1ZSgnMScpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ21vdmVzIHRvIG5leHQgaW5wdXQgYWZ0ZXIgZW50ZXJpbmcgZGlnaXQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xyXG5cclxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xyXG5cclxuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzEnKTtcclxuICAgICAgZXhwZWN0KGlucHV0c1sxXSkudG9IYXZlRm9jdXMoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdtb3ZlcyB0byBwcmV2aW91cyBpbnB1dCBvbiBiYWNrc3BhY2UnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xyXG5cclxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xyXG5cclxuICAgICAgLy8gVHlwZSBpbiBmaXJzdCBpbnB1dCBhbmQgbW92ZSB0byBzZWNvbmRcclxuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzEnKTtcclxuICAgICAgZXhwZWN0KGlucHV0c1sxXSkudG9IYXZlRm9jdXMoKTtcclxuXHJcbiAgICAgIC8vIEJhY2tzcGFjZSBzaG91bGQgbW92ZSBiYWNrIHRvIGZpcnN0IGlucHV0XHJcbiAgICAgIGF3YWl0IHVzZXIua2V5Ym9hcmQoJ3tCYWNrc3BhY2V9Jyk7XHJcbiAgICAgIGV4cGVjdChpbnB1dHNbMF0pLnRvSGF2ZUZvY3VzKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgncmVwbGFjZXMgZXhpc3RpbmcgZGlnaXQgd2hlbiB0eXBpbmcnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xyXG5cclxuICAgICAgY29uc3QgZmlyc3RJbnB1dCA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKVswXTtcclxuXHJcbiAgICAgIGF3YWl0IHVzZXIudHlwZShmaXJzdElucHV0LCAnMScpO1xyXG4gICAgICBleHBlY3QoZmlyc3RJbnB1dCkudG9IYXZlVmFsdWUoJzEnKTtcclxuXHJcbiAgICAgIC8vIENsZWFyIGFuZCB0eXBlIG5ldyBkaWdpdFxyXG4gICAgICBhd2FpdCB1c2VyLmNsZWFyKGZpcnN0SW5wdXQpO1xyXG4gICAgICBhd2FpdCB1c2VyLnR5cGUoZmlyc3RJbnB1dCwgJzInKTtcclxuICAgICAgZXhwZWN0KGZpcnN0SW5wdXQpLnRvSGF2ZVZhbHVlKCcyJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnaGFuZGxlcyBhcnJvdyBrZXkgbmF2aWdhdGlvbicsIGFzeW5jICgpID0+IHtcclxuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XHJcblxyXG4gICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XHJcblxyXG4gICAgICBpbnB1dHNbMF0uZm9jdXMoKTtcclxuXHJcbiAgICAgIGF3YWl0IHVzZXIua2V5Ym9hcmQoJ3tBcnJvd1JpZ2h0fScpO1xyXG4gICAgICBleHBlY3QoaW5wdXRzWzFdKS50b0hhdmVGb2N1cygpO1xyXG5cclxuICAgICAgYXdhaXQgdXNlci5rZXlib2FyZCgne0Fycm93TGVmdH0nKTtcclxuICAgICAgZXhwZWN0KGlucHV0c1swXSkudG9IYXZlRm9jdXMoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdoYW5kbGVzIEhvbWUga2V5IHRvIGp1bXAgdG8gZmlyc3QgaW5wdXQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xyXG5cclxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xyXG5cclxuICAgICAgaW5wdXRzWzNdLmZvY3VzKCk7XHJcbiAgICAgIGV4cGVjdChpbnB1dHNbM10pLnRvSGF2ZUZvY3VzKCk7XHJcblxyXG4gICAgICBhd2FpdCB1c2VyLmtleWJvYXJkKCd7SG9tZX0nKTtcclxuICAgICAgZXhwZWN0KGlucHV0c1swXSkudG9IYXZlRm9jdXMoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdoYW5kbGVzIEVuZCBrZXkgdG8ganVtcCB0byBsYXN0IGlucHV0JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcclxuXHJcbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcclxuXHJcbiAgICAgIGlucHV0c1syXS5mb2N1cygpO1xyXG4gICAgICBleHBlY3QoaW5wdXRzWzJdKS50b0hhdmVGb2N1cygpO1xyXG5cclxuICAgICAgYXdhaXQgdXNlci5rZXlib2FyZCgne0VuZH0nKTtcclxuICAgICAgZXhwZWN0KGlucHV0c1s1XSkudG9IYXZlRm9jdXMoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdoYW5kbGVzIGJhY2tzcGFjZSBvbiBmaWxsZWQgaW5wdXQgdG8gY2xlYXIgaXQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xyXG5cclxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xyXG5cclxuICAgICAgLy8gRmlsbCBmaXJzdCBpbnB1dFxyXG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnMScpO1xyXG4gICAgICBleHBlY3QoaW5wdXRzWzBdKS50b0hhdmVWYWx1ZSgnMScpO1xyXG5cclxuICAgICAgLy8gR28gYmFjayB0byBmaXJzdCBpbnB1dFxyXG4gICAgICBpbnB1dHNbMF0uZm9jdXMoKTtcclxuXHJcbiAgICAgIC8vIEJhY2tzcGFjZSBzaG91bGQgY2xlYXIgY3VycmVudCBpbnB1dFxyXG4gICAgICBhd2FpdCB1c2VyLmtleWJvYXJkKCd7QmFja3NwYWNlfScpO1xyXG4gICAgICBleHBlY3QoaW5wdXRzWzBdKS50b0hhdmVWYWx1ZSgnJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnaGFuZGxlcyBtdWx0aS1jaGFyYWN0ZXIgaW5wdXQgZnJvbSByYXBpZCB0eXBpbmcnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xyXG5cclxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xyXG5cclxuICAgICAgLy8gU3RhcnQgZnJvbSBtaWRkbGUgaW5wdXRcclxuICAgICAgaW5wdXRzWzJdLmZvY3VzKCk7XHJcblxyXG4gICAgICAvLyBTaW11bGF0ZSByYXBpZCBtdWx0aS1jaGFyYWN0ZXIgaW5wdXRcclxuICAgICAgZmlyZUV2ZW50LmNoYW5nZShpbnB1dHNbMl0sIHsgdGFyZ2V0OiB7IHZhbHVlOiAnMzQ1JyB9IH0pO1xyXG5cclxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XHJcbiAgICAgICAgZXhwZWN0KGlucHV0c1syXSkudG9IYXZlVmFsdWUoJzMnKTtcclxuICAgICAgICBleHBlY3QoaW5wdXRzWzNdKS50b0hhdmVWYWx1ZSgnNCcpO1xyXG4gICAgICAgIGV4cGVjdChpbnB1dHNbNF0pLnRvSGF2ZVZhbHVlKCc1Jyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdQYXN0ZSBGdW5jdGlvbmFsaXR5JywgKCkgPT4ge1xyXG4gICAgaXQoJ2hhbmRsZXMgcGFzdGUgb2YgY29tcGxldGUgT1RQJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcclxuXHJcbiAgICAgIGNvbnN0IGZpcnN0SW5wdXQgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94JylbMF07XHJcbiAgICAgIGZpcnN0SW5wdXQuZm9jdXMoKTtcclxuXHJcbiAgICAgIC8vIFNpbXVsYXRlIHBhc3RlIGV2ZW50XHJcbiAgICAgIGNvbnN0IHBhc3RlRXZlbnQgPSBuZXcgQ2xpcGJvYXJkRXZlbnQoJ3Bhc3RlJywge1xyXG4gICAgICAgIGNsaXBib2FyZERhdGE6IG5ldyBEYXRhVHJhbnNmZXIoKSxcclxuICAgICAgfSk7XHJcbiAgICAgIHBhc3RlRXZlbnQuY2xpcGJvYXJkRGF0YT8uc2V0RGF0YSgndGV4dC9wbGFpbicsICcxMjM0NTYnKTtcclxuXHJcbiAgICAgIGZpcmVFdmVudC5wYXN0ZShmaXJzdElucHV0LCBwYXN0ZUV2ZW50KTtcclxuXHJcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICAgIGV4cGVjdChtb2NrT25Db21wbGV0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJzEyMzQ1NicpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdoYW5kbGVzIHBhc3RlIG9mIHBhcnRpYWwgT1RQJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcclxuXHJcbiAgICAgIGNvbnN0IGZpcnN0SW5wdXQgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94JylbMF07XHJcbiAgICAgIGZpcnN0SW5wdXQuZm9jdXMoKTtcclxuXHJcbiAgICAgIGNvbnN0IHBhc3RlRXZlbnQgPSBuZXcgQ2xpcGJvYXJkRXZlbnQoJ3Bhc3RlJywge1xyXG4gICAgICAgIGNsaXBib2FyZERhdGE6IG5ldyBEYXRhVHJhbnNmZXIoKSxcclxuICAgICAgfSk7XHJcbiAgICAgIHBhc3RlRXZlbnQuY2xpcGJvYXJkRGF0YT8uc2V0RGF0YSgndGV4dC9wbGFpbicsICcxMjMnKTtcclxuXHJcbiAgICAgIGZpcmVFdmVudC5wYXN0ZShmaXJzdElucHV0LCBwYXN0ZUV2ZW50KTtcclxuXHJcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcclxuICAgICAgICBleHBlY3QoaW5wdXRzWzBdKS50b0hhdmVWYWx1ZSgnMScpO1xyXG4gICAgICAgIGV4cGVjdChpbnB1dHNbMV0pLnRvSGF2ZVZhbHVlKCcyJyk7XHJcbiAgICAgICAgZXhwZWN0KGlucHV0c1syXSkudG9IYXZlVmFsdWUoJzMnKTtcclxuICAgICAgICBleHBlY3QoaW5wdXRzWzJdKS50b0hhdmVGb2N1cygpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdpZ25vcmVzIG5vbi1udW1lcmljIHBhc3RlIGNvbnRlbnQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xyXG5cclxuICAgICAgY29uc3QgZmlyc3RJbnB1dCA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKVswXTtcclxuICAgICAgZmlyc3RJbnB1dC5mb2N1cygpO1xyXG5cclxuICAgICAgY29uc3QgcGFzdGVFdmVudCA9IG5ldyBDbGlwYm9hcmRFdmVudCgncGFzdGUnLCB7XHJcbiAgICAgICAgY2xpcGJvYXJkRGF0YTogbmV3IERhdGFUcmFuc2ZlcigpLFxyXG4gICAgICB9KTtcclxuICAgICAgcGFzdGVFdmVudC5jbGlwYm9hcmREYXRhPy5zZXREYXRhKCd0ZXh0L3BsYWluJywgJ2FiYzEyMycpO1xyXG5cclxuICAgICAgZmlyZUV2ZW50LnBhc3RlKGZpcnN0SW5wdXQsIHBhc3RlRXZlbnQpO1xyXG5cclxuICAgICAgLy8gU2hvdWxkIG5vdCBmaWxsIGFueSBpbnB1dHMgd2l0aCBpbnZhbGlkIGNoYXJhY3RlcnNcclxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xyXG4gICAgICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IHtcclxuICAgICAgICBleHBlY3QoaW5wdXQpLnRvSGF2ZVZhbHVlKCcnKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnaGFuZGxlcyBwYXN0ZSBsb25nZXIgdGhhbiBpbnB1dCBsZW5ndGgnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs0fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xyXG5cclxuICAgICAgY29uc3QgZmlyc3RJbnB1dCA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKVswXTtcclxuICAgICAgZmlyc3RJbnB1dC5mb2N1cygpO1xyXG5cclxuICAgICAgY29uc3QgcGFzdGVFdmVudCA9IG5ldyBDbGlwYm9hcmRFdmVudCgncGFzdGUnLCB7XHJcbiAgICAgICAgY2xpcGJvYXJkRGF0YTogbmV3IERhdGFUcmFuc2ZlcigpLFxyXG4gICAgICB9KTtcclxuICAgICAgcGFzdGVFdmVudC5jbGlwYm9hcmREYXRhPy5zZXREYXRhKCd0ZXh0L3BsYWluJywgJzEyMzQ1Njc4OScpO1xyXG5cclxuICAgICAgZmlyZUV2ZW50LnBhc3RlKGZpcnN0SW5wdXQsIHBhc3RlRXZlbnQpO1xyXG5cclxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XHJcbiAgICAgICAgZXhwZWN0KG1vY2tPbkNvbXBsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnMTIzNCcpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnQ29tcGxldGlvbiBIYW5kbGluZycsICgpID0+IHtcclxuICAgIGl0KCdjYWxscyBvbkNvbXBsZXRlIHdoZW4gYWxsIGZpZWxkcyBhcmUgZmlsbGVkJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17NH0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcclxuXHJcbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcclxuXHJcbiAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMF0sICcxJyk7XHJcbiAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMV0sICcyJyk7XHJcbiAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMl0sICczJyk7XHJcbiAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbM10sICc0Jyk7XHJcblxyXG4gICAgICBleHBlY3QobW9ja09uQ29tcGxldGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcxMjM0Jyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgndXBkYXRlcyBpbnRlcm5hbCBzdGF0ZSBvbiBpbnB1dCBjaGFuZ2UnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs0fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xyXG5cclxuICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xyXG5cclxuICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzEnKTtcclxuICAgICAgZXhwZWN0KGlucHV0c1swXSkudG9IYXZlVmFsdWUoJzEnKTtcclxuXHJcbiAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMV0sICcyJyk7XHJcbiAgICAgIGV4cGVjdChpbnB1dHNbMV0pLnRvSGF2ZVZhbHVlKCcyJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnZG9lcyBub3QgY2FsbCBvbkNvbXBsZXRlIGZvciBpbmNvbXBsZXRlIE9UUCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XHJcblxyXG4gICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XHJcblxyXG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnMScpO1xyXG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzFdLCAnMicpO1xyXG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzJdLCAnMycpO1xyXG5cclxuICAgICAgZXhwZWN0KG1vY2tPbkNvbXBsZXRlKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdDb21wb25lbnQgU3RhdGUgTWFuYWdlbWVudCcsICgpID0+IHtcclxuICAgIGl0KCdtYWludGFpbnMgaW50ZXJuYWwgc3RhdGUgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcclxuXHJcbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcclxuXHJcbiAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMF0sICcxJyk7XHJcbiAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMV0sICcyJyk7XHJcbiAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMl0sICczJyk7XHJcblxyXG4gICAgICBleHBlY3QoaW5wdXRzWzBdKS50b0hhdmVWYWx1ZSgnMScpO1xyXG4gICAgICBleHBlY3QoaW5wdXRzWzFdKS50b0hhdmVWYWx1ZSgnMicpO1xyXG4gICAgICBleHBlY3QoaW5wdXRzWzJdKS50b0hhdmVWYWx1ZSgnMycpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Jlc2V0cyBzdGF0ZSB3aGVuIGNvbXBvbmVudCByZW1vdW50cycsICgpID0+IHtcclxuICAgICAgY29uc3QgeyB1bm1vdW50IH0gPSByZW5kZXIoXHJcbiAgICAgICAgPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+XHJcbiAgICAgICk7XHJcblxyXG4gICAgICB1bm1vdW50KCk7XHJcblxyXG4gICAgICAvLyBSZW5kZXIgYSBuZXcgaW5zdGFuY2VcclxuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XHJcblxyXG4gICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XHJcbiAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xyXG4gICAgICAgIGV4cGVjdChpbnB1dCkudG9IYXZlVmFsdWUoJycpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnQWNjZXNzaWJpbGl0eScsICgpID0+IHtcclxuICAgIGl0KCdoYXMgcHJvcGVyIEFSSUEgYXR0cmlidXRlcycsICgpID0+IHtcclxuICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XHJcblxyXG4gICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XHJcbiAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCwgaW5kZXgpID0+IHtcclxuICAgICAgICBleHBlY3QoaW5wdXQpLnRvSGF2ZUF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGBEaWdpdCAke2luZGV4ICsgMX0gb2YgNmApO1xyXG4gICAgICAgIGV4cGVjdChpbnB1dCkudG9IYXZlQXR0cmlidXRlKCdpbnB1dE1vZGUnLCAnbnVtZXJpYycpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzdXBwb3J0cyBzY3JlZW4gcmVhZGVycyB3aXRoIGxpdmUgcmVnaW9uJywgKCkgPT4ge1xyXG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcclxuXHJcbiAgICAgIGNvbnN0IGxpdmVSZWdpb24gPSBzY3JlZW4uZ2V0QnlSb2xlKCdzdGF0dXMnKTtcclxuICAgICAgZXhwZWN0KGxpdmVSZWdpb24pLnRvSGF2ZUF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ3BvbGl0ZScpO1xyXG4gICAgICBleHBlY3QobGl2ZVJlZ2lvbikudG9IYXZlQXR0cmlidXRlKCdhcmlhLWF0b21pYycsICd0cnVlJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnYW5ub3VuY2VzIGVycm9ycyB0byBzY3JlZW4gcmVhZGVycycsICgpID0+IHtcclxuICAgICAgcmVuZGVyKFxyXG4gICAgICAgIDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSBlcnJvcj1cIkludmFsaWQgT1RQXCIgLz5cclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNvbnN0IGVycm9yRWxlbWVudCA9IHNjcmVlbi5nZXRCeVRleHQoJ0ludmFsaWQgT1RQJyk7XHJcbiAgICAgIGV4cGVjdChlcnJvckVsZW1lbnQpLnRvSGF2ZUF0dHJpYnV0ZSgncm9sZScsICdhbGVydCcpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdTZWN1cml0eScsICgpID0+IHtcclxuICAgIGl0KCdkb2VzIG5vdCBleHBvc2UgT1RQIGluIERPTSBhdHRyaWJ1dGVzJywgKCkgPT4ge1xyXG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcclxuXHJcbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcclxuICAgICAgaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XHJcbiAgICAgICAgZXhwZWN0KGlucHV0KS5ub3QudG9IYXZlQXR0cmlidXRlKCdkYXRhLXZhbHVlJyk7XHJcbiAgICAgICAgZXhwZWN0KGlucHV0KS5ub3QudG9IYXZlQXR0cmlidXRlKCd0aXRsZScpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCd1c2VzIHByb3BlciBpbnB1dCBtb2RlIGZvciBudW1lcmljIGlucHV0JywgKCkgPT4ge1xyXG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcclxuXHJcbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcclxuICAgICAgaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XHJcbiAgICAgICAgZXhwZWN0KGlucHV0KS50b0hhdmVBdHRyaWJ1dGUoJ2lucHV0TW9kZScsICdudW1lcmljJyk7XHJcbiAgICAgICAgZXhwZWN0KGlucHV0KS50b0hhdmVBdHRyaWJ1dGUoJ21heExlbmd0aCcsICcxJyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdFZGdlIENhc2VzJywgKCkgPT4ge1xyXG4gICAgaXQoJ2hhbmRsZXMgcmFwaWQgdHlwaW5nJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcclxuXHJcbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcclxuXHJcbiAgICAgIC8vIFR5cGUgcmFwaWRseSBpbiBzZXF1ZW5jZVxyXG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnMTIzNDU2Jyk7XHJcblxyXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcclxuICAgICAgICBleHBlY3QobW9ja09uQ29tcGxldGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcxMjM0NTYnKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnaGFuZGxlcyBmb2N1cyBldmVudHMgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcclxuXHJcbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcclxuXHJcbiAgICAgIC8vIEZvY3VzIG9uIG1pZGRsZSBpbnB1dFxyXG4gICAgICBpbnB1dHNbMl0uZm9jdXMoKTtcclxuICAgICAgZXhwZWN0KGlucHV0c1syXSkudG9IYXZlRm9jdXMoKTtcclxuXHJcbiAgICAgIC8vIFR5cGUgc2hvdWxkIHdvcmsgZnJvbSBhbnkgZm9jdXNlZCBpbnB1dFxyXG4gICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzJdLCAnNScpO1xyXG4gICAgICBleHBlY3QoaW5wdXRzWzJdKS50b0hhdmVWYWx1ZSgnNScpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ2hhbmRsZXMgbG9hZGluZyBzdGF0ZSBjb3JyZWN0bHknLCAoKSA9PiB7XHJcbiAgICAgIHJlbmRlcihcclxuICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gbG9hZGluZz17dHJ1ZX0gLz5cclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcclxuICAgICAgaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XHJcbiAgICAgICAgZXhwZWN0KGlucHV0KS50b0JlRGlzYWJsZWQoKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnVmVyaWZ5aW5nLi4uJykpLnRvQmVJblRoZURvY3VtZW50KCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnaGFuZGxlcyBlcnJvciBzdGF0ZSBjb3JyZWN0bHknLCAoKSA9PiB7XHJcbiAgICAgIHJlbmRlcihcclxuICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gZXJyb3I9XCJJbnZhbGlkIGNvZGVcIiAvPlxyXG4gICAgICApO1xyXG5cclxuICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ0ludmFsaWQgY29kZScpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xyXG4gICAgICBleHBlY3Qoc2NyZWVuLmdldEJ5Um9sZSgnYWxlcnQnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnUGVyZm9ybWFuY2UnLCAoKSA9PiB7XHJcbiAgICBpdCgnZG9lcyBub3QgY2F1c2UgdW5uZWNlc3NhcnkgcmUtcmVuZGVycycsICgpID0+IHtcclxuICAgICAgY29uc3QgcmVuZGVyU3B5ID0gamVzdC5mbigpO1xyXG5cclxuICAgICAgY29uc3QgVGVzdENvbXBvbmVudCA9ICgpID0+IHtcclxuICAgICAgICByZW5kZXJTcHkoKTtcclxuICAgICAgICByZXR1cm4gPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+O1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgY29uc3QgeyByZXJlbmRlciB9ID0gcmVuZGVyKDxUZXN0Q29tcG9uZW50IC8+KTtcclxuXHJcbiAgICAgIGV4cGVjdChyZW5kZXJTcHkpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcclxuXHJcbiAgICAgIC8vIFJlLXJlbmRlciB3aXRoIHNhbWUgcHJvcHNcclxuICAgICAgcmVyZW5kZXIoPFRlc3RDb21wb25lbnQgLz4pO1xyXG5cclxuICAgICAgLy8gU2hvdWxkIG5vdCBjYXVzZSBhZGRpdGlvbmFsIHJlbmRlcnMgZHVlIHRvIG1lbW9pemF0aW9uXHJcbiAgICAgIGV4cGVjdChyZW5kZXJTcHkpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygyKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnUHJvZHVjdGlvbiBFcnJvciBTY2VuYXJpb3MnLCAoKSA9PiB7XHJcbiAgICBkZXNjcmliZSgnTmV0d29yayBhbmQgQVBJIEZhaWx1cmVzJywgKCkgPT4ge1xyXG4gICAgICBpdCgnY2FsbHMgb25Db21wbGV0ZSBjYWxsYmFjayB3aGVuIGNvZGUgaXMgY29tcGxldGUnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc3VjY2Vzc0NhbGxiYWNrID0gamVzdC5mbigpO1xyXG5cclxuICAgICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17c3VjY2Vzc0NhbGxiYWNrfSAvPik7XHJcbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xyXG5cclxuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnMTIzNDU2Jyk7XHJcblxyXG4gICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICAgICAgZXhwZWN0KHN1Y2Nlc3NDYWxsYmFjaykudG9IYXZlQmVlbkNhbGxlZFdpdGgoJzEyMzQ1NicpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdhbGxvd3MgbXVsdGlwbGUgY2FsbGJhY2sgaW52b2NhdGlvbnMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBqZXN0LmZuKCk7XHJcblxyXG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs0fSBvbkNvbXBsZXRlPXtjYWxsYmFja30gLz4pO1xyXG4gICAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcclxuXHJcbiAgICAgICAgLy8gRmlyc3QgY29kZVxyXG4gICAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMF0sICcxMjM0Jyk7XHJcblxyXG4gICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICAgICAgZXhwZWN0KGNhbGxiYWNrKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIENsZWFyIGFuZCBlbnRlciBuZXcgY29kZVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XHJcbiAgICAgICAgICBhd2FpdCB1c2VyLmNsZWFyKGlucHV0c1tpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnNTY3OCcpO1xyXG5cclxuICAgICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcclxuICAgICAgICAgIGV4cGVjdChjYWxsYmFjaykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdwYXNzZXMgY29ycmVjdCBjb2RlIHRvIGNhbGxiYWNrJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGxldCByZWNlaXZlZENvZGUgPSAnJztcclxuICAgICAgICBjb25zdCBjYWxsYmFjayA9IGplc3QuZm4oKGNvZGU6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgcmVjZWl2ZWRDb2RlID0gY29kZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e2NhbGxiYWNrfSAvPik7XHJcbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xyXG5cclxuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnOTg3NjU0Jyk7XHJcblxyXG4gICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICAgICAgZXhwZWN0KHJlY2VpdmVkQ29kZSkudG9CZSgnOTg3NjU0Jyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ01lbW9yeSBhbmQgUmVzb3VyY2UgTWFuYWdlbWVudCcsICgpID0+IHtcclxuICAgICAgaXQoJ2NsZWFucyB1cCBldmVudCBsaXN0ZW5lcnMgb24gdW5tb3VudCcsICgpID0+IHtcclxuICAgICAgICBjb25zdCB7IHVubW91bnQgfSA9IHJlbmRlcihcclxuICAgICAgICAgIDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPlxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIENvbXBvbmVudCBzaG91bGQgdW5tb3VudCB3aXRob3V0IGVycm9yc1xyXG4gICAgICAgIGV4cGVjdCgoKSA9PiB1bm1vdW50KCkpLm5vdC50b1Rocm93KCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ2hhbmRsZXMgcmFwaWQgY29tcG9uZW50IG1vdW50L3VubW91bnQgY3ljbGVzJywgKCkgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xyXG4gICAgICAgICAgY29uc3QgeyB1bm1vdW50IH0gPSByZW5kZXIoXHJcbiAgICAgICAgICAgIDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPlxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIHVubW91bnQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNob3VsZCBub3QgbGVhayBtZW1vcnkgb3IgdGhyb3cgZXJyb3JzXHJcbiAgICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ2hhbmRsZXMgZXh0cmVtZWx5IGxvbmcgT1RQIGNvZGVzIGVmZmljaWVudGx5JywgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXsyMH0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xyXG4gICAgICAgIGV4cGVjdChpbnB1dHMpLnRvSGF2ZUxlbmd0aCgyMCk7XHJcblxyXG4gICAgICAgIC8vIFNob3VsZCByZW5kZXIgd2l0aG91dCBwZXJmb3JtYW5jZSBpc3N1ZXNcclxuICAgICAgICBleHBlY3QoY29udGFpbmVyKS50b0JlSW5UaGVEb2N1bWVudCgpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlc2NyaWJlKCdSYWNlIENvbmRpdGlvbnMgYW5kIFRpbWluZyBJc3N1ZXMnLCAoKSA9PiB7XHJcbiAgICAgIGl0KCdoYW5kbGVzIHNpbXVsdGFuZW91cyBpbnB1dCBjaGFuZ2VzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xyXG4gICAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcclxuXHJcbiAgICAgICAgLy8gU2ltdWxhdGUgcmFwaWQsIHNpbXVsdGFuZW91cyBjaGFuZ2VzXHJcbiAgICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzEnKTtcclxuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzFdLCAnMicpO1xyXG4gICAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMl0sICczJyk7XHJcblxyXG4gICAgICAgIC8vIFNob3VsZCBoYW5kbGUgZ3JhY2VmdWxseSAtIGNoZWNrIHRoYXQgYXQgbGVhc3Qgb25lIGlucHV0IGhhcyBhIHZhbHVlXHJcbiAgICAgICAgY29uc3QgaGFzVmFsdWVzID0gaW5wdXRzLnNvbWUoXHJcbiAgICAgICAgICAoaW5wdXQpID0+IGlucHV0LmdldEF0dHJpYnV0ZSgndmFsdWUnKSAhPT0gJydcclxuICAgICAgICApO1xyXG4gICAgICAgIGV4cGVjdChoYXNWYWx1ZXMpLnRvQmUodHJ1ZSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ2hhbmRsZXMgb25DaGFuZ2UgZHVyaW5nIGxvYWRpbmcgc3RhdGUnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyByZXJlbmRlciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IGxvYWRpbmc9e2ZhbHNlfSAvPlxyXG4gICAgICAgICk7XHJcbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xyXG5cclxuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnMScpO1xyXG5cclxuICAgICAgICAvLyBTd2l0Y2ggdG8gbG9hZGluZyBtaWQtaW5wdXRcclxuICAgICAgICByZXJlbmRlcihcclxuICAgICAgICAgIDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSBsb2FkaW5nPXt0cnVlfSAvPlxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIElucHV0cyBzaG91bGQgYmUgZGlzYWJsZWRcclxuICAgICAgICBjb25zdCB1cGRhdGVkSW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xyXG4gICAgICAgIHVwZGF0ZWRJbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IHtcclxuICAgICAgICAgIGV4cGVjdChpbnB1dCkudG9CZURpc2FibGVkKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ2hhbmRsZXMgb25Db21wbGV0ZSBiZWluZyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgZm9yIHNhbWUgY29kZScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCBjYWxsYmFjayA9IGplc3QuZm4oKTtcclxuICAgICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17NH0gb25Db21wbGV0ZT17Y2FsbGJhY2t9IC8+KTtcclxuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XHJcblxyXG4gICAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMF0sICcxMjM0Jyk7XHJcblxyXG4gICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICAgICAgZXhwZWN0KGNhbGxiYWNrKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIFR5cGluZyBzYW1lIGNvZGUgYWdhaW5cclxuICAgICAgICBhd2FpdCB1c2VyLmNsZWFyKGlucHV0c1swXSk7XHJcbiAgICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzEyMzQnKTtcclxuXHJcbiAgICAgICAgLy8gU2hvdWxkIGJlIGNhbGxlZCBhZ2FpblxyXG4gICAgICAgIGV4cGVjdChjYWxsYmFjaykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdoYW5kbGVzIHJhcGlkIGVycm9yIHN0YXRlIGNoYW5nZXMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyByZXJlbmRlciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IGVycm9yPVwiXCIgLz5cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcclxuICAgICAgICAgIHJlcmVuZGVyKFxyXG4gICAgICAgICAgICA8T1RQSW5wdXRcclxuICAgICAgICAgICAgICBsZW5ndGg9ezZ9XHJcbiAgICAgICAgICAgICAgb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9XHJcbiAgICAgICAgICAgICAgZXJyb3I9e2BFcnJvciAke2l9YH1cclxuICAgICAgICAgICAgLz5cclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMCkpO1xyXG4gICAgICAgICAgcmVyZW5kZXIoXHJcbiAgICAgICAgICAgIDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSBlcnJvcj1cIlwiIC8+XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2hvdWxkIGhhbmRsZSByYXBpZCBjaGFuZ2VzIHdpdGhvdXQgY3Jhc2hpbmdcclxuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpKS50b0hhdmVMZW5ndGgoNik7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ0lucHV0IFZhbGlkYXRpb24gRWRnZSBDYXNlcycsICgpID0+IHtcclxuICAgICAgaXQoJ2hhbmRsZXMgc3BlY2lhbCBVbmljb2RlIGRpZ2l0cycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcclxuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XHJcblxyXG4gICAgICAgIC8vIFRyeSB0byBpbnB1dCBVbmljb2RlIG1hdGhlbWF0aWNhbCBkaWdpdHNcclxuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAn8J2fj/Cdn5DwnZ+RJyk7XHJcblxyXG4gICAgICAgIC8vIFNob3VsZCByZWplY3Qgbm9uLUFTQ0lJIGRpZ2l0c1xyXG4gICAgICAgIGV4cGVjdChpbnB1dHNbMF0pLnRvSGF2ZVZhbHVlKCcnKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpdCgnaGFuZGxlcyBtaXhlZCB2YWxpZCBhbmQgaW52YWxpZCBjaGFyYWN0ZXJzIGluIHBhc3RlJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xyXG4gICAgICAgIGNvbnN0IGZpcnN0SW5wdXQgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94JylbMF07XHJcbiAgICAgICAgZmlyc3RJbnB1dC5mb2N1cygpO1xyXG5cclxuICAgICAgICBjb25zdCBwYXN0ZUV2ZW50ID0gbmV3IENsaXBib2FyZEV2ZW50KCdwYXN0ZScsIHtcclxuICAgICAgICAgIGNsaXBib2FyZERhdGE6IG5ldyBEYXRhVHJhbnNmZXIoKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBwYXN0ZUV2ZW50LmNsaXBib2FyZERhdGE/LnNldERhdGEoJ3RleHQvcGxhaW4nLCAnMTJhYmMzNCcpO1xyXG5cclxuICAgICAgICBmaXJlRXZlbnQucGFzdGUoZmlyc3RJbnB1dCwgcGFzdGVFdmVudCk7XHJcblxyXG4gICAgICAgIC8vIFNob3VsZCByZWplY3QgZW50aXJlIHBhc3RlIGR1ZSB0byBpbnZhbGlkIGNoYXJhY3RlcnNcclxuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XHJcbiAgICAgICAgaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XHJcbiAgICAgICAgICBleHBlY3QoaW5wdXQpLnRvSGF2ZVZhbHVlKCcnKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpdCgnaGFuZGxlcyB3aGl0ZXNwYWNlIGluIHBhc3RlZCBjb250ZW50JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xyXG4gICAgICAgIGNvbnN0IGZpcnN0SW5wdXQgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94JylbMF07XHJcbiAgICAgICAgZmlyc3RJbnB1dC5mb2N1cygpO1xyXG5cclxuICAgICAgICBjb25zdCBwYXN0ZUV2ZW50ID0gbmV3IENsaXBib2FyZEV2ZW50KCdwYXN0ZScsIHtcclxuICAgICAgICAgIGNsaXBib2FyZERhdGE6IG5ldyBEYXRhVHJhbnNmZXIoKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBwYXN0ZUV2ZW50LmNsaXBib2FyZERhdGE/LnNldERhdGEoJ3RleHQvcGxhaW4nLCAnICAxMjM0NTYgICcpO1xyXG5cclxuICAgICAgICBmaXJlRXZlbnQucGFzdGUoZmlyc3RJbnB1dCwgcGFzdGVFdmVudCk7XHJcblxyXG4gICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICAgICAgZXhwZWN0KG1vY2tPbkNvbXBsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnMTIzNDU2Jyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ2hhbmRsZXMgbmV3bGluZXMgaW4gcGFzdGVkIGNvbnRlbnQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XHJcbiAgICAgICAgY29uc3QgZmlyc3RJbnB1dCA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKVswXTtcclxuICAgICAgICBmaXJzdElucHV0LmZvY3VzKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHBhc3RlRXZlbnQgPSBuZXcgQ2xpcGJvYXJkRXZlbnQoJ3Bhc3RlJywge1xyXG4gICAgICAgICAgY2xpcGJvYXJkRGF0YTogbmV3IERhdGFUcmFuc2ZlcigpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHBhc3RlRXZlbnQuY2xpcGJvYXJkRGF0YT8uc2V0RGF0YSgndGV4dC9wbGFpbicsICcxMjNcXG40NTYnKTtcclxuXHJcbiAgICAgICAgZmlyZUV2ZW50LnBhc3RlKGZpcnN0SW5wdXQsIHBhc3RlRXZlbnQpO1xyXG5cclxuICAgICAgICAvLyBTaG91bGQgcmVqZWN0IGR1ZSB0byBuZXdsaW5lXHJcbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xyXG4gICAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xyXG4gICAgICAgICAgZXhwZWN0KGlucHV0KS50b0hhdmVWYWx1ZSgnJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ2hhbmRsZXMgemVyby13aWR0aCBjaGFyYWN0ZXJzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xyXG4gICAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcclxuXHJcbiAgICAgICAgLy8gVHJ5IHRvIGlucHV0IHplcm8td2lkdGggc3BhY2VcclxuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnMVxcdTIwMEIyJyk7XHJcblxyXG4gICAgICAgIC8vIFNob3VsZCBvbmx5IGFjY2VwdCB0aGUgZGlnaXRzXHJcbiAgICAgICAgZXhwZWN0KGlucHV0c1swXSkudG9IYXZlVmFsdWUoJzEnKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnQnJvd3NlciBDb21wYXRpYmlsaXR5IEVkZ2UgQ2FzZXMnLCAoKSA9PiB7XHJcbiAgICAgIGl0KCdoYW5kbGVzIG1pc3NpbmcgY2xpcGJvYXJkRGF0YSBncmFjZWZ1bGx5JywgKCkgPT4ge1xyXG4gICAgICAgIHJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz4pO1xyXG4gICAgICAgIGNvbnN0IGZpcnN0SW5wdXQgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94JylbMF07XHJcblxyXG4gICAgICAgIC8vIFNpbXVsYXRlIG9sZCBicm93c2VyIHdpdGhvdXQgY2xpcGJvYXJkRGF0YVxyXG4gICAgICAgIGNvbnN0IHBhc3RlRXZlbnQgPSBuZXcgRXZlbnQoJ3Bhc3RlJykgYXMgYW55O1xyXG4gICAgICAgIGZpcmVFdmVudChmaXJzdElucHV0LCBwYXN0ZUV2ZW50KTtcclxuXHJcbiAgICAgICAgLy8gU2hvdWxkIG5vdCBjcmFzaFxyXG4gICAgICAgIGV4cGVjdChmaXJzdElucHV0KS50b0JlSW5UaGVEb2N1bWVudCgpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdoYW5kbGVzIGlucHV0cyB3aXRob3V0IHNlbGVjdCBtZXRob2QnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XHJcbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xyXG5cclxuICAgICAgICAvLyBDb21wb25lbnQgc2hvdWxkIGhhbmRsZSBtaXNzaW5nIHNlbGVjdCBtZXRob2QgZ3JhY2VmdWxseVxyXG4gICAgICAgIC8vIFRoaXMgdGVzdHMgZGVmZW5zaXZlIHByb2dyYW1taW5nIGZvciBvbGRlciBicm93c2Vyc1xyXG4gICAgICAgIGV4cGVjdChpbnB1dHNbMF0pLnRvQmVJblRoZURvY3VtZW50KCk7XHJcbiAgICAgICAgZXhwZWN0KHR5cGVvZiAoaW5wdXRzWzBdIGFzIEhUTUxJbnB1dEVsZW1lbnQpLnNlbGVjdCkudG9CZSgnZnVuY3Rpb24nKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpdCgnaGFuZGxlcyBmb2N1cyBvbiBudWxsIHJlZnMgZ3JhY2VmdWxseScsICgpID0+IHtcclxuICAgICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcclxuXHJcbiAgICAgICAgLy8gQ29tcG9uZW50IHNob3VsZCBoYW5kbGUgbnVsbCByZWZzIGludGVybmFsbHlcclxuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpKS50b0hhdmVMZW5ndGgoNik7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ0hpZ2ggTG9hZCBTY2VuYXJpb3MnLCAoKSA9PiB7XHJcbiAgICAgIGl0KCdoYW5kbGVzIDEwMDArIHJhcGlkIGtleXN0cm9rZXMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XHJcbiAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xyXG5cclxuICAgICAgICAvLyBTaW11bGF0ZSB1c2VyIG1hc2hpbmcga2V5cyByYXBpZGx5XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDAwOyBpKyspIHtcclxuICAgICAgICAgIGNvbnN0IHJhbmRvbUlucHV0ID0gaW5wdXRzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGlucHV0cy5sZW5ndGgpXTtcclxuICAgICAgICAgIGNvbnN0IHJhbmRvbUtleSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgZmlyZUV2ZW50LmNoYW5nZShyYW5kb21JbnB1dCwgeyB0YXJnZXQ6IHsgdmFsdWU6IHJhbmRvbUtleSB9IH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2hvdWxkIHN0aWxsIGJlIGZ1bmN0aW9uYWxcclxuICAgICAgICBleHBlY3QoaW5wdXRzWzBdKS50b0JlSW5UaGVEb2N1bWVudCgpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdoYW5kbGVzIGNvbnRpbnVvdXMgcGFzdGUgb3BlcmF0aW9ucycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcclxuICAgICAgICBjb25zdCBmaXJzdElucHV0ID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpWzBdO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDsgaSsrKSB7XHJcbiAgICAgICAgICBjb25zdCBwYXN0ZUV2ZW50ID0gbmV3IENsaXBib2FyZEV2ZW50KCdwYXN0ZScsIHtcclxuICAgICAgICAgICAgY2xpcGJvYXJkRGF0YTogbmV3IERhdGFUcmFuc2ZlcigpLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBwYXN0ZUV2ZW50LmNsaXBib2FyZERhdGE/LnNldERhdGEoXHJcbiAgICAgICAgICAgICd0ZXh0L3BsYWluJyxcclxuICAgICAgICAgICAgYCR7MTAwMDAwICsgaX1gLnNsaWNlKDAsIDYpXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgZmlyZUV2ZW50LnBhc3RlKGZpcnN0SW5wdXQsIHBhc3RlRXZlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2hvdWxkIGhhbmRsZSB3aXRob3V0IG1lbW9yeSBsZWFrc1xyXG4gICAgICAgIGV4cGVjdChmaXJzdElucHV0KS50b0JlSW5UaGVEb2N1bWVudCgpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdoYW5kbGVzIGFsdGVybmF0aW5nIGZvY3VzIGJldHdlZW4gYWxsIGlucHV0cycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICByZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcclxuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XHJcblxyXG4gICAgICAgIC8vIFJhcGlkbHkgc3dpdGNoIGZvY3VzXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xyXG4gICAgICAgICAgaW5wdXRzW2kgJSA2XS5mb2N1cygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2hvdWxkIGhhbmRsZSBncmFjZWZ1bGx5XHJcbiAgICAgICAgZXhwZWN0KGlucHV0cy5zb21lKChpbnB1dCkgPT4gaW5wdXQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKS50b0JlKFxyXG4gICAgICAgICAgdHJ1ZVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ0FjY2Vzc2liaWxpdHkgVW5kZXIgU3RyZXNzJywgKCkgPT4ge1xyXG4gICAgICBpdCgnbWFpbnRhaW5zIEFSSUEgYXR0cmlidXRlcyBkdXJpbmcgcmFwaWQgc3RhdGUgY2hhbmdlcycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCB7IHJlcmVuZGVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz5cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcclxuICAgICAgICAgIHJlcmVuZGVyKFxyXG4gICAgICAgICAgICA8T1RQSW5wdXRcclxuICAgICAgICAgICAgICBsZW5ndGg9ezZ9XHJcbiAgICAgICAgICAgICAgb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9XHJcbiAgICAgICAgICAgICAgZXJyb3I9e2BFcnJvciAke2l9YH1cclxuICAgICAgICAgICAgLz5cclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgY29uc3QgaW5wdXRzID0gc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpO1xyXG4gICAgICAgICAgaW5wdXRzLmZvckVhY2goKGlucHV0LCBpZHgpID0+IHtcclxuICAgICAgICAgICAgZXhwZWN0KGlucHV0KS50b0hhdmVBdHRyaWJ1dGUoXHJcbiAgICAgICAgICAgICAgJ2FyaWEtbGFiZWwnLFxyXG4gICAgICAgICAgICAgIGBEaWdpdCAke2lkeCArIDF9IG9mIDZgXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGV4cGVjdChpbnB1dCkudG9IYXZlQXR0cmlidXRlKCdhcmlhLWludmFsaWQnLCAndHJ1ZScpO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgcmVyZW5kZXIoXHJcbiAgICAgICAgICAgIDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSBlcnJvcj1cIlwiIC8+XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpdCgnbWFpbnRhaW5zIGxpdmUgcmVnaW9uIHVwZGF0ZXMgZHVyaW5nIGhpZ2ggYWN0aXZpdHknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgcmVuZGVyKDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPik7XHJcbiAgICAgICAgY29uc3QgbGl2ZVJlZ2lvbiA9IHNjcmVlbi5nZXRCeVJvbGUoJ3N0YXR1cycpO1xyXG5cclxuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XHJcbiAgICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzW2ldLCAoaSArIDEpLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgZXhwZWN0KGxpdmVSZWdpb24pLnRvQmVJblRoZURvY3VtZW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlc2NyaWJlKCdDb21wb25lbnQgTGlmZWN5Y2xlIEVkZ2UgQ2FzZXMnLCAoKSA9PiB7XHJcbiAgICAgIGl0KCdoYW5kbGVzIGxlbmd0aCBwcm9wIGNoYW5naW5nIGR5bmFtaWNhbGx5JywgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgcmVyZW5kZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgIDxPVFBJbnB1dCBsZW5ndGg9ezR9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSAvPlxyXG4gICAgICAgICk7XHJcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKSkudG9IYXZlTGVuZ3RoKDQpO1xyXG5cclxuICAgICAgICAvLyBDaGFuZ2luZyBsZW5ndGggcHJvcCBjcmVhdGVzIGEgbmV3IGNvbXBvbmVudCBpbnN0YW5jZVxyXG4gICAgICAgIC8vIFRoZSBjb21wb25lbnQgZG9lc24ndCBkeW5hbWljYWxseSByZXNpemUsIHNvIHRoaXMgdGVzdCBkb2N1bWVudHMgdGhlIGJlaGF2aW9yXHJcbiAgICAgICAgcmVyZW5kZXIoPE9UUElucHV0IGxlbmd0aD17OH0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+KTtcclxuICAgICAgICAvLyBDb21wb25lbnQgd2lsbCBzdGlsbCBoYXZlIDQgaW5wdXRzIGFzIGl0IGRvZXNuJ3QgcmUtaW5pdGlhbGl6ZVxyXG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94JykubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ2hhbmRsZXMgb25Db21wbGV0ZSBjYWxsYmFjayBjaGFuZ2luZycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCBjYWxsYmFjazEgPSBqZXN0LmZuKCk7XHJcbiAgICAgICAgY29uc3QgY2FsbGJhY2syID0gamVzdC5mbigpO1xyXG5cclxuICAgICAgICBjb25zdCB7IHJlcmVuZGVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs0fSBvbkNvbXBsZXRlPXtjYWxsYmFjazF9IC8+XHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XHJcblxyXG4gICAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMF0sICcxMjM0Jyk7XHJcblxyXG4gICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICAgICAgZXhwZWN0KGNhbGxiYWNrMSkudG9IYXZlQmVlbkNhbGxlZCgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBDaGFuZ2UgY2FsbGJhY2tcclxuICAgICAgICByZXJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs0fSBvbkNvbXBsZXRlPXtjYWxsYmFjazJ9IC8+KTtcclxuXHJcbiAgICAgICAgYXdhaXQgdXNlci5jbGVhcihpbnB1dHNbMF0pO1xyXG4gICAgICAgIGF3YWl0IHVzZXIudHlwZShpbnB1dHNbMF0sICc1Njc4Jyk7XHJcblxyXG4gICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICAgICAgZXhwZWN0KGNhbGxiYWNrMikudG9IYXZlQmVlbkNhbGxlZCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdoYW5kbGVzIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycycsICgpID0+IHtcclxuICAgICAgICBjb25zdCBQYXJlbnRDb21wb25lbnQgPSAoeyBjb3VudCB9OiB7IGNvdW50OiBudW1iZXIgfSkgPT4gKFxyXG4gICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgPHNwYW4+e2NvdW50fTwvc3Bhbj5cclxuICAgICAgICAgICAgPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IC8+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjb25zdCB7IHJlcmVuZGVyIH0gPSByZW5kZXIoPFBhcmVudENvbXBvbmVudCBjb3VudD17MH0gLz4pO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDsgaSsrKSB7XHJcbiAgICAgICAgICByZXJlbmRlcig8UGFyZW50Q29tcG9uZW50IGNvdW50PXtpfSAvPik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBlY3Qoc2NyZWVuLmdldEFsbEJ5Um9sZSgndGV4dGJveCcpKS50b0hhdmVMZW5ndGgoNik7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ0Vycm9yIFJlY292ZXJ5JywgKCkgPT4ge1xyXG4gICAgICBpdCgncmVjb3ZlcnMgZnJvbSBlcnJvciBzdGF0ZSB3aGVuIHVzZXIgY29ycmVjdHMgaW5wdXQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyByZXJlbmRlciB9ID0gcmVuZGVyKFxyXG4gICAgICAgICAgPE9UUElucHV0XHJcbiAgICAgICAgICAgIGxlbmd0aD17Nn1cclxuICAgICAgICAgICAgb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9XHJcbiAgICAgICAgICAgIGVycm9yPVwiSW52YWxpZCBjb2RlXCJcclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoJ0ludmFsaWQgY29kZScpKS50b0JlSW5UaGVEb2N1bWVudCgpO1xyXG5cclxuICAgICAgICByZXJlbmRlcig8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gZXJyb3I9XCJcIiAvPik7XHJcblxyXG4gICAgICAgIGV4cGVjdChzY3JlZW4ucXVlcnlCeVRleHQoJ0ludmFsaWQgY29kZScpKS5ub3QudG9CZUluVGhlRG9jdW1lbnQoKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpdCgnYWxsb3dzIHJlLWVudHJ5IGFmdGVyIGVycm9yJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgcmVyZW5kZXIgfSA9IHJlbmRlcihcclxuICAgICAgICAgIDxPVFBJbnB1dCBsZW5ndGg9ezZ9IG9uQ29tcGxldGU9e21vY2tPbkNvbXBsZXRlfSBlcnJvcj1cIlRyeSBhZ2FpblwiIC8+XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmVyZW5kZXIoPE9UUElucHV0IGxlbmd0aD17Nn0gb25Db21wbGV0ZT17bW9ja09uQ29tcGxldGV9IGVycm9yPVwiXCIgLz4pO1xyXG5cclxuICAgICAgICBjb25zdCBpbnB1dHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCd0ZXh0Ym94Jyk7XHJcbiAgICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzEyMzQ1NicpO1xyXG5cclxuICAgICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcclxuICAgICAgICAgIGV4cGVjdChtb2NrT25Db21wbGV0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJzEyMzQ1NicpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdjbGVhcnMgaW5wdXQgd2hlbiBlcnJvciBpcyBzaG93bicsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCB7IHJlcmVuZGVyIH0gPSByZW5kZXIoXHJcbiAgICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gLz5cclxuICAgICAgICApO1xyXG4gICAgICAgIGNvbnN0IGlucHV0cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ3RleHRib3gnKTtcclxuXHJcbiAgICAgICAgYXdhaXQgdXNlci50eXBlKGlucHV0c1swXSwgJzEyMycpO1xyXG5cclxuICAgICAgICAvLyBTaG93IGVycm9yIC0gc2ltdWxhdGluZyBmYWlsZWQgdmVyaWZpY2F0aW9uXHJcbiAgICAgICAgcmVyZW5kZXIoXHJcbiAgICAgICAgICA8T1RQSW5wdXQgbGVuZ3RoPXs2fSBvbkNvbXBsZXRlPXttb2NrT25Db21wbGV0ZX0gZXJyb3I9XCJJbnZhbGlkXCIgLz5cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBVc2VyIHNob3VsZCBiZSBhYmxlIHRvIGNsZWFyIGFuZCByZXRyeVxyXG4gICAgICAgIGF3YWl0IHVzZXIuY2xlYXIoaW5wdXRzWzBdKTtcclxuICAgICAgICBhd2FpdCB1c2VyLnR5cGUoaW5wdXRzWzBdLCAnNDU2Jyk7XHJcblxyXG4gICAgICAgIGV4cGVjdChpbnB1dHNbMF0pLnRvSGF2ZVZhbHVlKCc0Jyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn0pO1xyXG4iXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJ1c2VyIiwidXNlckV2ZW50Iiwic2V0dXAiLCJtb2NrT25Db21wbGV0ZSIsImplc3QiLCJmbiIsIm1vY2tPbkNoYW5nZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwiaXQiLCJyZW5kZXIiLCJPVFBJbnB1dCIsImxlbmd0aCIsIm9uQ29tcGxldGUiLCJpbnB1dHMiLCJzY3JlZW4iLCJnZXRBbGxCeVJvbGUiLCJleHBlY3QiLCJ0b0hhdmVMZW5ndGgiLCJjb250YWluZXIiLCJjbG9zZXN0IiwidG9CZUluVGhlRG9jdW1lbnQiLCJsb2FkaW5nIiwiZm9yRWFjaCIsImlucHV0IiwidG9CZURpc2FibGVkIiwiZXJyb3IiLCJnZXRCeVRleHQiLCJmaXJzdElucHV0IiwidHlwZSIsInRvSGF2ZVZhbHVlIiwidG9IYXZlRm9jdXMiLCJrZXlib2FyZCIsImNsZWFyIiwiZm9jdXMiLCJmaXJlRXZlbnQiLCJjaGFuZ2UiLCJ0YXJnZXQiLCJ2YWx1ZSIsIndhaXRGb3IiLCJwYXN0ZUV2ZW50IiwiQ2xpcGJvYXJkRXZlbnQiLCJjbGlwYm9hcmREYXRhIiwiRGF0YVRyYW5zZmVyIiwic2V0RGF0YSIsInBhc3RlIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJub3QiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwidW5tb3VudCIsImluZGV4IiwidG9IYXZlQXR0cmlidXRlIiwibGl2ZVJlZ2lvbiIsImdldEJ5Um9sZSIsImVycm9yRWxlbWVudCIsInJlbmRlclNweSIsIlRlc3RDb21wb25lbnQiLCJyZXJlbmRlciIsInRvSGF2ZUJlZW5DYWxsZWRUaW1lcyIsInN1Y2Nlc3NDYWxsYmFjayIsImNhbGxiYWNrIiwiaSIsInJlY2VpdmVkQ29kZSIsImNvZGUiLCJ0b0JlIiwidG9UaHJvdyIsImhhc1ZhbHVlcyIsInNvbWUiLCJnZXRBdHRyaWJ1dGUiLCJ1cGRhdGVkSW5wdXRzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiRXZlbnQiLCJzZWxlY3QiLCJyYW5kb21JbnB1dCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInJhbmRvbUtleSIsInRvU3RyaW5nIiwic2xpY2UiLCJkb2N1bWVudCIsImFjdGl2ZUVsZW1lbnQiLCJpZHgiLCJ0b0JlR3JlYXRlclRoYW4iLCJjYWxsYmFjazEiLCJjYWxsYmFjazIiLCJQYXJlbnRDb21wb25lbnQiLCJjb3VudCIsImRpdiIsInNwYW4iLCJxdWVyeUJ5VGV4dCJdLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdDOzs7Ozs4REFFaUI7d0JBQ2lDO2tFQUM3QjtpRUFDRDs7Ozs7O0FBRXJCQSxTQUFTLFlBQVk7SUFDbkIsTUFBTUMsT0FBT0Msa0JBQVMsQ0FBQ0MsS0FBSztJQUM1QixNQUFNQyxpQkFBaUJDLEtBQUtDLEVBQUU7SUFDOUIsTUFBTUMsZUFBZUYsS0FBS0MsRUFBRTtJQUU1QkUsV0FBVztRQUNUSCxLQUFLSSxhQUFhO0lBQ3BCO0lBRUFULFNBQVMsdUJBQXVCO1FBQzlCVSxHQUFHLDBDQUEwQztZQUMzQ0MsSUFBQUEsY0FBTSxnQkFBQyxxQkFBQ0MsaUJBQVE7Z0JBQUNDLFFBQVE7Z0JBQUdDLFlBQVlWOztZQUV4QyxNQUFNVyxTQUFTQyxjQUFNLENBQUNDLFlBQVksQ0FBQztZQUNuQ0MsT0FBT0gsUUFBUUksWUFBWSxDQUFDO1FBQzlCO1FBRUFULEdBQUcsOEJBQThCO1lBQy9CQyxJQUFBQSxjQUFNLGdCQUFDLHFCQUFDQyxp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