beeaf98a426af471537094ae4c5d8e65
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get GraphAlgorithms () {
        return GraphAlgorithms;
    },
    get LRUCache () {
        return LRUCache;
    },
    get MemoryOptimizedOperations () {
        return MemoryOptimizedOperations;
    },
    get OptimizedSorting () {
        return OptimizedSorting;
    },
    get PerformanceAnalytics () {
        return PerformanceAnalytics;
    },
    get PriorityQueue () {
        return PriorityQueue;
    },
    get SearchAlgorithms () {
        return SearchAlgorithms;
    },
    get Trie () {
        return Trie;
    }
});
class PriorityQueue {
    constructor(compareFn){
        this.heap = [];
        this.compareFn = compareFn || ((a, b)=>a < b ? -1 : a > b ? 1 : 0);
    }
    enqueue(item) {
        this.heap.push(item);
        this.heapifyUp(this.heap.length - 1);
    }
    dequeue() {
        if (this.heap.length === 0) return undefined;
        if (this.heap.length === 1) return this.heap.pop();
        const result = this.heap[0];
        this.heap[0] = this.heap.pop();
        this.heapifyDown(0);
        return result;
    }
    peek() {
        return this.heap.length > 0 ? this.heap[0] : undefined;
    }
    size() {
        return this.heap.length;
    }
    isEmpty() {
        return this.heap.length === 0;
    }
    // Legacy methods for backward compatibility
    insert(item, priority) {
        this.heap.push({
            item,
            priority
        });
        this.heapifyUp(this.heap.length - 1);
    }
    extractMax() {
        if (this.heap.length === 0) return null;
        if (this.heap.length === 1) return this.heap.pop().item || this.heap.pop();
        const max = this.heap[0].item || this.heap[0];
        this.heap[0] = this.heap.pop();
        this.heapifyDown(0);
        return max;
    }
    heapifyUp(index) {
        while(index > 0){
            const parentIndex = Math.floor((index - 1) / 2);
            // For min heap: break if parent <= child
            if (this.compareFn(this.heap[parentIndex], this.heap[index]) <= 0) break;
            this.swap(parentIndex, index);
            index = parentIndex;
        }
    }
    heapifyDown(index) {
        while(true){
            let minIndex = index;
            const leftChild = 2 * index + 1;
            const rightChild = 2 * index + 2;
            // For min heap: pick the smaller child
            if (leftChild < this.heap.length && this.compareFn(this.heap[leftChild], this.heap[minIndex]) < 0) {
                minIndex = leftChild;
            }
            if (rightChild < this.heap.length && this.compareFn(this.heap[rightChild], this.heap[minIndex]) < 0) {
                minIndex = rightChild;
            }
            if (minIndex === index) break;
            this.swap(index, minIndex);
            index = minIndex;
        }
    }
    swap(i, j) {
        [this.heap[i], this.heap[j]] = [
            this.heap[j],
            this.heap[i]
        ];
    }
}
class Trie {
    insert(word) {
        let current = this.root;
        for (const char of word.toLowerCase()){
            if (!current.children.has(char)) {
                current.children.set(char, new TrieNode());
            }
            current = current.children.get(char);
        }
        current.isEndOfWord = true;
    }
    search(word) {
        let current = this.root;
        for (const char of word.toLowerCase()){
            if (!current.children.has(char)) return false;
            current = current.children.get(char);
        }
        return current.isEndOfWord;
    }
    startsWith(prefix) {
        let current = this.root;
        for (const char of prefix.toLowerCase()){
            if (!current.children.has(char)) return false;
            current = current.children.get(char);
        }
        return true;
    }
    getWordsWithPrefix(prefix) {
        let current = this.root;
        for (const char of prefix.toLowerCase()){
            if (!current.children.has(char)) return [];
            current = current.children.get(char);
        }
        const words = [];
        this.dfs(current, prefix, words);
        return words;
    }
    findWordsWithPrefix(prefix) {
        return this.getWordsWithPrefix(prefix);
    }
    delete(word) {
        return this.deleteHelper(this.root, word.toLowerCase(), 0);
    }
    deleteHelper(node, word, index) {
        if (index === word.length) {
            if (!node.isEndOfWord) return false;
            node.isEndOfWord = false;
            return node.children.size === 0;
        }
        const char = word[index];
        const childNode = node.children.get(char);
        if (!childNode) return false;
        const shouldDeleteChild = this.deleteHelper(childNode, word, index + 1);
        if (shouldDeleteChild) {
            node.children.delete(char);
            return node.children.size === 0 && !node.isEndOfWord;
        }
        return false;
    }
    dfs(node, currentWord, words) {
        if (node.isEndOfWord) {
            words.push(currentWord);
        }
        for (const [char, childNode] of node.children){
            this.dfs(childNode, currentWord + char, words);
        }
    }
    constructor(){
        this.root = new TrieNode();
    }
}
class TrieNode {
    constructor(){
        this.children = new Map();
        this.isEndOfWord = false;
    }
}
class LRUCache {
    constructor(capacity){
        this.cache = new Map();
        this.capacity = capacity;
        this.head = new Node(null, null);
        this.tail = new Node(null, null);
        this.head.next = this.tail;
        this.tail.prev = this.head;
    }
    get(key) {
        const node = this.cache.get(key);
        if (!node) return undefined;
        this.moveToHead(node);
        return node.value;
    }
    get size() {
        return this.cache.size;
    }
    clear() {
        this.cache.clear();
        this.head.next = this.tail;
        this.tail.prev = this.head;
    }
    put(key, value) {
        const existingNode = this.cache.get(key);
        if (existingNode) {
            existingNode.value = value;
            this.moveToHead(existingNode);
        } else {
            const newNode = new Node(key, value);
            if (this.cache.size >= this.capacity) {
                const lastNode = this.removeTail();
                this.cache.delete(lastNode.key);
            }
            this.cache.set(key, newNode);
            this.addToHead(newNode);
        }
    }
    addToHead(node) {
        node.prev = this.head;
        node.next = this.head.next;
        this.head.next.prev = node;
        this.head.next = node;
    }
    removeNode(node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
    moveToHead(node) {
        this.removeNode(node);
        this.addToHead(node);
    }
    removeTail() {
        const lastNode = this.tail.prev;
        this.removeNode(lastNode);
        return lastNode;
    }
}
class Node {
    constructor(key, value){
        this.prev = null;
        this.next = null;
        this.key = key;
        this.value = value;
    }
}
class SearchAlgorithms {
    /**
   * Binary search - O(log n)
   */ static binarySearch(array, target, compareFn) {
        let left = 0;
        let right = array.length - 1;
        while(left <= right){
            const mid = Math.floor((left + right) / 2);
            const cmp = compareFn(array[mid], target);
            if (cmp === 0) return mid;
            if (cmp < 0) left = mid + 1;
            else right = mid - 1;
        }
        return -1;
    }
    /**
   * Boyer-Moore string search - O(n/m) average case
   */ static boyerMooreSearch(text, pattern) {
        const positions = [];
        const m = pattern.length;
        const n = text.length;
        if (m === 0) return positions;
        const badChar = this.buildBadCharTable(pattern);
        let skip = 0;
        while(skip <= n - m){
            let j = m - 1;
            while(j >= 0 && pattern[j] === text[skip + j]){
                j--;
            }
            if (j < 0) {
                positions.push(skip);
                skip += skip + m < n ? m - badChar[text.charCodeAt(skip + m)] : 1;
            } else {
                skip += Math.max(1, j - badChar[text.charCodeAt(skip + j)]);
            }
        }
        return positions;
    }
    static buildBadCharTable(pattern) {
        const table = new Array(256).fill(-1);
        for(let i = 0; i < pattern.length; i++){
            table[pattern.charCodeAt(i)] = i;
        }
        return table;
    }
    /**
   * Fuzzy search using Levenshtein distance with optimizations
   */ static fuzzySearch(query, candidates, threshold = 0.6) {
        const results = candidates.map((candidate)=>({
                item: candidate,
                score: this.jaroWinklerSimilarity(query.toLowerCase(), candidate.toLowerCase())
            }));
        return results.filter((result)=>result.score >= threshold).sort((a, b)=>b.score - a.score);
    }
    static jaroWinklerSimilarity(s1, s2) {
        const jaro = this.jaroSimilarity(s1, s2);
        const prefixLength = this.commonPrefixLength(s1, s2, 4);
        return jaro + 0.1 * prefixLength * (1 - jaro);
    }
    static jaroSimilarity(s1, s2) {
        if (s1.length === 0 && s2.length === 0) return 1;
        if (s1.length === 0 || s2.length === 0) return 0;
        const matchWindow = Math.floor(Math.max(s1.length, s2.length) / 2) - 1;
        const s1Matches = new Array(s1.length).fill(false);
        const s2Matches = new Array(s2.length).fill(false);
        let matches = 0;
        let transpositions = 0;
        // Find matches
        for(let i = 0; i < s1.length; i++){
            const start = Math.max(0, i - matchWindow);
            const end = Math.min(i + matchWindow + 1, s2.length);
            for(let j = start; j < end; j++){
                if (s2Matches[j] || s1[i] !== s2[j]) continue;
                s1Matches[i] = s2Matches[j] = true;
                matches++;
                break;
            }
        }
        if (matches === 0) return 0;
        // Count transpositions
        let k = 0;
        for(let i = 0; i < s1.length; i++){
            if (!s1Matches[i]) continue;
            while(!s2Matches[k])k++;
            if (s1[i] !== s2[k]) transpositions++;
            k++;
        }
        return (matches / s1.length + matches / s2.length + (matches - transpositions / 2) / matches) / 3;
    }
    static commonPrefixLength(s1, s2, maxLength) {
        let length = 0;
        for(let i = 0; i < Math.min(s1.length, s2.length, maxLength); i++){
            if (s1[i] === s2[i]) length++;
            else break;
        }
        return length;
    }
}
class GraphAlgorithms {
    /**
   * Find shortest path using Dijkstra's algorithm
   */ static dijkstra(graph, start, end) {
        const distances = new Map();
        const previous = new Map();
        const unvisited = new PriorityQueue();
        // Initialize distances
        for (const node of graph.keys()){
            distances.set(node, node === start ? 0 : Infinity);
            previous.set(node, null);
            unvisited.insert(node, node === start ? 0 : -Infinity);
        }
        while(unvisited.size() > 0){
            const current = unvisited.extractMax();
            if (current === end) break;
            if (distances.get(current) === Infinity) break;
            const neighbors = graph.get(current) || [];
            for (const neighbor of neighbors){
                const alt = distances.get(current) + neighbor.weight;
                if (alt < distances.get(neighbor.node)) {
                    distances.set(neighbor.node, alt);
                    previous.set(neighbor.node, current);
                }
            }
        }
        // Reconstruct path
        const path = [];
        let current = end;
        while(current !== null){
            path.unshift(current);
            current = previous.get(current) || null;
        }
        if (path[0] !== start) return null;
        return {
            path,
            distance: distances.get(end)
        };
    }
    /**
   * Detect cycles in directed graph using DFS
   */ static hasCycle(graph) {
        const visited = new Set();
        const recursionStack = new Set();
        for (const node of graph.keys()){
            if (!visited.has(node)) {
                if (this.hasCycleDFS(graph, node, visited, recursionStack)) {
                    return true;
                }
            }
        }
        return false;
    }
    static hasCycleDFS(graph, node, visited, recursionStack) {
        visited.add(node);
        recursionStack.add(node);
        const neighbors = graph.get(node) || [];
        for (const neighbor of neighbors){
            if (!visited.has(neighbor)) {
                if (this.hasCycleDFS(graph, neighbor, visited, recursionStack)) {
                    return true;
                }
            } else if (recursionStack.has(neighbor)) {
                return true;
            }
        }
        recursionStack.delete(node);
        return false;
    }
}
class OptimizedSorting {
    /**
   * Hybrid sorting algorithm that chooses best approach based on data characteristics
   */ static smartSort(array, compareFn) {
        if (array.length <= 1) return [
            ...array
        ];
        const compare = compareFn || ((a, b)=>a < b ? -1 : a > b ? 1 : 0);
        // Choose algorithm based on array characteristics
        if (array.length < 50) {
            return this.insertionSort([
                ...array
            ], compare);
        } else if (this.isNearlySorted(array, compare)) {
            return this.timSort([
                ...array
            ], compare);
        } else if (array.length > 10000) {
            return this.parallelQuickSort([
                ...array
            ], compare);
        } else {
            return this.quickSort([
                ...array
            ], compare);
        }
    }
    static isNearlySorted(array, compare) {
        let inversions = 0;
        for(let i = 0; i < array.length - 1; i++){
            if (compare(array[i], array[i + 1]) > 0) {
                inversions++;
                if (inversions > array.length * 0.1) return false;
            }
        }
        return true;
    }
    static insertionSort(array, compare) {
        for(let i = 1; i < array.length; i++){
            const key = array[i];
            let j = i - 1;
            while(j >= 0 && compare(array[j], key) > 0){
                array[j + 1] = array[j];
                j--;
            }
            array[j + 1] = key;
        }
        return array;
    }
    static quickSort(array, compare) {
        if (array.length <= 1) return array;
        const pivot = array[Math.floor(array.length / 2)];
        const left = array.filter((x)=>compare(x, pivot) < 0);
        const middle = array.filter((x)=>compare(x, pivot) === 0);
        const right = array.filter((x)=>compare(x, pivot) > 0);
        return [
            ...this.quickSort(left, compare),
            ...middle,
            ...this.quickSort(right, compare)
        ];
    }
    static timSort(array, compare) {
        // Simplified TimSort implementation
        const minMerge = 32;
        if (array.length < minMerge) {
            return this.insertionSort(array, compare);
        }
        const mid = Math.floor(array.length / 2);
        const left = this.timSort(array.slice(0, mid), compare);
        const right = this.timSort(array.slice(mid), compare);
        return this.merge(left, right, compare);
    }
    static merge(left, right, compare) {
        const result = [];
        let i = 0, j = 0;
        while(i < left.length && j < right.length){
            if (compare(left[i], right[j]) <= 0) {
                result.push(left[i++]);
            } else {
                result.push(right[j++]);
            }
        }
        return result.concat(left.slice(i)).concat(right.slice(j));
    }
    static parallelQuickSort(array, compare) {
        // Simplified parallel sorting (would use Web Workers in real implementation)
        return this.quickSort(array, compare);
    }
}
class MemoryOptimizedOperations {
    /**
   * Process large datasets in chunks to avoid memory issues
   */ static async processInChunks(data, processor, chunkSize = 1000) {
        const results = [];
        for(let i = 0; i < data.length; i += chunkSize){
            const chunk = data.slice(i, i + chunkSize);
            const chunkResults = processor(chunk);
            results.push(...chunkResults);
            // Allow garbage collection between chunks
            await new Promise((resolve)=>setTimeout(resolve, 0));
        }
        return results;
    }
    /**
   * Virtual scrolling for large lists
   */ static calculateVisibleItems(totalItems, itemHeight, containerHeight, scrollTop, buffer = 5) {
        const visibleCount = Math.ceil(containerHeight / itemHeight);
        const startIndex = Math.max(0, Math.floor(scrollTop / itemHeight) - buffer);
        const endIndex = Math.min(totalItems - 1, startIndex + visibleCount + 2 * buffer);
        const offsetY = startIndex * itemHeight;
        return {
            startIndex,
            endIndex,
            offsetY
        };
    }
}
class PerformanceAnalytics {
    static{
        this.measurements = new Map();
    }
    static measure(name, fn) {
        const start = performance.now();
        const result = fn();
        const end = performance.now();
        if (!this.measurements.has(name)) {
            this.measurements.set(name, []);
        }
        this.measurements.get(name).push(end - start);
        return result;
    }
    static async measureAsync(name, fn) {
        const start = performance.now();
        const result = await fn();
        const end = performance.now();
        if (!this.measurements.has(name)) {
            this.measurements.set(name, []);
        }
        this.measurements.get(name).push(end - start);
        return result;
    }
    static getStats(name) {
        const times = this.measurements.get(name);
        if (!times) return null;
        // Return zeros for empty measurements (after clear)
        if (times.length === 0) {
            return {
                count: 0,
                totalTime: 0,
                averageTime: 0,
                minTime: 0,
                maxTime: 0
            };
        }
        const sum = times.reduce((a, b)=>a + b, 0);
        return {
            count: times.length,
            totalTime: sum,
            averageTime: sum / times.length,
            minTime: Math.min(...times),
            maxTime: Math.max(...times)
        };
    }
    static clearMeasurements(name) {
        if (name) {
            this.measurements.set(name, []);
        } else {
            // Clear all measurements but keep the keys
            for (const key of this.measurements.keys()){
                this.measurements.set(key, []);
            }
        }
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcQS5QXFxPbmVEcml2ZVxcRGVza3RvcFxcZWNoby1tYWluXFxmcm9udGVuZFxcc3JjXFx1dGlsc1xcRFNBVXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xyXG5cclxuLy8gRW5oYW5jZWQgRGF0YSBTdHJ1Y3R1cmVzIGFuZCBBbGdvcml0aG1zIFV0aWxpdHkgZm9yIEJlc3QgUGVyZm9ybWFuY2VcclxuXHJcbi8qKlxyXG4gKiBQcmlvcml0eSBRdWV1ZSBpbXBsZW1lbnRhdGlvbiB1c2luZyBCaW5hcnkgSGVhcFxyXG4gKiBUaW1lIENvbXBsZXhpdHk6IE8obG9nIG4pIGZvciBpbnNlcnQvZXh0cmFjdCwgTygxKSBmb3IgcGVla1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFByaW9yaXR5UXVldWU8VD4ge1xyXG4gIHByaXZhdGUgaGVhcDogVFtdID0gW107XHJcbiAgcHJpdmF0ZSBjb21wYXJlRm46IChhOiBULCBiOiBUKSA9PiBudW1iZXI7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGNvbXBhcmVGbj86IChhOiBULCBiOiBUKSA9PiBudW1iZXIpIHtcclxuICAgIHRoaXMuY29tcGFyZUZuID1cclxuICAgICAgY29tcGFyZUZuIHx8ICgoYTogYW55LCBiOiBhbnkpID0+IChhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMCkpO1xyXG4gIH1cclxuXHJcbiAgZW5xdWV1ZShpdGVtOiBUKTogdm9pZCB7XHJcbiAgICB0aGlzLmhlYXAucHVzaChpdGVtKTtcclxuICAgIHRoaXMuaGVhcGlmeVVwKHRoaXMuaGVhcC5sZW5ndGggLSAxKTtcclxuICB9XHJcblxyXG4gIGRlcXVldWUoKTogVCB8IHVuZGVmaW5lZCB7XHJcbiAgICBpZiAodGhpcy5oZWFwLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIGlmICh0aGlzLmhlYXAubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFwLnBvcCgpITtcclxuXHJcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmhlYXBbMF07XHJcbiAgICB0aGlzLmhlYXBbMF0gPSB0aGlzLmhlYXAucG9wKCkhO1xyXG4gICAgdGhpcy5oZWFwaWZ5RG93bigwKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBwZWVrKCk6IFQgfCB1bmRlZmluZWQge1xyXG4gICAgcmV0dXJuIHRoaXMuaGVhcC5sZW5ndGggPiAwID8gdGhpcy5oZWFwWzBdIDogdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgc2l6ZSgpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuaGVhcC5sZW5ndGg7XHJcbiAgfVxyXG5cclxuICBpc0VtcHR5KCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMuaGVhcC5sZW5ndGggPT09IDA7XHJcbiAgfVxyXG5cclxuICAvLyBMZWdhY3kgbWV0aG9kcyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxyXG4gIGluc2VydChpdGVtOiBULCBwcmlvcml0eTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICB0aGlzLmhlYXAucHVzaCh7IGl0ZW0sIHByaW9yaXR5IH0gYXMgYW55KTtcclxuICAgIHRoaXMuaGVhcGlmeVVwKHRoaXMuaGVhcC5sZW5ndGggLSAxKTtcclxuICB9XHJcblxyXG4gIGV4dHJhY3RNYXgoKTogVCB8IG51bGwge1xyXG4gICAgaWYgKHRoaXMuaGVhcC5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xyXG4gICAgaWYgKHRoaXMuaGVhcC5sZW5ndGggPT09IDEpXHJcbiAgICAgIHJldHVybiAodGhpcy5oZWFwLnBvcCgpIGFzIGFueSkuaXRlbSB8fCB0aGlzLmhlYXAucG9wKCkhO1xyXG5cclxuICAgIGNvbnN0IG1heCA9ICh0aGlzLmhlYXBbMF0gYXMgYW55KS5pdGVtIHx8IHRoaXMuaGVhcFswXTtcclxuICAgIHRoaXMuaGVhcFswXSA9IHRoaXMuaGVhcC5wb3AoKSE7XHJcbiAgICB0aGlzLmhlYXBpZnlEb3duKDApO1xyXG4gICAgcmV0dXJuIG1heDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgaGVhcGlmeVVwKGluZGV4OiBudW1iZXIpOiB2b2lkIHtcclxuICAgIHdoaWxlIChpbmRleCA+IDApIHtcclxuICAgICAgY29uc3QgcGFyZW50SW5kZXggPSBNYXRoLmZsb29yKChpbmRleCAtIDEpIC8gMik7XHJcbiAgICAgIC8vIEZvciBtaW4gaGVhcDogYnJlYWsgaWYgcGFyZW50IDw9IGNoaWxkXHJcbiAgICAgIGlmICh0aGlzLmNvbXBhcmVGbih0aGlzLmhlYXBbcGFyZW50SW5kZXhdLCB0aGlzLmhlYXBbaW5kZXhdKSA8PSAwKSBicmVhaztcclxuICAgICAgdGhpcy5zd2FwKHBhcmVudEluZGV4LCBpbmRleCk7XHJcbiAgICAgIGluZGV4ID0gcGFyZW50SW5kZXg7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGhlYXBpZnlEb3duKGluZGV4OiBudW1iZXIpOiB2b2lkIHtcclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgIGxldCBtaW5JbmRleCA9IGluZGV4O1xyXG4gICAgICBjb25zdCBsZWZ0Q2hpbGQgPSAyICogaW5kZXggKyAxO1xyXG4gICAgICBjb25zdCByaWdodENoaWxkID0gMiAqIGluZGV4ICsgMjtcclxuXHJcbiAgICAgIC8vIEZvciBtaW4gaGVhcDogcGljayB0aGUgc21hbGxlciBjaGlsZFxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgbGVmdENoaWxkIDwgdGhpcy5oZWFwLmxlbmd0aCAmJlxyXG4gICAgICAgIHRoaXMuY29tcGFyZUZuKHRoaXMuaGVhcFtsZWZ0Q2hpbGRdLCB0aGlzLmhlYXBbbWluSW5kZXhdKSA8IDBcclxuICAgICAgKSB7XHJcbiAgICAgICAgbWluSW5kZXggPSBsZWZ0Q2hpbGQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChcclxuICAgICAgICByaWdodENoaWxkIDwgdGhpcy5oZWFwLmxlbmd0aCAmJlxyXG4gICAgICAgIHRoaXMuY29tcGFyZUZuKHRoaXMuaGVhcFtyaWdodENoaWxkXSwgdGhpcy5oZWFwW21pbkluZGV4XSkgPCAwXHJcbiAgICAgICkge1xyXG4gICAgICAgIG1pbkluZGV4ID0gcmlnaHRDaGlsZDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG1pbkluZGV4ID09PSBpbmRleCkgYnJlYWs7XHJcbiAgICAgIHRoaXMuc3dhcChpbmRleCwgbWluSW5kZXgpO1xyXG4gICAgICBpbmRleCA9IG1pbkluZGV4O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzd2FwKGk6IG51bWJlciwgajogbnVtYmVyKTogdm9pZCB7XHJcbiAgICBbdGhpcy5oZWFwW2ldLCB0aGlzLmhlYXBbal1dID0gW3RoaXMuaGVhcFtqXSwgdGhpcy5oZWFwW2ldXTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUcmllIGRhdGEgc3RydWN0dXJlIGZvciBlZmZpY2llbnQgc3RyaW5nIG9wZXJhdGlvbnNcclxuICogVGltZSBDb21wbGV4aXR5OiBPKG0pIGZvciBpbnNlcnQvc2VhcmNoIHdoZXJlIG0gaXMgc3RyaW5nIGxlbmd0aFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFRyaWUge1xyXG4gIHByaXZhdGUgcm9vdDogVHJpZU5vZGUgPSBuZXcgVHJpZU5vZGUoKTtcclxuXHJcbiAgaW5zZXJ0KHdvcmQ6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgbGV0IGN1cnJlbnQgPSB0aGlzLnJvb3Q7XHJcbiAgICBmb3IgKGNvbnN0IGNoYXIgb2Ygd29yZC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgIGlmICghY3VycmVudC5jaGlsZHJlbi5oYXMoY2hhcikpIHtcclxuICAgICAgICBjdXJyZW50LmNoaWxkcmVuLnNldChjaGFyLCBuZXcgVHJpZU5vZGUoKSk7XHJcbiAgICAgIH1cclxuICAgICAgY3VycmVudCA9IGN1cnJlbnQuY2hpbGRyZW4uZ2V0KGNoYXIpITtcclxuICAgIH1cclxuICAgIGN1cnJlbnQuaXNFbmRPZldvcmQgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgc2VhcmNoKHdvcmQ6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgbGV0IGN1cnJlbnQgPSB0aGlzLnJvb3Q7XHJcbiAgICBmb3IgKGNvbnN0IGNoYXIgb2Ygd29yZC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgIGlmICghY3VycmVudC5jaGlsZHJlbi5oYXMoY2hhcikpIHJldHVybiBmYWxzZTtcclxuICAgICAgY3VycmVudCA9IGN1cnJlbnQuY2hpbGRyZW4uZ2V0KGNoYXIpITtcclxuICAgIH1cclxuICAgIHJldHVybiBjdXJyZW50LmlzRW5kT2ZXb3JkO1xyXG4gIH1cclxuXHJcbiAgc3RhcnRzV2l0aChwcmVmaXg6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgbGV0IGN1cnJlbnQgPSB0aGlzLnJvb3Q7XHJcbiAgICBmb3IgKGNvbnN0IGNoYXIgb2YgcHJlZml4LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgaWYgKCFjdXJyZW50LmNoaWxkcmVuLmhhcyhjaGFyKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBjdXJyZW50ID0gY3VycmVudC5jaGlsZHJlbi5nZXQoY2hhcikhO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBnZXRXb3Jkc1dpdGhQcmVmaXgocHJlZml4OiBzdHJpbmcpOiBzdHJpbmdbXSB7XHJcbiAgICBsZXQgY3VycmVudCA9IHRoaXMucm9vdDtcclxuICAgIGZvciAoY29uc3QgY2hhciBvZiBwcmVmaXgudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICBpZiAoIWN1cnJlbnQuY2hpbGRyZW4uaGFzKGNoYXIpKSByZXR1cm4gW107XHJcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmNoaWxkcmVuLmdldChjaGFyKSE7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgd29yZHM6IHN0cmluZ1tdID0gW107XHJcbiAgICB0aGlzLmRmcyhjdXJyZW50LCBwcmVmaXgsIHdvcmRzKTtcclxuICAgIHJldHVybiB3b3JkcztcclxuICB9XHJcblxyXG4gIGZpbmRXb3Jkc1dpdGhQcmVmaXgocHJlZml4OiBzdHJpbmcpOiBzdHJpbmdbXSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRXb3Jkc1dpdGhQcmVmaXgocHJlZml4KTtcclxuICB9XHJcblxyXG4gIGRlbGV0ZSh3b3JkOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLmRlbGV0ZUhlbHBlcih0aGlzLnJvb3QsIHdvcmQudG9Mb3dlckNhc2UoKSwgMCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGRlbGV0ZUhlbHBlcihub2RlOiBUcmllTm9kZSwgd29yZDogc3RyaW5nLCBpbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICBpZiAoaW5kZXggPT09IHdvcmQubGVuZ3RoKSB7XHJcbiAgICAgIGlmICghbm9kZS5pc0VuZE9mV29yZCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBub2RlLmlzRW5kT2ZXb3JkID0gZmFsc2U7XHJcbiAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLnNpemUgPT09IDA7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY2hhciA9IHdvcmRbaW5kZXhdO1xyXG4gICAgY29uc3QgY2hpbGROb2RlID0gbm9kZS5jaGlsZHJlbi5nZXQoY2hhcik7XHJcbiAgICBpZiAoIWNoaWxkTm9kZSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIGNvbnN0IHNob3VsZERlbGV0ZUNoaWxkID0gdGhpcy5kZWxldGVIZWxwZXIoY2hpbGROb2RlLCB3b3JkLCBpbmRleCArIDEpO1xyXG5cclxuICAgIGlmIChzaG91bGREZWxldGVDaGlsZCkge1xyXG4gICAgICBub2RlLmNoaWxkcmVuLmRlbGV0ZShjaGFyKTtcclxuICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4uc2l6ZSA9PT0gMCAmJiAhbm9kZS5pc0VuZE9mV29yZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGRmcyhub2RlOiBUcmllTm9kZSwgY3VycmVudFdvcmQ6IHN0cmluZywgd29yZHM6IHN0cmluZ1tdKTogdm9pZCB7XHJcbiAgICBpZiAobm9kZS5pc0VuZE9mV29yZCkge1xyXG4gICAgICB3b3Jkcy5wdXNoKGN1cnJlbnRXb3JkKTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGNvbnN0IFtjaGFyLCBjaGlsZE5vZGVdIG9mIG5vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgdGhpcy5kZnMoY2hpbGROb2RlLCBjdXJyZW50V29yZCArIGNoYXIsIHdvcmRzKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIFRyaWVOb2RlIHtcclxuICBjaGlsZHJlbjogTWFwPHN0cmluZywgVHJpZU5vZGU+ID0gbmV3IE1hcCgpO1xyXG4gIGlzRW5kT2ZXb3JkOiBib29sZWFuID0gZmFsc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMUlUgQ2FjaGUgaW1wbGVtZW50YXRpb24gdXNpbmcgSGFzaE1hcCArIERvdWJseSBMaW5rZWQgTGlzdFxyXG4gKiBUaW1lIENvbXBsZXhpdHk6IE8oMSkgZm9yIGdldC9wdXQgb3BlcmF0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExSVUNhY2hlPEssIFY+IHtcclxuICBwcml2YXRlIGNhcGFjaXR5OiBudW1iZXI7XHJcbiAgcHJpdmF0ZSBjYWNoZTogTWFwPEssIE5vZGU8SywgVj4+ID0gbmV3IE1hcCgpO1xyXG4gIHByaXZhdGUgaGVhZDogTm9kZTxLLCBWPjtcclxuICBwcml2YXRlIHRhaWw6IE5vZGU8SywgVj47XHJcblxyXG4gIGNvbnN0cnVjdG9yKGNhcGFjaXR5OiBudW1iZXIpIHtcclxuICAgIHRoaXMuY2FwYWNpdHkgPSBjYXBhY2l0eTtcclxuICAgIHRoaXMuaGVhZCA9IG5ldyBOb2RlKG51bGwgYXMgYW55LCBudWxsIGFzIGFueSk7XHJcbiAgICB0aGlzLnRhaWwgPSBuZXcgTm9kZShudWxsIGFzIGFueSwgbnVsbCBhcyBhbnkpO1xyXG4gICAgdGhpcy5oZWFkLm5leHQgPSB0aGlzLnRhaWw7XHJcbiAgICB0aGlzLnRhaWwucHJldiA9IHRoaXMuaGVhZDtcclxuICB9XHJcblxyXG4gIGdldChrZXk6IEspOiBWIHwgdW5kZWZpbmVkIHtcclxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmNhY2hlLmdldChrZXkpO1xyXG4gICAgaWYgKCFub2RlKSByZXR1cm4gdW5kZWZpbmVkO1xyXG5cclxuICAgIHRoaXMubW92ZVRvSGVhZChub2RlKTtcclxuICAgIHJldHVybiBub2RlLnZhbHVlO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHNpemUoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmNhY2hlLnNpemU7XHJcbiAgfVxyXG5cclxuICBjbGVhcigpOiB2b2lkIHtcclxuICAgIHRoaXMuY2FjaGUuY2xlYXIoKTtcclxuICAgIHRoaXMuaGVhZC5uZXh0ID0gdGhpcy50YWlsO1xyXG4gICAgdGhpcy50YWlsLnByZXYgPSB0aGlzLmhlYWQ7XHJcbiAgfVxyXG5cclxuICBwdXQoa2V5OiBLLCB2YWx1ZTogVik6IHZvaWQge1xyXG4gICAgY29uc3QgZXhpc3RpbmdOb2RlID0gdGhpcy5jYWNoZS5nZXQoa2V5KTtcclxuXHJcbiAgICBpZiAoZXhpc3RpbmdOb2RlKSB7XHJcbiAgICAgIGV4aXN0aW5nTm9kZS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICB0aGlzLm1vdmVUb0hlYWQoZXhpc3RpbmdOb2RlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IG5ld05vZGUgPSBuZXcgTm9kZShrZXksIHZhbHVlKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLmNhY2hlLnNpemUgPj0gdGhpcy5jYXBhY2l0eSkge1xyXG4gICAgICAgIGNvbnN0IGxhc3ROb2RlID0gdGhpcy5yZW1vdmVUYWlsKCk7XHJcbiAgICAgICAgdGhpcy5jYWNoZS5kZWxldGUobGFzdE5vZGUua2V5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCBuZXdOb2RlKTtcclxuICAgICAgdGhpcy5hZGRUb0hlYWQobmV3Tm9kZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFkZFRvSGVhZChub2RlOiBOb2RlPEssIFY+KTogdm9pZCB7XHJcbiAgICBub2RlLnByZXYgPSB0aGlzLmhlYWQ7XHJcbiAgICBub2RlLm5leHQgPSB0aGlzLmhlYWQubmV4dDtcclxuICAgIHRoaXMuaGVhZC5uZXh0IS5wcmV2ID0gbm9kZTtcclxuICAgIHRoaXMuaGVhZC5uZXh0ID0gbm9kZTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcmVtb3ZlTm9kZShub2RlOiBOb2RlPEssIFY+KTogdm9pZCB7XHJcbiAgICBub2RlLnByZXYhLm5leHQgPSBub2RlLm5leHQ7XHJcbiAgICBub2RlLm5leHQhLnByZXYgPSBub2RlLnByZXY7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIG1vdmVUb0hlYWQobm9kZTogTm9kZTxLLCBWPik6IHZvaWQge1xyXG4gICAgdGhpcy5yZW1vdmVOb2RlKG5vZGUpO1xyXG4gICAgdGhpcy5hZGRUb0hlYWQobm9kZSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHJlbW92ZVRhaWwoKTogTm9kZTxLLCBWPiB7XHJcbiAgICBjb25zdCBsYXN0Tm9kZSA9IHRoaXMudGFpbC5wcmV2ITtcclxuICAgIHRoaXMucmVtb3ZlTm9kZShsYXN0Tm9kZSk7XHJcbiAgICByZXR1cm4gbGFzdE5vZGU7XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBOb2RlPEssIFY+IHtcclxuICBrZXk6IEs7XHJcbiAgdmFsdWU6IFY7XHJcbiAgcHJldjogTm9kZTxLLCBWPiB8IG51bGwgPSBudWxsO1xyXG4gIG5leHQ6IE5vZGU8SywgVj4gfCBudWxsID0gbnVsbDtcclxuXHJcbiAgY29uc3RydWN0b3Ioa2V5OiBLLCB2YWx1ZTogVikge1xyXG4gICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQWR2YW5jZWQgU2VhcmNoIEFsZ29yaXRobXNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBTZWFyY2hBbGdvcml0aG1zIHtcclxuICAvKipcclxuICAgKiBCaW5hcnkgc2VhcmNoIC0gTyhsb2cgbilcclxuICAgKi9cclxuICBzdGF0aWMgYmluYXJ5U2VhcmNoPFQ+KFxyXG4gICAgYXJyYXk6IFRbXSxcclxuICAgIHRhcmdldDogVCxcclxuICAgIGNvbXBhcmVGbjogKGE6IFQsIGI6IFQpID0+IG51bWJlclxyXG4gICk6IG51bWJlciB7XHJcbiAgICBsZXQgbGVmdCA9IDA7XHJcbiAgICBsZXQgcmlnaHQgPSBhcnJheS5sZW5ndGggLSAxO1xyXG5cclxuICAgIHdoaWxlIChsZWZ0IDw9IHJpZ2h0KSB7XHJcbiAgICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKGxlZnQgKyByaWdodCkgLyAyKTtcclxuICAgICAgY29uc3QgY21wID0gY29tcGFyZUZuKGFycmF5W21pZF0sIHRhcmdldCk7XHJcblxyXG4gICAgICBpZiAoY21wID09PSAwKSByZXR1cm4gbWlkO1xyXG4gICAgICBpZiAoY21wIDwgMCkgbGVmdCA9IG1pZCArIDE7XHJcbiAgICAgIGVsc2UgcmlnaHQgPSBtaWQgLSAxO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAtMTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJveWVyLU1vb3JlIHN0cmluZyBzZWFyY2ggLSBPKG4vbSkgYXZlcmFnZSBjYXNlXHJcbiAgICovXHJcbiAgc3RhdGljIGJveWVyTW9vcmVTZWFyY2godGV4dDogc3RyaW5nLCBwYXR0ZXJuOiBzdHJpbmcpOiBudW1iZXJbXSB7XHJcbiAgICBjb25zdCBwb3NpdGlvbnM6IG51bWJlcltdID0gW107XHJcbiAgICBjb25zdCBtID0gcGF0dGVybi5sZW5ndGg7XHJcbiAgICBjb25zdCBuID0gdGV4dC5sZW5ndGg7XHJcblxyXG4gICAgaWYgKG0gPT09IDApIHJldHVybiBwb3NpdGlvbnM7XHJcblxyXG4gICAgY29uc3QgYmFkQ2hhciA9IHRoaXMuYnVpbGRCYWRDaGFyVGFibGUocGF0dGVybik7XHJcblxyXG4gICAgbGV0IHNraXAgPSAwO1xyXG4gICAgd2hpbGUgKHNraXAgPD0gbiAtIG0pIHtcclxuICAgICAgbGV0IGogPSBtIC0gMTtcclxuXHJcbiAgICAgIHdoaWxlIChqID49IDAgJiYgcGF0dGVybltqXSA9PT0gdGV4dFtza2lwICsgal0pIHtcclxuICAgICAgICBqLS07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChqIDwgMCkge1xyXG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHNraXApO1xyXG4gICAgICAgIHNraXAgKz0gc2tpcCArIG0gPCBuID8gbSAtIGJhZENoYXJbdGV4dC5jaGFyQ29kZUF0KHNraXAgKyBtKV0gOiAxO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNraXAgKz0gTWF0aC5tYXgoMSwgaiAtIGJhZENoYXJbdGV4dC5jaGFyQ29kZUF0KHNraXAgKyBqKV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBvc2l0aW9ucztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RhdGljIGJ1aWxkQmFkQ2hhclRhYmxlKHBhdHRlcm46IHN0cmluZyk6IG51bWJlcltdIHtcclxuICAgIGNvbnN0IHRhYmxlID0gbmV3IEFycmF5KDI1NikuZmlsbCgtMSk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdGFibGVbcGF0dGVybi5jaGFyQ29kZUF0KGkpXSA9IGk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFibGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGdXp6eSBzZWFyY2ggdXNpbmcgTGV2ZW5zaHRlaW4gZGlzdGFuY2Ugd2l0aCBvcHRpbWl6YXRpb25zXHJcbiAgICovXHJcbiAgc3RhdGljIGZ1enp5U2VhcmNoKFxyXG4gICAgcXVlcnk6IHN0cmluZyxcclxuICAgIGNhbmRpZGF0ZXM6IHN0cmluZ1tdLFxyXG4gICAgdGhyZXNob2xkOiBudW1iZXIgPSAwLjZcclxuICApOiBBcnJheTx7IGl0ZW06IHN0cmluZzsgc2NvcmU6IG51bWJlciB9PiB7XHJcbiAgICBjb25zdCByZXN1bHRzID0gY2FuZGlkYXRlcy5tYXAoKGNhbmRpZGF0ZSkgPT4gKHtcclxuICAgICAgaXRlbTogY2FuZGlkYXRlLFxyXG4gICAgICBzY29yZTogdGhpcy5qYXJvV2lua2xlclNpbWlsYXJpdHkoXHJcbiAgICAgICAgcXVlcnkudG9Mb3dlckNhc2UoKSxcclxuICAgICAgICBjYW5kaWRhdGUudG9Mb3dlckNhc2UoKVxyXG4gICAgICApLFxyXG4gICAgfSkpO1xyXG5cclxuICAgIHJldHVybiByZXN1bHRzXHJcbiAgICAgIC5maWx0ZXIoKHJlc3VsdCkgPT4gcmVzdWx0LnNjb3JlID49IHRocmVzaG9sZClcclxuICAgICAgLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RhdGljIGphcm9XaW5rbGVyU2ltaWxhcml0eShzMTogc3RyaW5nLCBzMjogc3RyaW5nKTogbnVtYmVyIHtcclxuICAgIGNvbnN0IGphcm8gPSB0aGlzLmphcm9TaW1pbGFyaXR5KHMxLCBzMik7XHJcbiAgICBjb25zdCBwcmVmaXhMZW5ndGggPSB0aGlzLmNvbW1vblByZWZpeExlbmd0aChzMSwgczIsIDQpO1xyXG4gICAgcmV0dXJuIGphcm8gKyAwLjEgKiBwcmVmaXhMZW5ndGggKiAoMSAtIGphcm8pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdGF0aWMgamFyb1NpbWlsYXJpdHkoczE6IHN0cmluZywgczI6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgICBpZiAoczEubGVuZ3RoID09PSAwICYmIHMyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDE7XHJcbiAgICBpZiAoczEubGVuZ3RoID09PSAwIHx8IHMyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7XHJcblxyXG4gICAgY29uc3QgbWF0Y2hXaW5kb3cgPSBNYXRoLmZsb29yKE1hdGgubWF4KHMxLmxlbmd0aCwgczIubGVuZ3RoKSAvIDIpIC0gMTtcclxuICAgIGNvbnN0IHMxTWF0Y2hlcyA9IG5ldyBBcnJheShzMS5sZW5ndGgpLmZpbGwoZmFsc2UpO1xyXG4gICAgY29uc3QgczJNYXRjaGVzID0gbmV3IEFycmF5KHMyLmxlbmd0aCkuZmlsbChmYWxzZSk7XHJcblxyXG4gICAgbGV0IG1hdGNoZXMgPSAwO1xyXG4gICAgbGV0IHRyYW5zcG9zaXRpb25zID0gMDtcclxuXHJcbiAgICAvLyBGaW5kIG1hdGNoZXNcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgczEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heCgwLCBpIC0gbWF0Y2hXaW5kb3cpO1xyXG4gICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihpICsgbWF0Y2hXaW5kb3cgKyAxLCBzMi5sZW5ndGgpO1xyXG5cclxuICAgICAgZm9yIChsZXQgaiA9IHN0YXJ0OyBqIDwgZW5kOyBqKyspIHtcclxuICAgICAgICBpZiAoczJNYXRjaGVzW2pdIHx8IHMxW2ldICE9PSBzMltqXSkgY29udGludWU7XHJcbiAgICAgICAgczFNYXRjaGVzW2ldID0gczJNYXRjaGVzW2pdID0gdHJ1ZTtcclxuICAgICAgICBtYXRjaGVzKys7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAobWF0Y2hlcyA9PT0gMCkgcmV0dXJuIDA7XHJcblxyXG4gICAgLy8gQ291bnQgdHJhbnNwb3NpdGlvbnNcclxuICAgIGxldCBrID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgczEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKCFzMU1hdGNoZXNbaV0pIGNvbnRpbnVlO1xyXG4gICAgICB3aGlsZSAoIXMyTWF0Y2hlc1trXSkgaysrO1xyXG4gICAgICBpZiAoczFbaV0gIT09IHMyW2tdKSB0cmFuc3Bvc2l0aW9ucysrO1xyXG4gICAgICBrKys7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgKG1hdGNoZXMgLyBzMS5sZW5ndGggK1xyXG4gICAgICAgIG1hdGNoZXMgLyBzMi5sZW5ndGggK1xyXG4gICAgICAgIChtYXRjaGVzIC0gdHJhbnNwb3NpdGlvbnMgLyAyKSAvIG1hdGNoZXMpIC9cclxuICAgICAgM1xyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RhdGljIGNvbW1vblByZWZpeExlbmd0aChcclxuICAgIHMxOiBzdHJpbmcsXHJcbiAgICBzMjogc3RyaW5nLFxyXG4gICAgbWF4TGVuZ3RoOiBudW1iZXJcclxuICApOiBudW1iZXIge1xyXG4gICAgbGV0IGxlbmd0aCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWluKHMxLmxlbmd0aCwgczIubGVuZ3RoLCBtYXhMZW5ndGgpOyBpKyspIHtcclxuICAgICAgaWYgKHMxW2ldID09PSBzMltpXSkgbGVuZ3RoKys7XHJcbiAgICAgIGVsc2UgYnJlYWs7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVuZ3RoO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdyYXBoIGFsZ29yaXRobXMgZm9yIHJlbGF0aW9uc2hpcCBhbmQgbmV0d29yayBhbmFseXNpc1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEdyYXBoQWxnb3JpdGhtcyB7XHJcbiAgLyoqXHJcbiAgICogRmluZCBzaG9ydGVzdCBwYXRoIHVzaW5nIERpamtzdHJhJ3MgYWxnb3JpdGhtXHJcbiAgICovXHJcbiAgc3RhdGljIGRpamtzdHJhPFQ+KFxyXG4gICAgZ3JhcGg6IE1hcDxULCBBcnJheTx7IG5vZGU6IFQ7IHdlaWdodDogbnVtYmVyIH0+PixcclxuICAgIHN0YXJ0OiBULFxyXG4gICAgZW5kOiBUXHJcbiAgKTogeyBwYXRoOiBUW107IGRpc3RhbmNlOiBudW1iZXIgfSB8IG51bGwge1xyXG4gICAgY29uc3QgZGlzdGFuY2VzID0gbmV3IE1hcDxULCBudW1iZXI+KCk7XHJcbiAgICBjb25zdCBwcmV2aW91cyA9IG5ldyBNYXA8VCwgVCB8IG51bGw+KCk7XHJcbiAgICBjb25zdCB1bnZpc2l0ZWQgPSBuZXcgUHJpb3JpdHlRdWV1ZTxUPigpO1xyXG5cclxuICAgIC8vIEluaXRpYWxpemUgZGlzdGFuY2VzXHJcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgZ3JhcGgua2V5cygpKSB7XHJcbiAgICAgIGRpc3RhbmNlcy5zZXQobm9kZSwgbm9kZSA9PT0gc3RhcnQgPyAwIDogSW5maW5pdHkpO1xyXG4gICAgICBwcmV2aW91cy5zZXQobm9kZSwgbnVsbCk7XHJcbiAgICAgIHVudmlzaXRlZC5pbnNlcnQobm9kZSwgbm9kZSA9PT0gc3RhcnQgPyAwIDogLUluZmluaXR5KTtcclxuICAgIH1cclxuXHJcbiAgICB3aGlsZSAodW52aXNpdGVkLnNpemUoKSA+IDApIHtcclxuICAgICAgY29uc3QgY3VycmVudCA9IHVudmlzaXRlZC5leHRyYWN0TWF4KCkhO1xyXG5cclxuICAgICAgaWYgKGN1cnJlbnQgPT09IGVuZCkgYnJlYWs7XHJcbiAgICAgIGlmIChkaXN0YW5jZXMuZ2V0KGN1cnJlbnQpID09PSBJbmZpbml0eSkgYnJlYWs7XHJcblxyXG4gICAgICBjb25zdCBuZWlnaGJvcnMgPSBncmFwaC5nZXQoY3VycmVudCkgfHwgW107XHJcbiAgICAgIGZvciAoY29uc3QgbmVpZ2hib3Igb2YgbmVpZ2hib3JzKSB7XHJcbiAgICAgICAgY29uc3QgYWx0ID0gZGlzdGFuY2VzLmdldChjdXJyZW50KSEgKyBuZWlnaGJvci53ZWlnaHQ7XHJcbiAgICAgICAgaWYgKGFsdCA8IGRpc3RhbmNlcy5nZXQobmVpZ2hib3Iubm9kZSkhKSB7XHJcbiAgICAgICAgICBkaXN0YW5jZXMuc2V0KG5laWdoYm9yLm5vZGUsIGFsdCk7XHJcbiAgICAgICAgICBwcmV2aW91cy5zZXQobmVpZ2hib3Iubm9kZSwgY3VycmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVjb25zdHJ1Y3QgcGF0aFxyXG4gICAgY29uc3QgcGF0aDogVFtdID0gW107XHJcbiAgICBsZXQgY3VycmVudDogVCB8IG51bGwgPSBlbmQ7XHJcbiAgICB3aGlsZSAoY3VycmVudCAhPT0gbnVsbCkge1xyXG4gICAgICBwYXRoLnVuc2hpZnQoY3VycmVudCk7XHJcbiAgICAgIGN1cnJlbnQgPSBwcmV2aW91cy5nZXQoY3VycmVudCkgfHwgbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocGF0aFswXSAhPT0gc3RhcnQpIHJldHVybiBudWxsO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHBhdGgsXHJcbiAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZXMuZ2V0KGVuZCkhLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVjdCBjeWNsZXMgaW4gZGlyZWN0ZWQgZ3JhcGggdXNpbmcgREZTXHJcbiAgICovXHJcbiAgc3RhdGljIGhhc0N5Y2xlPFQ+KGdyYXBoOiBNYXA8VCwgVFtdPik6IGJvb2xlYW4ge1xyXG4gICAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQ8VD4oKTtcclxuICAgIGNvbnN0IHJlY3Vyc2lvblN0YWNrID0gbmV3IFNldDxUPigpO1xyXG5cclxuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBncmFwaC5rZXlzKCkpIHtcclxuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhub2RlKSkge1xyXG4gICAgICAgIGlmICh0aGlzLmhhc0N5Y2xlREZTKGdyYXBoLCBub2RlLCB2aXNpdGVkLCByZWN1cnNpb25TdGFjaykpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RhdGljIGhhc0N5Y2xlREZTPFQ+KFxyXG4gICAgZ3JhcGg6IE1hcDxULCBUW10+LFxyXG4gICAgbm9kZTogVCxcclxuICAgIHZpc2l0ZWQ6IFNldDxUPixcclxuICAgIHJlY3Vyc2lvblN0YWNrOiBTZXQ8VD5cclxuICApOiBib29sZWFuIHtcclxuICAgIHZpc2l0ZWQuYWRkKG5vZGUpO1xyXG4gICAgcmVjdXJzaW9uU3RhY2suYWRkKG5vZGUpO1xyXG5cclxuICAgIGNvbnN0IG5laWdoYm9ycyA9IGdyYXBoLmdldChub2RlKSB8fCBbXTtcclxuICAgIGZvciAoY29uc3QgbmVpZ2hib3Igb2YgbmVpZ2hib3JzKSB7XHJcbiAgICAgIGlmICghdmlzaXRlZC5oYXMobmVpZ2hib3IpKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzQ3ljbGVERlMoZ3JhcGgsIG5laWdoYm9yLCB2aXNpdGVkLCByZWN1cnNpb25TdGFjaykpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChyZWN1cnNpb25TdGFjay5oYXMobmVpZ2hib3IpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZWN1cnNpb25TdGFjay5kZWxldGUobm9kZSk7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQWR2YW5jZWQgc29ydGluZyB3aXRoIG11bHRpcGxlIGFsZ29yaXRobXMgYW5kIG9wdGltaXphdGlvbnNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBPcHRpbWl6ZWRTb3J0aW5nIHtcclxuICAvKipcclxuICAgKiBIeWJyaWQgc29ydGluZyBhbGdvcml0aG0gdGhhdCBjaG9vc2VzIGJlc3QgYXBwcm9hY2ggYmFzZWQgb24gZGF0YSBjaGFyYWN0ZXJpc3RpY3NcclxuICAgKi9cclxuICBzdGF0aWMgc21hcnRTb3J0PFQ+KGFycmF5OiBUW10sIGNvbXBhcmVGbj86IChhOiBULCBiOiBUKSA9PiBudW1iZXIpOiBUW10ge1xyXG4gICAgaWYgKGFycmF5Lmxlbmd0aCA8PSAxKSByZXR1cm4gWy4uLmFycmF5XTtcclxuXHJcbiAgICBjb25zdCBjb21wYXJlID0gY29tcGFyZUZuIHx8ICgoYSwgYikgPT4gKGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwKSk7XHJcblxyXG4gICAgLy8gQ2hvb3NlIGFsZ29yaXRobSBiYXNlZCBvbiBhcnJheSBjaGFyYWN0ZXJpc3RpY3NcclxuICAgIGlmIChhcnJheS5sZW5ndGggPCA1MCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnRpb25Tb3J0KFsuLi5hcnJheV0sIGNvbXBhcmUpO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLmlzTmVhcmx5U29ydGVkKGFycmF5LCBjb21wYXJlKSkge1xyXG4gICAgICByZXR1cm4gdGhpcy50aW1Tb3J0KFsuLi5hcnJheV0sIGNvbXBhcmUpO1xyXG4gICAgfSBlbHNlIGlmIChhcnJheS5sZW5ndGggPiAxMDAwMCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJhbGxlbFF1aWNrU29ydChbLi4uYXJyYXldLCBjb21wYXJlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnF1aWNrU29ydChbLi4uYXJyYXldLCBjb21wYXJlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RhdGljIGlzTmVhcmx5U29ydGVkPFQ+KFxyXG4gICAgYXJyYXk6IFRbXSxcclxuICAgIGNvbXBhcmU6IChhOiBULCBiOiBUKSA9PiBudW1iZXJcclxuICApOiBib29sZWFuIHtcclxuICAgIGxldCBpbnZlcnNpb25zID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgIGlmIChjb21wYXJlKGFycmF5W2ldLCBhcnJheVtpICsgMV0pID4gMCkge1xyXG4gICAgICAgIGludmVyc2lvbnMrKztcclxuICAgICAgICBpZiAoaW52ZXJzaW9ucyA+IGFycmF5Lmxlbmd0aCAqIDAuMSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RhdGljIGluc2VydGlvblNvcnQ8VD4oXHJcbiAgICBhcnJheTogVFtdLFxyXG4gICAgY29tcGFyZTogKGE6IFQsIGI6IFQpID0+IG51bWJlclxyXG4gICk6IFRbXSB7XHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGtleSA9IGFycmF5W2ldO1xyXG4gICAgICBsZXQgaiA9IGkgLSAxO1xyXG4gICAgICB3aGlsZSAoaiA+PSAwICYmIGNvbXBhcmUoYXJyYXlbal0sIGtleSkgPiAwKSB7XHJcbiAgICAgICAgYXJyYXlbaiArIDFdID0gYXJyYXlbal07XHJcbiAgICAgICAgai0tO1xyXG4gICAgICB9XHJcbiAgICAgIGFycmF5W2ogKyAxXSA9IGtleTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcnJheTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RhdGljIHF1aWNrU29ydDxUPihcclxuICAgIGFycmF5OiBUW10sXHJcbiAgICBjb21wYXJlOiAoYTogVCwgYjogVCkgPT4gbnVtYmVyXHJcbiAgKTogVFtdIHtcclxuICAgIGlmIChhcnJheS5sZW5ndGggPD0gMSkgcmV0dXJuIGFycmF5O1xyXG5cclxuICAgIGNvbnN0IHBpdm90ID0gYXJyYXlbTWF0aC5mbG9vcihhcnJheS5sZW5ndGggLyAyKV07XHJcbiAgICBjb25zdCBsZWZ0ID0gYXJyYXkuZmlsdGVyKCh4KSA9PiBjb21wYXJlKHgsIHBpdm90KSA8IDApO1xyXG4gICAgY29uc3QgbWlkZGxlID0gYXJyYXkuZmlsdGVyKCh4KSA9PiBjb21wYXJlKHgsIHBpdm90KSA9PT0gMCk7XHJcbiAgICBjb25zdCByaWdodCA9IGFycmF5LmZpbHRlcigoeCkgPT4gY29tcGFyZSh4LCBwaXZvdCkgPiAwKTtcclxuXHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAuLi50aGlzLnF1aWNrU29ydChsZWZ0LCBjb21wYXJlKSxcclxuICAgICAgLi4ubWlkZGxlLFxyXG4gICAgICAuLi50aGlzLnF1aWNrU29ydChyaWdodCwgY29tcGFyZSksXHJcbiAgICBdO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdGF0aWMgdGltU29ydDxUPihhcnJheTogVFtdLCBjb21wYXJlOiAoYTogVCwgYjogVCkgPT4gbnVtYmVyKTogVFtdIHtcclxuICAgIC8vIFNpbXBsaWZpZWQgVGltU29ydCBpbXBsZW1lbnRhdGlvblxyXG4gICAgY29uc3QgbWluTWVyZ2UgPSAzMjtcclxuXHJcbiAgICBpZiAoYXJyYXkubGVuZ3RoIDwgbWluTWVyZ2UpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0aW9uU29ydChhcnJheSwgY29tcGFyZSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbWlkID0gTWF0aC5mbG9vcihhcnJheS5sZW5ndGggLyAyKTtcclxuICAgIGNvbnN0IGxlZnQgPSB0aGlzLnRpbVNvcnQoYXJyYXkuc2xpY2UoMCwgbWlkKSwgY29tcGFyZSk7XHJcbiAgICBjb25zdCByaWdodCA9IHRoaXMudGltU29ydChhcnJheS5zbGljZShtaWQpLCBjb21wYXJlKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5tZXJnZShsZWZ0LCByaWdodCwgY29tcGFyZSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHN0YXRpYyBtZXJnZTxUPihcclxuICAgIGxlZnQ6IFRbXSxcclxuICAgIHJpZ2h0OiBUW10sXHJcbiAgICBjb21wYXJlOiAoYTogVCwgYjogVCkgPT4gbnVtYmVyXHJcbiAgKTogVFtdIHtcclxuICAgIGNvbnN0IHJlc3VsdDogVFtdID0gW107XHJcbiAgICBsZXQgaSA9IDAsXHJcbiAgICAgIGogPSAwO1xyXG5cclxuICAgIHdoaWxlIChpIDwgbGVmdC5sZW5ndGggJiYgaiA8IHJpZ2h0Lmxlbmd0aCkge1xyXG4gICAgICBpZiAoY29tcGFyZShsZWZ0W2ldLCByaWdodFtqXSkgPD0gMCkge1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKGxlZnRbaSsrXSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0LnB1c2gocmlnaHRbaisrXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0LmNvbmNhdChsZWZ0LnNsaWNlKGkpKS5jb25jYXQocmlnaHQuc2xpY2UoaikpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdGF0aWMgcGFyYWxsZWxRdWlja1NvcnQ8VD4oXHJcbiAgICBhcnJheTogVFtdLFxyXG4gICAgY29tcGFyZTogKGE6IFQsIGI6IFQpID0+IG51bWJlclxyXG4gICk6IFRbXSB7XHJcbiAgICAvLyBTaW1wbGlmaWVkIHBhcmFsbGVsIHNvcnRpbmcgKHdvdWxkIHVzZSBXZWIgV29ya2VycyBpbiByZWFsIGltcGxlbWVudGF0aW9uKVxyXG4gICAgcmV0dXJuIHRoaXMucXVpY2tTb3J0KGFycmF5LCBjb21wYXJlKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNZW1vcnktZWZmaWNpZW50IGRhdGEgb3BlcmF0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE1lbW9yeU9wdGltaXplZE9wZXJhdGlvbnMge1xyXG4gIC8qKlxyXG4gICAqIFByb2Nlc3MgbGFyZ2UgZGF0YXNldHMgaW4gY2h1bmtzIHRvIGF2b2lkIG1lbW9yeSBpc3N1ZXNcclxuICAgKi9cclxuICBzdGF0aWMgYXN5bmMgcHJvY2Vzc0luQ2h1bmtzPFQsIFI+KFxyXG4gICAgZGF0YTogVFtdLFxyXG4gICAgcHJvY2Vzc29yOiAoY2h1bms6IFRbXSkgPT4gUltdLFxyXG4gICAgY2h1bmtTaXplOiBudW1iZXIgPSAxMDAwXHJcbiAgKTogUHJvbWlzZTxSW10+IHtcclxuICAgIGNvbnN0IHJlc3VsdHM6IFJbXSA9IFtdO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gY2h1bmtTaXplKSB7XHJcbiAgICAgIGNvbnN0IGNodW5rID0gZGF0YS5zbGljZShpLCBpICsgY2h1bmtTaXplKTtcclxuICAgICAgY29uc3QgY2h1bmtSZXN1bHRzID0gcHJvY2Vzc29yKGNodW5rKTtcclxuICAgICAgcmVzdWx0cy5wdXNoKC4uLmNodW5rUmVzdWx0cyk7XHJcblxyXG4gICAgICAvLyBBbGxvdyBnYXJiYWdlIGNvbGxlY3Rpb24gYmV0d2VlbiBjaHVua3NcclxuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHRzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVmlydHVhbCBzY3JvbGxpbmcgZm9yIGxhcmdlIGxpc3RzXHJcbiAgICovXHJcbiAgc3RhdGljIGNhbGN1bGF0ZVZpc2libGVJdGVtcyhcclxuICAgIHRvdGFsSXRlbXM6IG51bWJlcixcclxuICAgIGl0ZW1IZWlnaHQ6IG51bWJlcixcclxuICAgIGNvbnRhaW5lckhlaWdodDogbnVtYmVyLFxyXG4gICAgc2Nyb2xsVG9wOiBudW1iZXIsXHJcbiAgICBidWZmZXI6IG51bWJlciA9IDVcclxuICApOiB7IHN0YXJ0SW5kZXg6IG51bWJlcjsgZW5kSW5kZXg6IG51bWJlcjsgb2Zmc2V0WTogbnVtYmVyIH0ge1xyXG4gICAgY29uc3QgdmlzaWJsZUNvdW50ID0gTWF0aC5jZWlsKGNvbnRhaW5lckhlaWdodCAvIGl0ZW1IZWlnaHQpO1xyXG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IE1hdGgubWF4KDAsIE1hdGguZmxvb3Ioc2Nyb2xsVG9wIC8gaXRlbUhlaWdodCkgLSBidWZmZXIpO1xyXG4gICAgY29uc3QgZW5kSW5kZXggPSBNYXRoLm1pbihcclxuICAgICAgdG90YWxJdGVtcyAtIDEsXHJcbiAgICAgIHN0YXJ0SW5kZXggKyB2aXNpYmxlQ291bnQgKyAyICogYnVmZmVyXHJcbiAgICApO1xyXG4gICAgY29uc3Qgb2Zmc2V0WSA9IHN0YXJ0SW5kZXggKiBpdGVtSGVpZ2h0O1xyXG5cclxuICAgIHJldHVybiB7IHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBvZmZzZXRZIH07XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUGVyZm9ybWFuY2UgbW9uaXRvcmluZyBhbmQgYW5hbHl0aWNzXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUGVyZm9ybWFuY2VBbmFseXRpY3Mge1xyXG4gIHByaXZhdGUgc3RhdGljIG1lYXN1cmVtZW50cyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXJbXT4oKTtcclxuXHJcbiAgc3RhdGljIG1lYXN1cmU8VD4obmFtZTogc3RyaW5nLCBmbjogKCkgPT4gVCk6IFQge1xyXG4gICAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGZuKCk7XHJcbiAgICBjb25zdCBlbmQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuXHJcbiAgICBpZiAoIXRoaXMubWVhc3VyZW1lbnRzLmhhcyhuYW1lKSkge1xyXG4gICAgICB0aGlzLm1lYXN1cmVtZW50cy5zZXQobmFtZSwgW10pO1xyXG4gICAgfVxyXG4gICAgdGhpcy5tZWFzdXJlbWVudHMuZ2V0KG5hbWUpIS5wdXNoKGVuZCAtIHN0YXJ0KTtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGFzeW5jIG1lYXN1cmVBc3luYzxUPihuYW1lOiBzdHJpbmcsIGZuOiAoKSA9PiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiB7XHJcbiAgICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZm4oKTtcclxuICAgIGNvbnN0IGVuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG5cclxuICAgIGlmICghdGhpcy5tZWFzdXJlbWVudHMuaGFzKG5hbWUpKSB7XHJcbiAgICAgIHRoaXMubWVhc3VyZW1lbnRzLnNldChuYW1lLCBbXSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLm1lYXN1cmVtZW50cy5nZXQobmFtZSkhLnB1c2goZW5kIC0gc3RhcnQpO1xyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZ2V0U3RhdHMobmFtZTogc3RyaW5nKToge1xyXG4gICAgY291bnQ6IG51bWJlcjtcclxuICAgIHRvdGFsVGltZTogbnVtYmVyO1xyXG4gICAgYXZlcmFnZVRpbWU6IG51bWJlcjtcclxuICAgIG1pblRpbWU6IG51bWJlcjtcclxuICAgIG1heFRpbWU6IG51bWJlcjtcclxuICB9IHwgbnVsbCB7XHJcbiAgICBjb25zdCB0aW1lcyA9IHRoaXMubWVhc3VyZW1lbnRzLmdldChuYW1lKTtcclxuICAgIGlmICghdGltZXMpIHJldHVybiBudWxsO1xyXG5cclxuICAgIC8vIFJldHVybiB6ZXJvcyBmb3IgZW1wdHkgbWVhc3VyZW1lbnRzIChhZnRlciBjbGVhcilcclxuICAgIGlmICh0aW1lcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBjb3VudDogMCxcclxuICAgICAgICB0b3RhbFRpbWU6IDAsXHJcbiAgICAgICAgYXZlcmFnZVRpbWU6IDAsXHJcbiAgICAgICAgbWluVGltZTogMCxcclxuICAgICAgICBtYXhUaW1lOiAwLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN1bSA9IHRpbWVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY291bnQ6IHRpbWVzLmxlbmd0aCxcclxuICAgICAgdG90YWxUaW1lOiBzdW0sXHJcbiAgICAgIGF2ZXJhZ2VUaW1lOiBzdW0gLyB0aW1lcy5sZW5ndGgsXHJcbiAgICAgIG1pblRpbWU6IE1hdGgubWluKC4uLnRpbWVzKSxcclxuICAgICAgbWF4VGltZTogTWF0aC5tYXgoLi4udGltZXMpLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjbGVhck1lYXN1cmVtZW50cyhuYW1lPzogc3RyaW5nKTogdm9pZCB7XHJcbiAgICBpZiAobmFtZSkge1xyXG4gICAgICB0aGlzLm1lYXN1cmVtZW50cy5zZXQobmFtZSwgW10pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gQ2xlYXIgYWxsIG1lYXN1cmVtZW50cyBidXQga2VlcCB0aGUga2V5c1xyXG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLm1lYXN1cmVtZW50cy5rZXlzKCkpIHtcclxuICAgICAgICB0aGlzLm1lYXN1cmVtZW50cy5zZXQoa2V5LCBbXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbIkdyYXBoQWxnb3JpdGhtcyIsIkxSVUNhY2hlIiwiTWVtb3J5T3B0aW1pemVkT3BlcmF0aW9ucyIsIk9wdGltaXplZFNvcnRpbmciLCJQZXJmb3JtYW5jZUFuYWx5dGljcyIsIlByaW9yaXR5UXVldWUiLCJTZWFyY2hBbGdvcml0aG1zIiwiVHJpZSIsImNvbXBhcmVGbiIsImhlYXAiLCJhIiwiYiIsImVucXVldWUiLCJpdGVtIiwicHVzaCIsImhlYXBpZnlVcCIsImxlbmd0aCIsImRlcXVldWUiLCJ1bmRlZmluZWQiLCJwb3AiLCJyZXN1bHQiLCJoZWFwaWZ5RG93biIsInBlZWsiLCJzaXplIiwiaXNFbXB0eSIsImluc2VydCIsInByaW9yaXR5IiwiZXh0cmFjdE1heCIsIm1heCIsImluZGV4IiwicGFyZW50SW5kZXgiLCJNYXRoIiwiZmxvb3IiLCJzd2FwIiwibWluSW5kZXgiLCJsZWZ0Q2hpbGQiLCJyaWdodENoaWxkIiwiaSIsImoiLCJ3b3JkIiwiY3VycmVudCIsInJvb3QiLCJjaGFyIiwidG9Mb3dlckNhc2UiLCJjaGlsZHJlbiIsImhhcyIsInNldCIsIlRyaWVOb2RlIiwiZ2V0IiwiaXNFbmRPZldvcmQiLCJzZWFyY2giLCJzdGFydHNXaXRoIiwicHJlZml4IiwiZ2V0V29yZHNXaXRoUHJlZml4Iiwid29yZHMiLCJkZnMiLCJmaW5kV29yZHNXaXRoUHJlZml4IiwiZGVsZXRlIiwiZGVsZXRlSGVscGVyIiwibm9kZSIsImNoaWxkTm9kZSIsInNob3VsZERlbGV0ZUNoaWxkIiwiY3VycmVudFdvcmQiLCJNYXAiLCJjYXBhY2l0eSIsImNhY2hlIiwiaGVhZCIsIk5vZGUiLCJ0YWlsIiwibmV4dCIsInByZXYiLCJrZXkiLCJtb3ZlVG9IZWFkIiwidmFsdWUiLCJjbGVhciIsInB1dCIsImV4aXN0aW5nTm9kZSIsIm5ld05vZGUiLCJsYXN0Tm9kZSIsInJlbW92ZVRhaWwiLCJhZGRUb0hlYWQiLCJyZW1vdmVOb2RlIiwiYmluYXJ5U2VhcmNoIiwiYXJyYXkiLCJ0YXJnZXQiLCJsZWZ0IiwicmlnaHQiLCJtaWQiLCJjbXAiLCJib3llck1vb3JlU2VhcmNoIiwidGV4dCIsInBhdHRlcm4iLCJwb3NpdGlvbnMiLCJtIiwibiIsImJhZENoYXIiLCJidWlsZEJhZENoYXJUYWJsZSIsInNraXAiLCJjaGFyQ29kZUF0IiwidGFibGUiLCJBcnJheSIsImZpbGwiLCJmdXp6eVNlYXJjaCIsInF1ZXJ5IiwiY2FuZGlkYXRlcyIsInRocmVzaG9sZCIsInJlc3VsdHMiLCJtYXAiLCJjYW5kaWRhdGUiLCJzY29yZSIsImphcm9XaW5rbGVyU2ltaWxhcml0eSIsImZpbHRlciIsInNvcnQiLCJzMSIsInMyIiwiamFybyIsImphcm9TaW1pbGFyaXR5IiwicHJlZml4TGVuZ3RoIiwiY29tbW9uUHJlZml4TGVuZ3RoIiwibWF0Y2hXaW5kb3ciLCJzMU1hdGNoZXMiLCJzMk1hdGNoZXMiLCJtYXRjaGVzIiwidHJhbnNwb3NpdGlvbnMiLCJzdGFydCIsImVuZCIsIm1pbiIsImsiLCJtYXhMZW5ndGgiLCJkaWprc3RyYSIsImdyYXBoIiwiZGlzdGFuY2VzIiwicHJldmlvdXMiLCJ1bnZpc2l0ZWQiLCJrZXlzIiwiSW5maW5pdHkiLCJuZWlnaGJvcnMiLCJuZWlnaGJvciIsImFsdCIsIndlaWdodCIsInBhdGgiLCJ1bnNoaWZ0IiwiZGlzdGFuY2UiLCJoYXNDeWNsZSIsInZpc2l0ZWQiLCJTZXQiLCJyZWN1cnNpb25TdGFjayIsImhhc0N5Y2xlREZTIiwiYWRkIiwic21hcnRTb3J0IiwiY29tcGFyZSIsImluc2VydGlvblNvcnQiLCJpc05lYXJseVNvcnRlZCIsInRpbVNvcnQiLCJwYXJhbGxlbFF1aWNrU29ydCIsInF1aWNrU29ydCIsImludmVyc2lvbnMiLCJwaXZvdCIsIngiLCJtaWRkbGUiLCJtaW5NZXJnZSIsInNsaWNlIiwibWVyZ2UiLCJjb25jYXQiLCJwcm9jZXNzSW5DaHVua3MiLCJkYXRhIiwicHJvY2Vzc29yIiwiY2h1bmtTaXplIiwiY2h1bmsiLCJjaHVua1Jlc3VsdHMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJjYWxjdWxhdGVWaXNpYmxlSXRlbXMiLCJ0b3RhbEl0ZW1zIiwiaXRlbUhlaWdodCIsImNvbnRhaW5lckhlaWdodCIsInNjcm9sbFRvcCIsImJ1ZmZlciIsInZpc2libGVDb3VudCIsImNlaWwiLCJzdGFydEluZGV4IiwiZW5kSW5kZXgiLCJvZmZzZXRZIiwibWVhc3VyZW1lbnRzIiwibWVhc3VyZSIsIm5hbWUiLCJmbiIsInBlcmZvcm1hbmNlIiwibm93IiwibWVhc3VyZUFzeW5jIiwiZ2V0U3RhdHMiLCJ0aW1lcyIsImNvdW50IiwidG90YWxUaW1lIiwiYXZlcmFnZVRpbWUiLCJtaW5UaW1lIiwibWF4VGltZSIsInN1bSIsInJlZHVjZSIsImNsZWFyTWVhc3VyZW1lbnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7O1FBd2JhQTtlQUFBQTs7UUFoUEFDO2VBQUFBOztRQXNjQUM7ZUFBQUE7O1FBcEhBQztlQUFBQTs7UUFvS0FDO2VBQUFBOztRQXRyQkFDO2VBQUFBOztRQTBSQUM7ZUFBQUE7O1FBdkxBQztlQUFBQTs7O0FBbkdOLE1BQU1GO0lBSVgsWUFBWUcsU0FBa0MsQ0FBRTthQUh4Q0MsT0FBWSxFQUFFO1FBSXBCLElBQUksQ0FBQ0QsU0FBUyxHQUNaQSxhQUFjLENBQUEsQ0FBQ0UsR0FBUUMsSUFBWUQsSUFBSUMsSUFBSSxDQUFDLElBQUlELElBQUlDLElBQUksSUFBSSxDQUFDO0lBQ2pFO0lBRUFDLFFBQVFDLElBQU8sRUFBUTtR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