"""
Enhanced Products API with advanced CRUD operations.
Demonstrates the enhanced CRUD system in action.
"""
from typing import Any, Dict, List, Optional, Union
from fastapi import APIRouter, Depends, HTTPException, Query, BackgroundTasks, status
from fastapi.responses import StreamingResponse\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom app.core.database import get_db\nfrom app.services.enhanced_shop_service import EnhancedShopService, get_enhanced_shop_service\nfrom app.models.shop import (\n    Product, ProductCreate, ProductUpdate, ProductResponse,\n    ProductCategory, ProductStatus\n)\nfrom app.api.v1.endpoints.enhanced_crud import (\n    EnhancedCRUDRouter,\n    FilterParam,\n    SortParam,\n    SearchRequest,\n    BulkCreateRequest,\n    BulkDeleteRequest,\n    ExportRequest,\n)\nfrom app.core.exceptions import create_success_response\nfrom app.core.logging import get_logger\nfrom app.auth.dependencies import get_current_user, get_current_active_user\n\nlogger = get_logger(__name__)\n\n# Create enhanced CRUD router for products\nenhanced_router = EnhancedCRUDRouter(\n    service_class=EnhancedShopService,\n    prefix=\"/products\",\n    tags=[\"Enhanced Products\"],\n    create_schema=ProductCreate,\n    update_schema=ProductUpdate,\n    response_schema=ProductResponse,\n)\n\n# Create main router\nrouter = APIRouter()\n\n# Include the enhanced CRUD router\nrouter.include_router(enhanced_router.router)\n\n# Add domain-specific endpoints\n\n@router.get(\"/products/featured\", response_model=Dict[str, Any])\nasync def get_featured_products(\n    limit: int = Query(10, ge=1, le=50, description=\"Number of featured products\"),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Get featured products with caching.\"\"\"\n    try:\n        service = get_enhanced_shop_service(db)\n        products = await service.get_featured_products(limit=limit)\n        \n        return create_success_response(\n            data={\n                \"products\": [product.dict() if hasattr(product, \"dict\") else product.__dict__ for product in products],\n                \"count\": len(products),\n            },\n            message=\"Featured products retrieved successfully\",\n        )\n        \n    except Exception as e:\n        logger.error(\"Failed to get featured products\", error=str(e))\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@router.get(\"/products/categories\", response_model=Dict[str, Any])\nasync def get_product_categories():\n    \"\"\"Get available product categories.\"\"\"\n    categories = [\n        {\n            \"value\": category.value,\n            \"label\": category.value.replace(\"_\", \" \").title(),\n            \"description\": f\"Products in {category.value.replace('_', ' ')} category\",\n        }\n        for category in ProductCategory\n    ]\n    \n    return create_success_response(\n        data={\"categories\": categories},\n        message=\"Product categories retrieved successfully\",\n    )\n\n\n@router.get(\"/products/sku/{sku}\", response_model=Dict[str, Any])\nasync def get_product_by_sku(\n    sku: str,\n    db: AsyncSession = Depends(get_db),\n    current_user = Depends(get_current_user),\n):\n    \"\"\"Get product by SKU.\"\"\"\n    try:\n        service = get_enhanced_shop_service(db)\n        product = await service.get_by_sku(sku)\n        \n        if not product:\n            raise HTTPException(status_code=404, detail=\"Product not found\")\n        \n        # Check read permission\n        if not await service._check_read_permission(product, getattr(current_user, \"id\", None)):\n            raise HTTPException(status_code=404, detail=\"Product not found\")\n        \n        return create_success_response(\n            data=product.dict() if hasattr(product, \"dict\") else product.__dict__,\n            message=\"Product retrieved successfully\",\n        )\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(\"Failed to get product by SKU\", sku=sku, error=str(e))\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@router.get(\"/products/slug/{slug}\", response_model=Dict[str, Any])\nasync def get_product_by_slug(\n    slug: str,\n    db: AsyncSession = Depends(get_db),\n    current_user = Depends(get_current_user),\n):\n    \"\"\"Get product by slug.\"\"\"\n    try:\n        service = get_enhanced_shop_service(db)\n        product = await service.get_by_slug(slug)\n        \n        if not product:\n            raise HTTPException(status_code=404, detail=\"Product not found\")\n        \n        # Check read permission\n        if not await service._check_read_permission(product, getattr(current_user, \"id\", None)):\n            raise HTTPException(status_code=404, detail=\"Product not found\")\n        \n        return create_success_response(\n            data=product.dict() if hasattr(product, \"dict\") else product.__dict__,\n            message=\"Product retrieved successfully\",\n        )\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(\"Failed to get product by slug\", slug=slug, error=str(e))\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@router.get(\"/products/{product_id}/related\", response_model=Dict[str, Any])\nasync def get_related_products(\n    product_id: int,\n    limit: int = Query(5, ge=1, le=20, description=\"Number of related products\"),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Get related products.\"\"\"\n    try:\n        service = get_enhanced_shop_service(db)\n        products = await service.get_related_products(product_id, limit=limit)\n        \n        return create_success_response(\n            data={\n                \"products\": [product.dict() if hasattr(product, \"dict\") else product.__dict__ for product in products],\n                \"count\": len(products),\n            },\n            message=\"Related products retrieved successfully\",\n        )\n        \n    except Exception as e:\n        logger.error(\"Failed to get related products\", product_id=product_id, error=str(e))\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@router.get(\"/products/{product_id}/analytics\", response_model=Dict[str, Any])\nasync def get_product_analytics(\n    product_id: int,\n    db: AsyncSession = Depends(get_db),\n    current_user = Depends(get_current_active_user),\n):\n    \"\"\"Get product analytics (owner/admin only).\"\"\"\n    try:\n        service = get_enhanced_shop_service(db)\n        analytics = await service.get_product_analytics(\n            product_id=product_id,\n            user_id=getattr(current_user, \"id\", None),\n        )\n        \n        return create_success_response(\n            data=analytics,\n            message=\"Product analytics retrieved successfully\",\n        )\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(\"Failed to get product analytics\", product_id=product_id, error=str(e))\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@router.put(\"/products/{product_id}/stock\", response_model=Dict[str, Any])\nasync def update_product_stock(\n    product_id: int,\n    quantity_change: int = Query(..., description=\"Stock quantity change (positive or negative)\"),\n    db: AsyncSession = Depends(get_db),\n    current_user = Depends(get_current_active_user),\n):\n    \"\"\"Update product stock quantity.\"\"\"\n    try:\n        service = get_enhanced_shop_service(db)\n        success = await service.update_stock(\n            product_id=product_id,\n            quantity_change=quantity_change,\n            user_id=getattr(current_user, \"id\", None),\n        )\n        \n        if not success:\n            raise HTTPException(status_code=400, detail=\"Failed to update stock\")\n        \n        # Get updated product\n        product = await service.get_by_id(product_id)\n        \n        return create_success_response(\n            data={\n                \"product_id\": product_id,\n                \"new_stock_quantity\": product.stock_quantity if product else None,\n                \"quantity_change\": quantity_change,\n            },\n            message=\"Stock updated successfully\",\n        )\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(\"Failed to update product stock\", product_id=product_id, error=str(e))\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@router.get(\"/products/low-stock\", response_model=Dict[str, Any])\nasync def get_low_stock_products(\n    threshold: int = Query(5, ge=0, description=\"Stock threshold\"),\n    db: AsyncSession = Depends(get_db),\n    current_user = Depends(get_current_active_user),\n):\n    \"\"\"Get products with low stock (seller/admin only).\"\"\"\n    try:\n        service = get_enhanced_shop_service(db)\n        products = await service.get_low_stock_products(\n            threshold=threshold,\n            user_id=getattr(current_user, \"id\", None),\n        )\n        \n        return create_success_response(\n            data={\n                \"products\": [product.dict() if hasattr(product, \"dict\") else product.__dict__ for product in products],\n                \"count\": len(products),\n                \"threshold\": threshold,\n            },\n            message=\"Low stock products retrieved successfully\",\n        )\n        \n    except Exception as e:\n        logger.error(\"Failed to get low stock products\", error=str(e))\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@router.post(\"/products/advanced-search\", response_model=Dict[str, Any])\nasync def advanced_product_search(\n    search_request: SearchRequest,\n    db: AsyncSession = Depends(get_db),\n    current_user = Depends(get_current_user),\n):\n    \"\"\"Advanced product search with filters and sorting.\"\"\"\n    try:\n        service = get_enhanced_shop_service(db)\n        \n        # Convert filters\n        filters = {}\n        for filter_param in search_request.filters:\n            filters[filter_param.field] = {\n                \"operator\": filter_param.operator,\n                \"value\": filter_param.value,\n            }\n        \n        products = await service.search_products(\n            query=search_request.query,\n            filters=filters,\n            skip=(search_request.page - 1) * search_request.size,\n            limit=search_request.size,\n            user_id=getattr(current_user, \"id\", None),\n        )\n        \n        return create_success_response(\n            data={\n                \"products\": [product.dict() if hasattr(product, \"dict\") else product.__dict__ for product in products],\n                \"count\": len(products),\n                \"search\": {\n                    \"query\": search_request.query,\n                    \"fields\": search_request.fields,\n                    \"filters\": search_request.filters,\n                    \"page\": search_request.page,\n                    \"size\": search_request.size,\n                },\n            },\n            message=\"Search completed successfully\",\n        )\n        \n    except Exception as e:\n        logger.error(\"Failed to search products\", error=str(e))\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@router.post(\"/products/bulk-update-status\", response_model=Dict[str, Any])\nasync def bulk_update_product_status(\n    product_ids: List[int],\n    status: ProductStatus,\n    background_tasks: BackgroundTasks,\n    db: AsyncSession = Depends(get_db),\n    current_user = Depends(get_current_active_user),\n):\n    \"\"\"Bulk update product status.\"\"\"\n    try:\n        service = get_enhanced_shop_service(db)\n        \n        updated_count = 0\n        errors = []\n        \n        for product_id in product_ids:\n            try:\n                # Create update data\n                update_data = ProductUpdate(status=status)\n                \n                result = await service.update(\n                    id=product_id,\n                    obj_in=update_data,\n                    user_id=getattr(current_user, \"id\", None),\n                )\n                \n                if result:\n                    updated_count += 1\n                    \n            except Exception as e:\n                errors.append({\"product_id\": product_id, \"error\": str(e)})\n        \n        # Background task for post-processing\n        background_tasks.add_task(\n            _log_bulk_status_update,\n            product_ids=product_ids,\n            status=status.value,\n            updated_count=updated_count,\n            user_id=getattr(current_user, \"id\", None),\n        )\n        \n        return create_success_response(\n            data={\n                \"updated_count\": updated_count,\n                \"total_requested\": len(product_ids),\n                \"errors\": errors,\n                \"new_status\": status.value,\n            },\n            message=f\"Bulk status update completed. Updated {updated_count} products.\",\n        )\n        \n    except Exception as e:\n        logger.error(\"Failed to bulk update product status\", error=str(e))\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@router.post(\"/products/bulk-price-update\", response_model=Dict[str, Any])\nasync def bulk_update_product_prices(\n    updates: List[Dict[str, Union[int, float]]],  # [{\"id\": 1, \"price\": 100.0}, ...]\n    background_tasks: BackgroundTasks,\n    db: AsyncSession = Depends(get_db),\n    current_user = Depends(get_current_active_user),\n):\n    \"\"\"Bulk update product prices.\"\"\"\n    try:\n        service = get_enhanced_shop_service(db)\n        \n        updated_count = 0\n        errors = []\n        \n        for update_item in updates:\n            try:\n                product_id = update_item.get(\"id\")\n                new_price = update_item.get(\"price\")\n                \n                if not product_id or new_price is None:\n                    errors.append({\"item\": update_item, \"error\": \"Missing id or price\"})\n                    continue\n                \n                # Create update data\n                update_data = ProductUpdate(price=new_price)\n                \n                result = await service.update(\n                    id=product_id,\n                    obj_in=update_data,\n                    user_id=getattr(current_user, \"id\", None),\n                )\n                \n                if result:\n                    updated_count += 1\n                    \n            except Exception as e:\n                errors.append({\"item\": update_item, \"error\": str(e)})\n        \n        return create_success_response(\n            data={\n                \"updated_count\": updated_count,\n                \"total_requested\": len(updates),\n                \"errors\": errors,\n            },\n            message=f\"Bulk price update completed. Updated {updated_count} products.\",\n        )\n        \n    except Exception as e:\n        logger.error(\"Failed to bulk update product prices\", error=str(e))\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n@router.get(\"/products/export/csv\", response_class=StreamingResponse)\nasync def export_products_csv(\n    category: Optional[ProductCategory] = Query(None, description=\"Filter by category\"),\n    status: Optional[ProductStatus] = Query(None, description=\"Filter by status\"),\n    seller_id: Optional[str] = Query(None, description=\"Filter by seller\"),\n    db: AsyncSession = Depends(get_db),\n    current_user = Depends(get_current_active_user),\n):\n    \"\"\"Export products to CSV.\"\"\"\n    try:\n        service = get_enhanced_shop_service(db)\n        \n        # Build filters\n        filters = {}\n        if category:\n            filters[\"category\"] = category\n        if status:\n            filters[\"status\"] = status\n        if seller_id:\n            filters[\"seller_id\"] = seller_id\n        \n        # Get products\n        from app.core.repository import FilterParams, PaginationParams\n        \n        filter_params = FilterParams(filters=filters)\n        pagination = PaginationParams(page=1, size=10000)  # Max 10k for export\n        \n        result = await service.get_multi(\n            pagination=pagination,\n            filters=filter_params,\n            user_id=getattr(current_user, \"id\", None),\n        )\n        \n        # Generate CSV\n        import csv\n        import io\n        \n        output = io.StringIO()\n        fieldnames = [\n            \"id\", \"name\", \"sku\", \"category\", \"price\", \"stock_quantity\",\n            \"status\", \"created_at\", \"updated_at\"\n        ]\n        \n        writer = csv.DictWriter(output, fieldnames=fieldnames)\n        writer.writeheader()\n        \n        for product in result.items:\n            product_dict = product.dict() if hasattr(product, \"dict\") else product.__dict__\n            row = {field: product_dict.get(field, \"\") for field in fieldnames}\n            writer.writerow(row)\n        \n        output.seek(0)\n        \n        return StreamingResponse(\n            io.BytesIO(output.getvalue().encode()),\n            media_type=\"text/csv\",\n            headers={\"Content-Disposition\": \"attachment; filename=products_export.csv\"},\n        )\n        \n    except Exception as e:\n        logger.error(\"Failed to export products\", error=str(e))\n        raise HTTPException(status_code=500, detail=str(e))\n\n\n# Background task functions\n\nasync def _log_bulk_status_update(\n    product_ids: List[int],\n    status: str,\n    updated_count: int,\n    user_id: Optional[str],\n):\n    \"\"\"Log bulk status update for analytics.\"\"\"\n    logger.info(\n        \"Bulk product status update completed\",\n        product_ids=product_ids[:10],  # Log first 10 IDs\n        total_products=len(product_ids),\n        new_status=status,\n        updated_count=updated_count,\n        user_id=user_id,\n    )