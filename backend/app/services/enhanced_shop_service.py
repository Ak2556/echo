"""
Enhanced Shop Service with advanced CRUD operations.
Demonstrates how to use the enhanced CRUD system for a specific domain.
"""
import asyncio
from typing import Any, Dict, List, Optional, Union
from datetime import datetime, timezone
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, and_, or_

from app.core.service import BaseService, ValidationRule, BusinessRule
from app.core.repository import BaseRepository, FilterParams, PaginationParams, SortParams
from app.models.shop import (\n    Product, ProductCreate, ProductUpdate, ProductResponse,\n    Cart, CartItem, Order, OrderItem, ProductReview,\n    ProductStatus, ProductCategory\n)\nfrom app.core.exceptions import ValidationException, NotFoundException, ConflictException\nfrom app.core.logging import get_logger\nfrom app.core.redis import cache\n\nlogger = get_logger(__name__)\n\n\nclass ProductRepository(BaseRepository[Product, ProductCreate, ProductUpdate]):\n    \"\"\"Enhanced Product repository with domain-specific methods.\"\"\"\n    \n    def __init__(self, db: AsyncSession):\n        super().__init__(Product, db)\n    \n    async def get_by_sku(self, sku: str) -> Optional[Product]:\n        \"\"\"Get product by SKU.\"\"\"\n        try:\n            query = select(self.model).where(self.model.sku == sku)\n            result = await self.db.execute(query)\n            return result.scalar_one_or_none()\n        except Exception as e:\n            logger.error(\"Failed to get product by SKU\", sku=sku, error=str(e))\n            return None\n    \n    async def get_by_slug(self, slug: str) -> Optional[Product]:\n        \"\"\"Get product by slug.\"\"\"\n        try:\n            query = select(self.model).where(self.model.slug == slug)\n            result = await self.db.execute(query)\n            return result.scalar_one_or_none()\n        except Exception as e:\n            logger.error(\"Failed to get product by slug\", slug=slug, error=str(e))\n            return None\n    \n    async def get_featured_products(self, limit: int = 10) -> List[Product]:\n        \"\"\"Get featured products.\"\"\"\n        try:\n            query = (\n                select(self.model)\n                .where(\n                    and_(\n                        self.model.is_featured == True,\n                        self.model.status == ProductStatus.ACTIVE\n                    )\n                )\n                .order_by(self.model.created_at.desc())\n                .limit(limit)\n            )\n            result = await self.db.execute(query)\n            return list(result.scalars().all())\n        except Exception as e:\n            logger.error(\"Failed to get featured products\", error=str(e))\n            return []\n    \n    async def get_low_stock_products(self, threshold: int = 5) -> List[Product]:\n        \"\"\"Get products with low stock.\"\"\"\n        try:\n            query = (\n                select(self.model)\n                .where(\n                    and_(\n                        self.model.stock_quantity <= threshold,\n                        self.model.track_inventory == True,\n                        self.model.status == ProductStatus.ACTIVE\n                    )\n                )\n                .order_by(self.model.stock_quantity.asc())\n            )\n            result = await self.db.execute(query)\n            return list(result.scalars().all())\n        except Exception as e:\n            logger.error(\"Failed to get low stock products\", error=str(e))\n            return []\n    \n    async def update_stock(self, product_id: int, quantity_change: int) -> bool:\n        \"\"\"Update product stock quantity.\"\"\"\n        try:\n            product = await self.get_by_id(product_id, use_cache=False)\n            if not product:\n                return False\n            \n            new_quantity = product.stock_quantity + quantity_change\n            if new_quantity < 0:\n                raise ValidationException(\"Insufficient stock\")\n            \n            product.stock_quantity = new_quantity\n            product.updated_at = datetime.now(timezone.utc)\n            \n            # Update status if out of stock\n            if new_quantity == 0 and product.track_inventory:\n                product.status = ProductStatus.OUT_OF_STOCK\n            elif product.status == ProductStatus.OUT_OF_STOCK and new_quantity > 0:\n                product.status = ProductStatus.ACTIVE\n            \n            await self.db.commit()\n            await self.db.refresh(product)\n            \n            # Invalidate cache\n            await self._cache_delete(self._get_cache_key(\"id\", product_id))\n            \n            return True\n            \n        except Exception as e:\n            await self.db.rollback()\n            logger.error(\"Failed to update stock\", product_id=product_id, error=str(e))\n            return False\n    \n    async def get_related_products(\n        self, \n        product_id: int, \n        limit: int = 5\n    ) -> List[Product]:\n        \"\"\"Get related products based on category and tags.\"\"\"\n        try:\n            # Get the source product\n            source_product = await self.get_by_id(product_id)\n            if not source_product:\n                return []\n            \n            # Find products in same category with similar tags\n            query = (\n                select(self.model)\n                .where(\n                    and_(\n                        self.model.id != product_id,\n                        self.model.category == source_product.category,\n                        self.model.status == ProductStatus.ACTIVE\n                    )\n                )\n                .order_by(self.model.average_rating.desc())\n                .limit(limit)\n            )\n            \n            result = await self.db.execute(query)\n            return list(result.scalars().all())\n            \n        except Exception as e:\n            logger.error(\"Failed to get related products\", product_id=product_id, error=str(e))\n            return []\n\n\nclass EnhancedShopService(BaseService[Product, ProductCreate, ProductUpdate]):\n    \"\"\"Enhanced Shop service with business logic and validation.\"\"\"\n    \n    def __init__(self, db: AsyncSession):\n        repository = ProductRepository(db)\n        super().__init__(repository, db)\n        \n        # Setup validation rules\n        self._setup_validation_rules()\n        \n        # Setup business rules\n        self._setup_business_rules()\n    \n    def _setup_validation_rules(self):\n        \"\"\"Setup validation rules for products.\"\"\"\n        \n        # Price validation\n        self.add_validation_rule(ValidationRule(\n            field=\"price\",\n            rule=lambda x: x is not None and x > 0,\n            message=\"Price must be greater than 0\"\n        ))\n        \n        # Stock validation\n        self.add_validation_rule(ValidationRule(\n            field=\"stock_quantity\",\n            rule=lambda x: x is not None and x >= 0,\n            message=\"Stock quantity cannot be negative\"\n        ))\n        \n        # SKU validation\n        self.add_validation_rule(ValidationRule(\n            field=\"sku\",\n            rule=lambda x: x is not None and len(x.strip()) >= 3,\n            message=\"SKU must be at least 3 characters long\"\n        ))\n        \n        # Name validation\n        self.add_validation_rule(ValidationRule(\n            field=\"name\",\n            rule=lambda x: x is not None and len(x.strip()) >= 2,\n            message=\"Product name must be at least 2 characters long\"\n        ))\n        \n        # Description validation\n        self.add_validation_rule(ValidationRule(\n            field=\"description\",\n            rule=lambda x: x is not None and len(x.strip()) >= 10,\n            message=\"Product description must be at least 10 characters long\"\n        ))\n    \n    def _setup_business_rules(self):\n        \"\"\"Setup business rules for products.\"\"\"\n        \n        # Unique SKU rule\n        self.add_business_rule(BusinessRule(\n            name=\"unique_sku\",\n            condition=self._check_unique_sku,\n            message=\"SKU must be unique\",\n            action=\"reject\"\n        ))\n        \n        # Pricing rule\n        self.add_business_rule(BusinessRule(\n            name=\"reasonable_price\",\n            condition=self._check_reasonable_price,\n            message=\"Price seems unusually high\",\n            action=\"warn\"\n        ))\n        \n        # Stock level rule\n        self.add_business_rule(BusinessRule(\n            name=\"stock_level_warning\",\n            condition=self._check_stock_level,\n            message=\"Stock level is below minimum threshold\",\n            action=\"warn\"\n        ))\n    \n    async def _check_unique_sku(self, context: Dict[str, Any]) -> bool:\n        \"\"\"Check if SKU is unique.\"\"\"\n        data = context[\"data\"]\n        existing = context.get(\"existing\")\n        \n        sku = data.get(\"sku\")\n        if not sku:\n            return True\n        \n        # Check if SKU exists\n        existing_product = await self.repository.get_by_sku(sku)\n        \n        if not existing_product:\n            return True\n        \n        # If updating, allow same SKU for same product\n        if existing and existing.get(\"id\") == existing_product.id:\n            return True\n        \n        return False\n    \n    async def _check_reasonable_price(self, context: Dict[str, Any]) -> bool:\n        \"\"\"Check if price is reasonable.\"\"\"\n        data = context[\"data\"]\n        price = data.get(\"price\")\n        \n        if not price:\n            return True\n        \n        # Warn if price is over 100,000\n        return price <= 100000\n    \n    async def _check_stock_level(self, context: Dict[str, Any]) -> bool:\n        \"\"\"Check stock level.\"\"\"\n        data = context[\"data\"]\n        stock_quantity = data.get(\"stock_quantity\")\n        min_stock_level = data.get(\"min_stock_level\", 5)\n        \n        if stock_quantity is None:\n            return True\n        \n        return stock_quantity >= min_stock_level\n    \n    async def _before_create(self, data: ProductCreate, user_id: Optional[str] = None) -> ProductCreate:\n        \"\"\"Pre-create processing.\"\"\"\n        # Generate slug from name if not provided\n        if hasattr(data, \"name\") and not hasattr(data, \"slug\"):\n            slug = self._generate_slug(data.name)\n            # Add slug to data (this would need to be handled properly in real implementation)\n        \n        # Set seller_id if provided\n        if user_id and hasattr(data, \"seller_id\"):\n            data.seller_id = user_id\n        \n        return data\n    \n    async def _after_create(self, obj: Product, user_id: Optional[str] = None) -> Product:\n        \"\"\"Post-create processing.\"\"\"\n        # Update search index, send notifications, etc.\n        logger.info(\"Product created\", product_id=obj.id, name=obj.name)\n        return obj\n    \n    async def _before_update(self, id: Any, data: ProductUpdate, existing: Product, user_id: Optional[str] = None) -> ProductUpdate:\n        \"\"\"Pre-update processing.\"\"\"\n        # Check if user can update this product\n        if user_id and existing.seller_id != user_id:\n            # Check if user is admin (this would be implemented based on your auth system)\n            pass\n        \n        return data\n    \n    async def _after_update(self, obj: Product, changes: Dict[str, Any], user_id: Optional[str] = None) -> Product:\n        \"\"\"Post-update processing.\"\"\"\n        # Update search index, send notifications for price changes, etc.\n        if \"price\" in changes:\n            logger.info(\"Product price updated\", product_id=obj.id, old_price=changes[\"price\"][\"old\"], new_price=changes[\"price\"][\"new\"])\n        \n        return obj\n    \n    async def _check_read_permission(self, obj: Product, user_id: Optional[str]) -> bool:\n        \"\"\"Check read permission.\"\"\"\n        # Allow reading active products, or own products regardless of status\n        if obj.status == ProductStatus.ACTIVE:\n            return True\n        \n        if user_id and obj.seller_id == user_id:\n            return True\n        \n        # Check if user is admin\n        return False  # This would be implemented based on your auth system\n    \n    async def _check_update_permission(self, obj: Product, user_id: Optional[str]) -> bool:\n        \"\"\"Check update permission.\"\"\"\n        if not user_id:\n            return False\n        \n        # Allow owner or admin\n        if obj.seller_id == user_id:\n            return True\n        \n        # Check if user is admin\n        return False  # This would be implemented based on your auth system\n    \n    async def _check_delete_permission(self, obj: Product, user_id: Optional[str]) -> bool:\n        \"\"\"Check delete permission.\"\"\"\n        if not user_id:\n            return False\n        \n        # Allow owner or admin\n        if obj.seller_id == user_id:\n            return True\n        \n        # Check if user is admin\n        return False  # This would be implemented based on your auth system\n    \n    # Domain-specific methods\n    \n    @cache(ttl=600, key_prefix=\"featured_products\")\n    async def get_featured_products(self, limit: int = 10) -> List[Product]:\n        \"\"\"Get featured products with caching.\"\"\"\n        return await self.repository.get_featured_products(limit)\n    \n    async def get_by_sku(self, sku: str) -> Optional[Product]:\n        \"\"\"Get product by SKU.\"\"\"\n        return await self.repository.get_by_sku(sku)\n    \n    async def get_by_slug(self, slug: str) -> Optional[Product]:\n        \"\"\"Get product by slug.\"\"\"\n        return await self.repository.get_by_slug(slug)\n    \n    async def get_related_products(self, product_id: int, limit: int = 5) -> List[Product]:\n        \"\"\"Get related products.\"\"\"\n        return await self.repository.get_related_products(product_id, limit)\n    \n    async def update_stock(self, product_id: int, quantity_change: int, user_id: Optional[str] = None) -> bool:\n        \"\"\"Update product stock.\"\"\"\n        # Check permission\n        product = await self.get_by_id(product_id, user_id=user_id)\n        if not product:\n            raise NotFoundException(\"Product not found\")\n        \n        if not await self._check_update_permission(product, user_id):\n            raise ValidationException(\"Insufficient permissions\")\n        \n        return await self.repository.update_stock(product_id, quantity_change)\n    \n    async def get_low_stock_products(self, threshold: int = 5, user_id: Optional[str] = None) -> List[Product]:\n        \"\"\"Get products with low stock.\"\"\"\n        products = await self.repository.get_low_stock_products(threshold)\n        \n        # Filter by permission\n        if user_id:\n            filtered_products = []\n            for product in products:\n                if await self._check_read_permission(product, user_id):\n                    filtered_products.append(product)\n            return filtered_products\n        \n        return products\n    \n    async def search_products(\n        self,\n        query: str,\n        filters: Optional[Dict[str, Any]] = None,\n        skip: int = 0,\n        limit: int = 50,\n        user_id: Optional[str] = None,\n    ) -> List[Product]:\n        \"\"\"Search products with full-text search.\"\"\"\n        try:\n            # Setup search filters\n            search_filters = FilterParams(\n                search=query,\n                search_fields=[\"name\", \"description\", \"tags\"],\n                filters=filters or {},\n            )\n            \n            # Add active status filter for non-owners\n            if not filters or \"status\" not in filters:\n                search_filters.filters[\"status\"] = ProductStatus.ACTIVE\n            \n            # Setup pagination\n            pagination = PaginationParams(page=(skip // limit) + 1, size=limit)\n            \n            # Get results\n            result = await self.get_multi(\n                pagination=pagination,\n                filters=search_filters,\n                user_id=user_id,\n            )\n            \n            return result.items\n            \n        except Exception as e:\n            logger.error(\"Failed to search products\", query=query, error=str(e))\n            return []\n    \n    async def get_product_analytics(self, product_id: int, user_id: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"Get product analytics.\"\"\"\n        product = await self.get_by_id(product_id, user_id=user_id)\n        if not product:\n            raise NotFoundException(\"Product not found\")\n        \n        if not await self._check_read_permission(product, user_id):\n            raise ValidationException(\"Insufficient permissions\")\n        \n        # Calculate analytics\n        analytics = {\n            \"total_sales\": product.total_sales,\n            \"total_revenue\": product.total_revenue,\n            \"average_rating\": product.average_rating,\n            \"total_reviews\": product.total_reviews,\n            \"view_count\": product.view_count,\n            \"stock_level\": product.stock_quantity,\n            \"stock_status\": \"low\" if product.stock_quantity <= product.min_stock_level else \"normal\",\n            \"conversion_rate\": (product.total_sales / max(product.view_count, 1)) * 100,\n        }\n        \n        return analytics\n    \n    def _generate_slug(self, name: str) -> str:\n        \"\"\"Generate URL-friendly slug from name.\"\"\"\n        import re\n        slug = name.lower().strip()\n        slug = re.sub(r'[^a-z0-9\\s-]', '', slug)\n        slug = re.sub(r'\\s+', '-', slug)\n        slug = slug.strip('-')\n        return slug\n    \n    # Cart operations\n    \n    async def add_to_cart(\n        self,\n        user_id: str,\n        product_id: int,\n        quantity: int = 1,\n    ) -> CartItem:\n        \"\"\"Add product to cart.\"\"\"\n        try:\n            # Check if product exists and is available\n            product = await self.get_by_id(product_id)\n            if not product:\n                raise NotFoundException(\"Product not found\")\n            \n            if product.status != ProductStatus.ACTIVE:\n                raise ValidationException(\"Product is not available\")\n            \n            if product.track_inventory and product.stock_quantity < quantity:\n                raise ValidationException(\"Insufficient stock\")\n            \n            # Get or create cart\n            cart_query = select(Cart).where(Cart.user_id == user_id)\n            cart_result = await self.db.execute(cart_query)\n            cart = cart_result.scalar_one_or_none()\n            \n            if not cart:\n                cart = Cart(user_id=user_id)\n                self.db.add(cart)\n                await self.db.commit()\n                await self.db.refresh(cart)\n            \n            # Check if item already in cart\n            cart_item_query = select(CartItem).where(\n                and_(\n                    CartItem.cart_id == cart.id,\n                    CartItem.product_id == product_id\n                )\n            )\n            cart_item_result = await self.db.execute(cart_item_query)\n            cart_item = cart_item_result.scalar_one_or_none()\n            \n            if cart_item:\n                # Update quantity\n                new_quantity = cart_item.quantity + quantity\n                if product.track_inventory and product.stock_quantity < new_quantity:\n                    raise ValidationException(\"Insufficient stock\")\n                \n                cart_item.quantity = new_quantity\n                cart_item.total_price = cart_item.unit_price * new_quantity\n                cart_item.updated_at = datetime.now(timezone.utc)\n            else:\n                # Create new cart item\n                cart_item = CartItem(\n                    cart_id=cart.id,\n                    product_id=product_id,\n                    quantity=quantity,\n                    unit_price=product.sale_price or product.price,\n                    total_price=(product.sale_price or product.price) * quantity,\n                )\n                self.db.add(cart_item)\n            \n            # Update cart totals\n            await self._update_cart_totals(cart.id)\n            \n            await self.db.commit()\n            await self.db.refresh(cart_item)\n            \n            return cart_item\n            \n        except Exception as e:\n            await self.db.rollback()\n            logger.error(\"Failed to add to cart\", user_id=user_id, product_id=product_id, error=str(e))\n            raise\n    \n    async def _update_cart_totals(self, cart_id: int) -> None:\n        \"\"\"Update cart totals.\"\"\"\n        try:\n            # Calculate totals\n            totals_query = select(\n                func.count(CartItem.id).label(\"total_items\"),\n                func.sum(CartItem.total_price).label(\"total_amount\")\n            ).where(CartItem.cart_id == cart_id)\n            \n            totals_result = await self.db.execute(totals_query)\n            totals = totals_result.first()\n            \n            # Update cart\n            cart_query = select(Cart).where(Cart.id == cart_id)\n            cart_result = await self.db.execute(cart_query)\n            cart = cart_result.scalar_one_or_none()\n            \n            if cart:\n                cart.total_items = totals.total_items or 0\n                cart.total_amount = totals.total_amount or 0.0\n                cart.updated_at = datetime.now(timezone.utc)\n            \n        except Exception as e:\n            logger.error(\"Failed to update cart totals\", cart_id=cart_id, error=str(e))\n\n\n# Factory function for dependency injection\ndef get_enhanced_shop_service(db: AsyncSession = None) -> EnhancedShopService:\n    \"\"\"Get enhanced shop service instance.\"\"\"\n    return EnhancedShopService(db)